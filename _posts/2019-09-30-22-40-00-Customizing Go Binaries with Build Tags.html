---
layout: post
title: Customizing Go Binaries with Build Tags
network: digitalocean
date: September 30, 2019 at 10:40PM
url: https://www.digitalocean.com/community/tutorials/customizing-go-binaries-with-build-tags
image: http://ifttt.com/images/no_image_card.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="introduction">Introduction</h3>

<p>In Go, a <em>build tag</em>, or a build constraint, is an identifier added to a piece of code that determines when the file should be included in a package during the <code>build</code> process. This allows you to build different versions of your Go application from the same source code and to toggle between them in a fast and organized manner. Many developers use build tags to improve the workflow of building cross-platform compatible applications, such as programs that require code changes to account for variances between different operating systems. Build tags are also used for <a href="https://en.wikipedia.org/wiki/Integration_testing">integration testing</a>, allowing you to quickly switch between the integrated code and the code with a <a href="https://en.wikipedia.org/wiki/Mock_object">mock service or stub</a>, and for differing levels of feature sets within an application.</p>

<p>Let&rsquo;s take the problem of differing customer feature sets as an example. When writing some applications, you may want to control which features to include in the binary, such as an application that offers <strong>Free</strong>, <strong>Pro</strong>, and <strong>Enterprise</strong> levels. As the customer increases their subscription level in these applications, more features become unlocked and available. To solve this problem, you could maintain separate projects and try to keep them in sync with each other through the use of <code>import</code> statements. While this approach would work, over time it would become tedious and error prone. An alternative approach would be to use build tags.</p>

<p>In this article, you will use build tags in Go to generate different executable binaries that offer Free, Pro, and Enterprise feature sets of a sample application. Each will have a different set of features available, with the Free version being the default.</p>

<h2 id="prerequisites">Prerequisites</h2>

<p>To follow the example in this article, you will need:</p>

<ul>
<li>A Go workspace set up by following <a href="https://www.digitalocean.com/community/tutorial_series/how-to-install-and-set-up-a-local-programming-environment-for-go">How To Install Go and Set Up a Local Programming Environment</a>.</li>
</ul>

<h2 id="building-the-free-version">Building the Free Version</h2>

<p>Let&rsquo;s start by building the Free version of the application, as it will be the default when running <code>go build</code> without any build tags. Later on, we will use build tags to selectively add other parts to our program.</p>

<p>In the <code>src</code> directory, create a folder with the name of your application. This tutorial will use <code>app</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir <span class="highlight">app</span>
</li></ul></code></pre>
<p>Move into this folder:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd <span class="highlight">app</span>
</li></ul></code></pre>
<p>Next, make a new text file in your text editor of choice named <code>main.go</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano main.go
</li></ul></code></pre>
<p>Now, weâ€™ll define the Free version of the application. Add in the following contents to <code>main.go</code>:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

var features = []string{
  "Free Feature #1",
  "Free Feature #2",
}

func main() {
  for _, f := range features {
    fmt.Println("&gt;", f)
  }
}
</code></pre>
<p>In this file, we created a program that declares a <a href="https://www.digitalocean.com/community/tutorials/understanding-arrays-and-slices-in-go#slices">slice</a> named <code>features</code>, which holds two <a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-working-with-strings-in-go">strings</a> that represent the features of our Free application. The <code>main()</code> function in the application uses a <a href="https://www.digitalocean.com/community/tutorials/how-to-construct-for-loops-in-go#looping-through-sequential-data-types-with-rangeclause"><code>for</code> loop to <code>range</code></a> through the <code>features</code> slice and print all of the features available to the screen.</p>

<p>Save and exit the file. Now that this file is saved, we will no longer have to edit it for the rest of the article. Instead we will use build tags to change the features of the binaries we will build from it.</p>

<p>Build and run the program:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go build
</li><li class="line" prefix="$">./<span class="highlight">app</span>
</li></ul></code></pre>
<p>You&rsquo;ll receive the following output:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>&gt; Free Feature #1
&gt; Free Feature #2
</code></pre>
<p>The program has printed out our two free features, completing the Free version of our app.</p>

<p>So far, you created an application that has a very basic feature set. Next, you will build a way to add more features into the application at build time.</p>

<h2 id="adding-the-pro-features-with-go-build">Adding the Pro Features With <code>go build</code></h2>

<p>We have so far avoided making changes to <code>main.go</code>, simulating a common production environment in which code needs to be added without changing and possibly breaking the main code. Since we can&rsquo;t edit the <code>main.go</code> file, we&rsquo;ll need to use another mechanism for injecting more features into the <code>features</code> slice using build tags.</p>

<p>Let&rsquo;s create a new file called <code>pro.go</code> that will use an <a href="https://www.digitalocean.com/community/tutorials/understanding-init-in-go"><code>init()</code></a> function to append more features to the <code>features</code> slice:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano pro.go
</li></ul></code></pre>
<p>Once the editor has opened the file, add the following lines:</p>
<div class="code-label " title="pro.go">pro.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

func init() {
  features = append(features,
    "Pro Feature #1",
    "Pro Feature #2",
  )
}
</code></pre>
<p>In this code, we used <code>init()</code> to run code before the <code>main()</code> function of our application, followed by <code>append()</code> to add the Pro features to the <code>features</code> slice. Save and exit the file.</p>

<p>Compile and run the application using <code>go build</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go build
</li></ul></code></pre>
<p>Since there are now two files in our current directory (<code>pro.go</code> and <code>main.go</code>), <code>go build</code> will create a binary from both of them. Execute this binary:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">./<span class="highlight">app</span>
</li></ul></code></pre>
<p>This will give you the following feature set:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>&gt; Free Feature #1
&gt; Free Feature #2
<span class="highlight">&gt; Pro Feature #1</span>
<span class="highlight">&gt; Pro Feature #2</span>
</code></pre>
<p>The application now includes both the Pro and the Free features. However, this is not desirable: since there is no distinction between versions, the Free version now includes the features that are supposed to be only available in the Pro version. To fix this, you could include more code to manage the different tiers of the application, or you could use build tags to tell the Go tool chain which <code>.go</code> files to build and which to ignore. Let&rsquo;s add build tags in the next step.</p>

<h2 id="adding-build-tags">Adding Build Tags</h2>

<p>You can now use build tags to distinguish the Pro version of your application from the Free version.</p>

<p>Let&rsquo;s start by examining what a build tag looks like:</p>
<pre class="code-pre "><code class="code-highlight language-go">// +build <span class="highlight">tag_name</span>
</code></pre>
<p>By putting this line of code as the first line of your package and replacing <code><span class="highlight">tag_name</span></code> with the name of your build tag, you will tag this package as code that can be selectively included in the final binary. Let&rsquo;s see this in action by adding a build tag to the <code>pro.go</code> file to tell the <code>go build</code> command to ignore it unless the tag is specified. Open up the file in your text editor:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano pro.go
</li></ul></code></pre>
<p>Then add the following highlighted line:</p>
<div class="code-label " title="pro.go">pro.go</div><pre class="code-pre "><code langs=""><span class="highlight">// +build pro</span>

package main

func init() {
  features = append(features,
    "Pro Feature #1",
    "Pro Feature #2",
  )
}
</code></pre>
<p>At the top of the <code>pro.go</code> file, we added <code>// +build pro</code> followed by a blank newline. This trailing newline is required, otherwise Go interprets this as a comment. Build tag declarations must also be at the very top of a <code>.go</code> file. Nothing, not even comments, can be above build tags.</p>

<p>The <code>+build</code> declaration tells the <code>go build</code> command that this isn&rsquo;t a comment, but instead is a build tag. The second part is the <code>pro</code> tag. By adding this tag at the top of the <code>pro.go</code> file, the <code>go build</code> command will now only include the <code>pro.go</code> file with the <code>pro</code> tag is present.</p>

<p>Compile and run the application again:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go build
</li><li class="line" prefix="$">./<span class="highlight">app</span>
</li></ul></code></pre>
<p>You&rsquo;ll receive the following output:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>&gt; Free Feature #1
&gt; Free Feature #2
</code></pre>
<p>Since the <code>pro.go</code> file requires a <code>pro</code> tag to be present, the file is ignored and the application compiles without it.</p>

<p>When running the <code>go build</code> command, we can use the <code>-tags</code> flag to conditionally include code in the compiled source by adding the tag itself as an argument. Let&rsquo;s do this for the <code>pro</code> tag:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go build -tags pro
</li></ul></code></pre>
<p>This will output the following:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>&gt; Free Feature #1
&gt; Free Feature #2
&gt; Pro Feature #1
&gt; Pro Feature #2
</code></pre>
<p>Now we only get the extra features when we build the application using the <code>pro</code> build tag.</p>

<p>This is fine if there are only two versions, but things get complicated when you add in more tags. To add in the Enterprise version of our app in the next step, we will use multiple build tags joined together with Boolean logic.</p>

<h2 id="build-tag-boolean-logic">Build Tag Boolean Logic</h2>

<p>When there are multiple build tags in a Go package, the tags interact with each other using <a href="https://www.digitalocean.com/community/tutorials/understanding-boolean-logic-in-go">Boolean logic</a>. To demonstrate this, we will add the Enterprise level of our application using both the <code>pro</code> tag and the <code>enterprise</code> tag.</p>

<p>In order to build an Enterprise binary, we will need to include both the default features, the Pro level features, and a new set of features for Enterprise. First, open an editor and create a new file, <code>enterprise.go</code>, that will add the new Enterprise features:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano enterprise.go
</li></ul></code></pre>
<p>The contents of <code>enterprise.go</code> will look almost identical to <code>pro.go</code> but will contain new features. Add the following lines to the file:</p>
<div class="code-label " title="enterprise.go">enterprise.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

func init() {
  features = append(features,
    "Enterprise Feature #1",
    "Enterprise Feature #2",
  )
}
</code></pre>
<p>Save and exit the file.</p>

<p>Currently the <code>enterprise.go</code> file does not have any build tags, and as you learned when you added <code>pro.go</code>, this means that these features will be added to the Free version when executing <code>go.build</code>. For <code>pro.go</code>, you added <code>// +build pro</code> and a newline to the top of the file to tell <code>go build</code> that it should only be included when <code>-tags pro</code> is used. In this situation, you only needed one build tag to accomplish the goal. When adding the new Enterprise features, however, you first must also have the Pro features. </p>

<p>Let&rsquo;s add support for the <code>pro</code> build tag to <code>enterprise.go</code> first. Open the file with your text editor:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano enterprise.go
</li></ul></code></pre>
<p>Next add the build tag before the <code>package main</code> declaration and make sure to include a newline after the build tag:</p>
<div class="code-label " title="enterprise.go">enterprise.go</div><pre class="code-pre "><code langs=""><span class="highlight">// +build pro</span>

package main

func init() {
  features = append(features,
    "Enterprise Feature #1",
    "Enterprise Feature #2",
  )
}
</code></pre>
<p>Save and exit the file.</p>

<p>Compile and run the application without any tags:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go build
</li><li class="line" prefix="$">./<span class="highlight">app</span>
</li></ul></code></pre>
<p>You&rsquo;ll receive the following output:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>&gt; Free Feature #1
&gt; Free Feature #2
</code></pre>
<p>The Enterprise features no longer show up in the Free version. Now let&rsquo;s add the <code>pro</code> build tag and build and run the application again:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go build -tags pro
</li><li class="line" prefix="$">./<span class="highlight">app</span>
</li></ul></code></pre>
<p>You&rsquo;ll receive the following output:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>&gt; Free Feature #1
&gt; Free Feature #2
&gt; Enterprise Feature #1
&gt; Enterprise Feature #2
&gt; Pro Feature #1
&gt; Pro Feature #2
</code></pre>
<p>This is still not exactly what we need: The Enterprise features now show up when we try to build the Pro version. To solve this, we need to use another build tag. Unlike the <code>pro</code> tag, however, we need to now make sure both the <code>pro</code> and <code>enterprise</code> features are available.</p>

<p>The Go build system accounts for this situation by allowing the use of some basic Boolean logic in the build tags system.</p>

<p>Let&rsquo;s open <code>enterprise.go</code> again:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano enterprise.go
</li></ul></code></pre>
<p>Add another build tag, <code>enterprise</code>, on the same line as the <code>pro</code> tag:</p>
<div class="code-label " title="enterprise.go">enterprise.go</div><pre class="code-pre "><code langs="">// +build pro <span class="highlight">enterprise</span>

package main

func init() {
  features = append(features,
    "Enterprise Feature #1",
    "Enterprise Feature #2",
  )
}
</code></pre>
<p>Save and close the file.</p>

<p>Now let&rsquo;s compile and run the application with the new <code>enterprise</code> build tag.</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go build -tags enterprise
</li><li class="line" prefix="$">./<span class="highlight">app</span>
</li></ul></code></pre>
<p>This will give the following:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>&gt; Free Feature #1
&gt; Free Feature #2
&gt; Enterprise Feature #1
&gt; Enterprise Feature #2
</code></pre>
<p>Now we have lost the Pro features. This is because when we put multiple build tags on the same line in a <code>.go</code> file, <code>go build</code> interprets them as using <code>OR</code> logic. With the addition of the line <code>// +build pro enterprise</code>, the <code>enterprise.go</code> file will be built if <strong>either</strong> the <code>pro</code> build tag or the <code>enterprise</code> build tag is present. We need to set up the build tags correctly to require <strong>both</strong> and use <code>AND</code> logic instead.</p>

<p>Instead of putting both tags on the same line, if we put them on separate lines, then <code>go build</code> will interpret those tags using <code>AND</code> logic.</p>

<p>Open <code>enterprise.go</code> once again and let&rsquo;s separate the build tags onto multiple lines.</p>
<div class="code-label " title="enterprise.go">enterprise.go</div><pre class="code-pre "><code langs=""><span class="highlight">// +build pro</span>
<span class="highlight">// +build enterprise</span>

package main

func init() {
  features = append(features,
    "Enterprise Feature #1",
    "Enterprise Feature #2",
  )
}
</code></pre>
<p>Now compile and run the application with the new <code>enterprise</code> build tag.</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go build -tags enterprise
</li><li class="line" prefix="$">./<span class="highlight">app</span>
</li></ul></code></pre>
<p>You&rsquo;ll receive the following output:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>&gt; Free Feature #1
&gt; Free Feature #2
</code></pre>
<p>Still not quite there: Because an <code>AND</code> statement requires both elements to be considered <code>true</code>,  we need to use both <code>pro</code> and <code>enterprise</code> build tags. </p>

<p>Let&rsquo;s try again:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go build -tags "enterprise pro"
</li><li class="line" prefix="$">./<span class="highlight">app</span>
</li></ul></code></pre>
<p>You&rsquo;ll receive the following output:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>&gt; Free Feature #1
&gt; Free Feature #2
&gt; Enterprise Feature #1
&gt; Enterprise Feature #2
&gt; Pro Feature #1
&gt; Pro Feature #2
</code></pre>
<p>Now our application can be built from the same source tree in multiple ways unlocking the features of the application accordingly.</p>

<p>In this example, we used a new <code>// +build</code> tag to signify <code>AND</code> logic, but there are alternative ways to represent Boolean logic with build tags. The following table holds some examples of other syntactic formatting for build tags, along with their Boolean equivalent:</p>

<table><thead>
<tr>
<th style="text-align: center">Build Tag Syntax</th>
<th>Build Tag Sample</th>
<th>Boolean Statement</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">Space-separated elements</td>
<td><code>// +build pro enterprise</code></td>
<td><code>pro</code> OR <code>enterprise</code></td>
</tr>
<tr>
<td style="text-align: center">Comma-separated elements</td>
<td><code>// +build pro,enterprise</code></td>
<td><code>pro</code> AND <code>enterprise</code></td>
</tr>
<tr>
<td style="text-align: center">Exclamation point elements</td>
<td><code>// +build !pro</code></td>
<td>NOT <code>pro</code></td>
</tr>
</tbody></table>

<h2 id="conclusion">Conclusion</h2>

<p>In this tutorial, you used build tags to allow you to control which of your code got compiled into the binary. First, you declared build tags and used them with <code>go build</code>, then you combined multiple tags with Boolean logic. You then built a program that represented the different feature sets of a Free, Pro, and Enterprise version, showing the powerful level of control that build tags can give you over your project.</p>

<p>If you&rsquo;d like to learn more about build tags, take a look at the <a href="https://golang.org/pkg/go/build/#hdr-Build_Constraints">Golang documentation on the subject</a>, or continue to explore our <a href="https://www.digitalocean.com/community/tutorial_series/how-to-code-in-go">How To Code in Go series</a>.</p>
