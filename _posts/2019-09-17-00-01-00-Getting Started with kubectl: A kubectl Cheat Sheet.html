---
layout: post
title: Getting Started with kubectl: A kubectl Cheat Sheet
network: digitalocean
date: September 17, 2019 at 12:01AM
url: https://www.digitalocean.com/community/tutorials/getting-started-with-kubectl-a-kubectl-cheat-sheet
image: http://ifttt.com/images/no_image_card.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="introduction">Introduction</h3>

<p><a href="https://kubernetes.io/docs/reference/kubectl/overview/">Kubectl</a> is a command-line tool designed to manage Kubernetes objects and clusters. It provides a command-line interface for performing common operations like creating and scaling Deployments, switching contexts, and accessing a shell in a running container.</p>

<p><strong>How to Use This Guide:</strong></p>

<ul>
<li>This guide is in cheat sheet format with self-contained command-line snippets.</li>
<li>It is not an exhaustive list of kubectl commands, but contains many common operations and use cases. For a more thorough reference, consult the <a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands">Kubectl Reference Docs</a></li>
<li>Jump to any section that is relevant to the task you are trying to complete.</li>
</ul>

<h2 id="prerequisites">Prerequisites</h2>

<ul>
<li>To use kubectl, you&rsquo;ll need a Kubernetes cluster available to you. To learn how to create a Kubernetes cluster from scratch, you can consult <a href="https://www.digitalocean.com/community/tutorials/how-to-create-a-kubernetes-cluster-using-kubeadm-on-ubuntu-18-04">How To Create a Kubernetes Cluster Using Kubeadm on Ubuntu 18.04</a>. Alternatively, you can provision a managed Kubernetes cluster in minutes using DigitalOcean Kubernetes. To get started creating a DigitalOcean Kubernetes cluster, consult <a href="https://www.digitalocean.com/docs/kubernetes/how-to/create-clusters/">How to Create Kubernetes Clusters Using the Control Panel</a>. </li>
<li>You&rsquo;ll also need a remote machine on which you&rsquo;ll install and run kubectl. kubectl can run on many different operating systems.</li>
</ul>

<h3 id="sample-deployment">Sample Deployment</h3>

<p>To demonstrate some of the operations and commands in this cheat sheet, we&rsquo;ll use a sample Deployment that runs 2 replicas of Nginx:</p>
<div class="code-label " title="nginx-deployment.yaml">nginx-deployment.yaml</div><pre class="code-pre "><code langs="">apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 80
</code></pre>
<p>Copy and paste this manifest into a file called <code>nginx-deployment.yaml</code>.</p>

<h2 id="installing-kubectl">Installing kubectl</h2>

<p><span class='note'><strong>Note:</strong> These commands have only been tested on an <strong>Ubuntu 18.04</strong> machine. To learn how to install kubectl on other operating systems, consult <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/">Install and Set Up kubectl</a> from the Kubernetes docs.<br></span></p>

<p>First, update your local package index and install required dependencies:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https
</li></ul></code></pre>
<p>Then add the Google Cloud GPG key to APT and make the kubectl package available to your system:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -
</li><li class="line" prefix="$">echo "deb https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee -a /etc/apt/sources.list.d/kubernetes.list
</li><li class="line" prefix="$">sudo apt-get update
</li></ul></code></pre>
<p>Finally, install kubectl:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt-get install -y kubectl
</li></ul></code></pre>
<p>Test that the installation succeeded using <code>version</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl version
</li></ul></code></pre>
<h2 id="setting-up-shell-autocompletion">Setting Up Shell Autocompletion</h2>

<p><span class='note'><strong>Note:</strong> These commands have only been tested on an <strong>Ubuntu 18.04</strong> machine. To learn how to set up autocompletion on other operating systems, consult <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/">Install and Set Up kubectl</a> from the Kubernetes docs.<br></span></p>

<p>kubectl includes a shell autocompletion script that you can make available to your system&rsquo;s existing shell autocompletion software.</p>

<h3 id="installing-kubectl-autocompletion">Installing kubectl Autocompletion</h3>

<p>First, check if you have <a href="https://github.com/scop/bash-completion">bash-completion</a> installed:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">type _init_completion
</li></ul></code></pre>
<p>You should see some script output.</p>

<p>Next, <code>source</code> the kubectl autocompletion script in your <code>~/.bashrc</code> file:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">echo 'source &lt;(kubectl completion bash)' &gt;&gt;~/.bashrc
</li><li class="line" prefix="$">. ~/.bashrc
</li></ul></code></pre>
<p><strong>Alternatively</strong>, you can add the completion script to the <code>/etc/bash_completion.d</code> directory:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl completion bash &gt;/etc/bash_completion.d/kubectl
</li></ul></code></pre>
<h3 id="usage">Usage</h3>

<p>To use the autocompletion feature, press the <code>TAB</code> key to display available kubectl commands:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl TAB TAB
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>annotate       apply          autoscale      completion     cordon         delete         drain          explain        kustomize      options        port-forward   rollout        set            uncordon
api-resources  attach         certificate    config         cp             describe
. . .
</code></pre>
<p>You can also display available commands after partially typing a command:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl d TAB
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>delete    describe  diff      drain
</code></pre>
<h2 id="connecting-configuring-and-using-contexts">Connecting, Configuring and Using Contexts</h2>

<h3 id="connecting">Connecting</h3>

<p>To test that kubectl can authenticate with and access your Kubernetes cluster, use <code>cluster-info</code>: </p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl cluster-info
</li></ul></code></pre>
<p>If kubectl can successfully authenticate with your cluster, you should see the following output:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Kubernetes master is running at https://<span class="highlight">kubernetes_master_endpoint</span>
CoreDNS is running at https://<span class="highlight">coredns_endpoint</span>

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
</code></pre>
<p>kubectl is configured using <em>kubeconfig</em> configuration files. By default, kubectl will look for a file called <code>config</code> in the <code>$HOME/.kube</code> directory. To change this, you can set the <code>$KUBECONFIG</code> environment variable to a custom kubeconfig file, or pass in the custom file at execution time using the <code>--kubeconfig</code> flag:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl cluster-info --kubeconfig=<span class="highlight">path_to_your_kubeconfig_file</span>
</li></ul></code></pre>
<p><span class='note'><strong>Note:</strong> If you&rsquo;re using a managed Kubernetes cluster, your cloud provider should have made its kubeconfig file available to you.<br></span></p>

<p>If you don&rsquo;t want to use the <code>--kubeconfig</code> flag with every command, <strong>and there is no existing <code>~/.kube/config</code> file</strong>, create a directory called <code>~/.kube</code> in your home directory if it doesn&rsquo;t already exist, and copy in the kubeconfig file, renaming it to <code>config</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir ~/.kube
</li><li class="line" prefix="$">cp <span class="highlight">your_kubeconfig_file</span> ~/.kube/config
</li></ul></code></pre>
<p>Now, run <code>cluster-info</code> once again to test your connection.</p>

<h3 id="modifying-your-kubectl-configuration">Modifying your kubectl Configuration</h3>

<p>You can also modify your config using the <code>kubectl config</code> set of commands.</p>

<p>To view your kubectl configuration, use the <code>view</code> subcommand:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl config view
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: DATA+OMITTED
. . .
</code></pre>
<p><strong>Modifying Clusters</strong></p>

<p>To fetch a list of clusters defined in your kubeconfig, use <code>get-clusters</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl config get-clusters
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME
do-nyc1-sammy
</code></pre>
<p>To add a cluster to your config, use the <code>set-cluster</code> subcommand:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl config set-cluster <span class="highlight">new_cluster</span> --server=<span class="highlight">server_address</span> --certificate-authority=<span class="highlight">path_to_certificate_authority</span>
</li></ul></code></pre>
<p>To delete a cluster from your config, use <code>delete-cluster</code>:</p>

<p><span class='note'><strong>Note:</strong> This only deletes the cluster from your config and does not delete the actual Kubernetes cluster.<br></span></p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl config delete-cluster
</li></ul></code></pre>
<p><strong>Modifying Users</strong></p>

<p>You can perform similar operations for users using <code>set-credentials</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl config set-credentials <span class="highlight">username</span> --client-certificate=<span class="highlight">/path/to/cert/file</span> --client-key=<span class="highlight">/path/to/key/file</span>
</li></ul></code></pre>
<p>To delete a user from your config, you can run <code>unset</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl config unset users.<span class="highlight">username</span>
</li></ul></code></pre>
<p><strong>Contexts</strong></p>

<p>A <em>context</em> in Kubernetes is an object that contains a set of access parameters for your cluster. It consists of a <code>cluster</code>, <code>namespace</code>, and <code>user</code> triple. Contexts allow you to quickly switch between different sets of cluster configuration. </p>

<p>To see your current context, you can use <code>current-context</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl config current-context
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>do-nyc1-sammy
</code></pre>
<p>To see a list of all configured contexts, run <code>get-contexts</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl config get-contexts
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>CURRENT   NAME            CLUSTER         AUTHINFO              NAMESPACE
*         do-nyc1-sammy   do-nyc1-sammy   do-nyc1-sammy-admin
</code></pre>
<p>To set a context, use <code>set-context</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl config set-context <span class="highlight">context_name</span> --cluster=<span class="highlight">cluster_name</span> --user=<span class="highlight">user_name</span> --namespace=<span class="highlight">namespace</span>
</li></ul></code></pre>
<p>You can switch between contexts with <code>use-context</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl config use-context <span class="highlight">context_name</span>
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Switched to context "do-nyc1-sammy"
</code></pre>
<p>And you can delete a context with <code>delete-context</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl config delete-context context_name
</li></ul></code></pre>
<h2 id="using-namespaces">Using Namespaces</h2>

<p>A Namespace in Kubernetes is an abstraction that allows you to subdivide your cluster into multiple <em>virtual clusters</em>. By using Namespaces you can divide cluster resources among multiple teams and scope objects appropriately. For example, you can have a <code>prod</code> Namespace for production workloads, and a <code>dev</code> Namespace for development and test workloads.</p>

<p>To fetch and print a list of all the Namespaces in your cluster, use <code>get namespace</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get namespace
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME              STATUS   AGE
default           Active   2d21h
kube-node-lease   Active   2d21h
kube-public       Active   2d21h
kube-system       Active   2d21h
</code></pre>
<p>To set a Namespace for your current context, use <code>set-context --current</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl config set-context --current --namespace=<span class="highlight">namespace_name</span>
</li></ul></code></pre>
<p>To create a Namespace, use <code>create namespace</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl create namespace <span class="highlight">namespace_name</span>
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>namespace/sammy created
</code></pre>
<p>Similarly, to delete a Namespace, use <code>delete namespace</code>:</p>

<p><span class='warning'><strong>Warning:</strong> Deleting a Namespace will delete <strong>everything</strong> in the Namespace, including running Deployments, Pods, and other workloads. Only run this command if you&rsquo;re sure you&rsquo;d like to kill whatever&rsquo;s running in the Namespace or if you&rsquo;re deleting an empty Namespace.<br></span></p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl delete namespace <span class="highlight">namespace_name</span>
</li></ul></code></pre>
<p>To fetch all Pods in a given Namespace or to perform other operations on resources in a given Namespace, make sure to include the <code>--namespace</code> flag:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get pods --namespace=<span class="highlight">namespace_name</span>
</li></ul></code></pre>
<h2 id="managing-kubernetes-resources">Managing Kubernetes Resources</h2>

<h3 id="general-syntax">General Syntax</h3>

<p>The general syntax for most kubectl management commands is:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl command type name flags
</li></ul></code></pre>
<p>Where</p>

<ul>
<li><code>command</code> is an operation you&rsquo;d like to perform, like <code>create</code></li>
<li><code>type</code> is the Kubernetes resource type, like <code>deployment</code></li>
<li><code>name</code> is the resource&rsquo;s name, like <code>app_frontend</code></li>
<li><code>flags</code> are any optional flags you&rsquo;d like to include</li>
</ul>

<p>For example the following command retrieves information about a Deployment named <code>app_frontend</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get deployment app_frontend
</li></ul></code></pre>
<h2 id="declarative-management-and-kubectl-apply">Declarative Management and <code>kubectl apply</code></h2>

<p>The recommended approach to managing workloads on Kubernetes is to rely on the cluster&rsquo;s declarative design as much as possible. This means that instead of running a series of commands to create, update, delete, and restart running Pods, you should define the workloads, services, and systems you&rsquo;d like to run in YAML manifest files, and provide these files to Kubernetes, which will handle the rest.</p>

<p>In practice, this means using the <code>kubectl apply</code> command, which applies a particular configuration to a given resource. If the target resource doesn&rsquo;t exist, then Kubernetes will create the resource. If the resource already exists, then Kubernetes will save the current revision, and update the resource according to the new configuration. This <em>declarative</em> approach exists in contrast to the <em>imperative</em> approach of running the <code>kubectl create</code> , <code>kubectl edit</code>, and the <code>kubectl scale</code> set of commands to manage resources. To learn more about the different ways of managing Kubernetes resources, consult <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/object-management/">Kubernetes Object Management</a> from the Kubernetes docs.</p>

<p><strong>Rolling out a Deployment</strong></p>

<p>For example, to deploy the sample Nginx Deployment to your cluster, use <code>apply</code> and provide the path to the <code>nginx-deployment.yaml</code> manifest file:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f nginx-deployment.yaml
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>deployment.apps/nginx-deployment created
</code></pre>
<p>The <code>-f</code> flag is used to specify a filename or URL containing a valid configuration. If you&rsquo;d like to <code>apply</code> all manifests from a directory, you can use the <code>-k</code> flag: </p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -k <span class="highlight">manifests_dir</span>
</li></ul></code></pre>
<p>You can track the rollout status using <code>rollout status</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl rollout status deployment/nginx-deployment
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Waiting for deployment "nginx-deployment" rollout to finish: 1 of 2 updated replicas are available...
deployment "nginx-deployment" successfully rolled out
</code></pre>
<p>An alternative to <code>rollout status</code> is the <code>kubectl get</code> command, along with the <code>-w</code> (watch) flag:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get deployment -w
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   0/2     2            0           3s
nginx-deployment   1/2     2            1           3s
nginx-deployment   2/2     2            2           3s
</code></pre>
<p>Using <code>rollout pause</code> and <code>rollout resume</code>, you can pause and resume the rollout of a Deployment:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl rollout pause deployment/nginx-deployment
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>deployment.extensions/nginx-deployment paused
</code></pre><pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl rollout resume deployment/nginx-deployment
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>deployment.extensions/nginx-deployment resumed
</code></pre>
<p><strong>Modifying a Running Deployment</strong></p>

<p>If you&rsquo;d like to modify a running Deployment, you can make changes to its manifest file and then run <code>kubectl apply</code> again to apply the update. For example, we&rsquo;ll modify the <code>nginx-deployment.yaml</code> file to change the number of replicas from <code>2</code> to <code>3</code>:</p>
<div class="code-label " title="nginx-deployment.yaml">nginx-deployment.yaml</div><pre class="code-pre "><code langs="">. . .
spec:
  replicas: <span class="highlight">3</span>
  selector:
    matchLabels:
      app: nginx
. . .
</code></pre>
<p>The <code>kubectl diff</code> command allows you to see a diff between currently running resources, and the changes proposed in the supplied configuration file:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl diff -f nginx-deployment.yaml
</li></ul></code></pre>
<p>Now allow Kubernetes to perform the update using <code>apply</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f nginx-deployment.yaml
</li></ul></code></pre>
<p>Running another <code>get deployment</code> should confirm the addition of a third replica.</p>

<p>If you run <code>apply</code> again without modifying the manifest file, Kubernetes will detect that no changes were made and won&rsquo;t perform any action. </p>

<p>Using <code>rollout history</code> you can see a list of the Deployment&rsquo;s previous revisions:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl rollout history deployment/nginx-deployment
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>deployment.extensions/nginx-deployment
REVISION  CHANGE-CAUSE
1         &lt;none&gt;

</code></pre>
<p>With <code>rollout undo</code>, you can revert a Deployment to any of its previous revisions:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl rollout undo deployment/nginx-deployment --to-revision=<span class="highlight">1</span>
</li></ul></code></pre>
<p><strong>Deleting a Deployment</strong></p>

<p>To delete a running Deployment, use <code>kubectl delete</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl delete -f nginx-deployment.yaml
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>deployment.apps "nginx-deployment" deleted
</code></pre>
<h2 id="imperative-management">Imperative Management</h2>

<p>You can also use a set of imperative commands to directly manipulate and manage Kubernetes resources.</p>

<p><strong>Creating a Deployment</strong></p>

<p>Use <code>create</code> to create an object from a file, URL, or STDIN. Note that unlike <code>apply</code>, if an object with the same name already exists, the operation will fail. The <code>--dry-run</code> flag allows you to preview the result of the operation without actually performing it:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl create -f nginx-deployment.yaml --dry-run
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>deployment.apps/nginx-deployment created (dry-run)
</code></pre>
<p>We can now create the object:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl create -f nginx-deployment.yaml
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>deployment.apps/nginx-deployment created
</code></pre>
<p><strong>Modifying a Running Deployment</strong></p>

<p>Use <code>scale</code> to scale the number of replicas for the Deployment from 2 to 4:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl scale --replicas=4 deployment/nginx-deployment
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>deployment.extensions/nginx-deployment scaled
</code></pre>
<p>You can edit any object in-place using <code>kubectl edit</code>. This will open up the object&rsquo;s manifest in your default editor:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl edit deployment/nginx-deployment
</li></ul></code></pre>
<p>You should see the following manifest file in your editor:</p>
<div class="code-label " title="nginx-deployment">nginx-deployment</div><pre class="code-pre "><code langs=""># Please edit the object below. Lines beginning with a '#' will be ignored,
# and an empty file will abort the edit. If an error occurs while saving this file will be
# reopened with the relevant failures.
#
apiVersion: extensions/v1beta1
kind: Deployment
. . . 
spec:
  progressDeadlineSeconds: 600
  replicas: 4
  revisionHistoryLimit: 10
  selector:
    matchLabels:
. . .
</code></pre>
<p>Change the <code>replicas</code> value from <code>4</code> to <code>2</code>, then save and close the file.</p>

<p>Now run a <code>get</code> to inspect the changes:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get deployment/nginx-deployment
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   2/2     2            2           6m40s
</code></pre>
<p>We&rsquo;ve successfully scaled the Deployment back down to 2 replicas on-the-fly. You can update most of a Kubernetes&rsquo; object&rsquo;s fields in a similar manner.</p>

<p>Another useful command for modifying objects in-place is <code>kubectl patch</code>. Using <code>patch</code>, you can update an object&rsquo;s fields on-the-fly without having to open up your editor. <code>patch</code> also allows for more complex updates with various merging and patching strategies. To learn more about these, consult <a href="https://kubernetes.io/docs/tasks/run-application/update-api-object-kubectl-patch">Update API Objects in Place Using kubectl patch</a>. </p>

<p>The following command will patch the <code>nginx-deployment</code> object to update the <code>replicas</code> field from <code>2</code> to <code>4</code>;  <code>deploy</code> is shorthand for the <code>deployment</code> object.</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl patch deploy nginx-deployment -p '{"spec": {"replicas": 4}}'
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>deployment.extensions/nginx-deployment patched
</code></pre>
<p>We can now inspect the changes:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get deployment/nginx-deployment
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   4/4     4            4           18m
</code></pre>
<p>You can also create a Deployment imperatively using the <code>run</code> command. <code>run</code> will create a Deployment using an image provided as a parameter:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl run nginx-deployment --image=nginx --port=80 --replicas=2
</li></ul></code></pre>
<p>The <code>expose</code> command lets you quickly expose a running Deployment with a Kubernetes Service, allowing connections from outside your Kubernetes cluster:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl expose deploy nginx-deployment --type=LoadBalancer --port=80 --name=nginx-svc
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>service/nginx-svc exposed
</code></pre>
<p>Here we&rsquo;ve exposed the <code>nginx-deployment</code> Deployment as a LoadBalancer Service, opening up port <code>80</code> to external traffic and directing it to container port <code>80</code>. We name the service <code>nginx-svc</code>. Using the LoadBalancer Service type, a cloud load balancer is automatically provisioned and configured by Kubernetes. To get the Service&rsquo;s external IP address, use <code>get</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get svc nginx-svc
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME        TYPE           CLUSTER-IP      EXTERNAL-IP      PORT(S)        AGE
nginx-svc   LoadBalancer   10.245.26.242   203.0.113.0   80:30153/TCP   22m
</code></pre>
<p>You can access the running Nginx containers by navigating to <code>EXTERNAL-IP</code> in your web browser.</p>

<h2 id="inspecting-workloads-and-debugging">Inspecting Workloads and Debugging</h2>

<p>There are several commands you can use to get more information about workloads running in your cluster.</p>

<p><strong>Inspecting Kubernetes Resources</strong></p>

<p><code>kubectl get</code> fetches a given Kubernetes resource and displays some basic information associated with it:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get deployment -o wide
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME               READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES   SELECTOR
nginx-deployment   4/4     4            4           29m   nginx        nginx    app=nginx
</code></pre>
<p>Since we did not provide a Deployment name or Namespace, kubectl fetches all Deployments in the current Namespace. The <code>-o</code> flag provides additional information like <code>CONTAINERS</code> and <code>IMAGES</code>.</p>

<p>In addition to <code>get</code>, you can use <code>describe</code> to fetch a detailed description of the resource and associated resources:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl describe deploy nginx-deployment
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Name:                   nginx-deployment
Namespace:              default
CreationTimestamp:      Wed, 11 Sep 2019 12:53:42 -0400
Labels:                 run=nginx-deployment
Annotations:            deployment.kubernetes.io/revision: 1
Selector:               run=nginx-deployment
. . . 
</code></pre>
<p>The set of information presented will vary depending on the resource type. You can also use this command without specifying a resource name, in which case information will be provided for all resources of that type in the current Namespace.</p>

<p><code>explain</code> allows you to quickly pull configurable fields for a given resource type:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl explain deployment.spec
</li></ul></code></pre>
<p>By appending additional fields you can dive deeper into the field hierarchy:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl explain deployment.spec.template.spec
</li></ul></code></pre>
<p><strong>Gaining Shell Access to a Container</strong></p>

<p>To gain shell access into a running container, use <code>exec</code>. First, find the Pod that contains the running container you&rsquo;d like access to:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get pod
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>nginx-deployment-8859878f8-7gfw9   1/1     Running   0          109m
nginx-deployment-8859878f8-z7f9q   1/1     Running   0          109m
</code></pre>
<p>Let&rsquo;s <code>exec</code> into the first Pod. Since this Pod has only one container, we don&rsquo;t need to use the <code>-c</code> flag to specify which container we&rsquo;d like to <code>exec</code> into.</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl exec -i -t nginx-deployment-8859878f8-7gfw9 -- /bin/bash
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>root@nginx-deployment-8859878f8-7gfw9:/#
</code></pre>
<p>You now have shell access to the Nginx container. The <code>-i</code> flag passes STDIN to the container, and <code>-t</code> gives you an interactive TTY. The <code>--</code>  double-dash acts as a separator for the <code>kubectl</code> command and the command you&rsquo;d like to run inside the container. In this case, we are running <code>/bin/bash</code>.</p>

<p>To run commands inside the container without opening a full shell, omit the <code>-i</code> and <code>-t</code> flags, and substitute the command you&rsquo;d like to run instead of <code>/bin/bash</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl exec nginx-deployment-8859878f8-7gfw9 ls
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>bin
boot
dev
etc
home
lib
lib64
media
. . .
</code></pre>
<p><strong>Fetching Logs</strong></p>

<p>Another useful command is <code>logs</code>, which prints logs for Pods and containers, including terminated containers.  </p>

<p>To stream logs to your terminal output, you can use the <code>-f</code> flag:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl logs -f nginx-deployment-8859878f8-7gfw9
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>10.244.2.1 - - [12/Sep/2019:17:21:33 +0000] "GET / HTTP/1.1" 200 612 "-" "203.0.113.0" "-"
2019/09/16 17:21:34 [error] 6#6: *1 open() "/usr/share/nginx/html/favicon.ico" failed (2: No such file or directory), client: 10.244.2.1, server: localhost, request: "GET /favicon.ico HTTP/1.1", host: "203.0.113.0", referrer: "http://203.0.113.0"
. . .
</code></pre>
<p>This command will keep running in your terminal until interrupted with a <code>CTRL+C</code>. You can omit the <code>-f</code> flag  if you&rsquo;d like to print log output and exit immediately. </p>

<p>You can also use the <code>-p</code> flag to fetch logs for a terminated container. When this option is used within a Pod that had a prior running container instance, <code>logs</code> will print output from the terminated container:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl logs -p nginx-deployment-8859878f8-7gfw9
</li></ul></code></pre>
<p>The <code>-c</code> flag allows you to specify the container you&rsquo;d like to fetch logs from, if the Pod has multiple containers. You can use the <code>--all-containers=true</code> flag to fetch logs from all containers in the Pod.</p>

<p><strong>Port Forwarding and Proxying</strong></p>

<p>To gain network access to a Pod, you can use <code>port-forward</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo kubectl port-forward pod/nginx-deployment-8859878f8-7gfw9 80:80
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Forwarding from 127.0.0.1:80 -&gt; 80
Forwarding from [::1]:80 -&gt; 80
</code></pre>
<p>In this case we use <code>sudo</code> because local port <code>80</code> is a protected port. For most other ports you can omit <code>sudo</code> and run the kubectl command as your system user. </p>

<p>Here we forward local port <code>80</code> (preceding the colon) to the Pod&rsquo;s container port <code>80</code> (after the colon).</p>

<p>You can also use <code>deploy/nginx-deployment</code> as the resource type and name to forward to. If you do this, the local port will be forwarded to the Pod selected by the Deployment. </p>

<p>The <code>proxy</code> command can be used to access the Kubernetes API server locally:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl proxy --port=8080
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Starting to serve on 127.0.0.1:8080
</code></pre>
<p>In another shell, use <code>curl</code> to explore the API:</p>
<pre class="code-pre "><code langs="">curl http://localhost:8080/api/
</code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>{
  "kind": "APIVersions",
  "versions": [
    "v1"
  ],
  "serverAddressByClientCIDRs": [
    {
      "clientCIDR": "0.0.0.0/0",
      "serverAddress": "203.0.113.0:443"
    }
  ]
</code></pre>
<p>Close the proxy by hitting <code>CTRL-C</code>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>This guide covers some of the more common kubectl commands you may use when managing a Kubernetes cluster and workloads you&rsquo;ve deployed to it. </p>

<p>You can learn more about kubectl by consulting the official Kubernetes <a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands">reference documentation</a>.</p>

<p>There are many more commands and variations that you may find useful as part of your work with kubectl. To learn more about all of your available options, you can run:</p>
<pre class="code-pre "><code langs="">kubectl --help
</code></pre>