---
layout: post
title: Установка WordPress с помощью Docker Compose
network: digitalocean
date: January 21, 2020 at 10:08PM
url: https://www.digitalocean.com/community/tutorials/how-to-install-wordpress-with-docker-compose-ru
image: https://assets.digitalocean.com/articles/docker-wordpress/wp_language_select.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="Введение">Введение</h3>

<p><a href="https://wordpress.org/">WordPress</a> — бесплатная <a href="https://www.digitalocean.com/community/tutorials/digitalocean-community-glossary#content-management-system">система управления контентом (CMS)</a> с открытым исходным кодом, которая опирается на базу данных <a href="https://www.mysql.com/">MySQL</a> и обрабатывает запросы с помощью <a href="https://www.php.net/">PHP</a>. Благодаря огромному количеству плагинов и системе шаблонов, а также тому факту, что большая часть административных функций может производиться через веб-интерфейс, WordPress завоевала популярность среди создателей самых разных сайтов, от блогов и страниц с описанием продукта и до сайтов электронной торговли.</p>

<p>Для запуска WordPress, как правило, требуется установка стека <a href="https://www.digitalocean.com/community/tutorials/digitalocean-community-glossary#lamp">LAMP</a> (Linux, Apache, MySQL и PHP) или <a href="https://www.digitalocean.com/community/tutorials/digitalocean-community-glossary#lemp">LEMP</a> (Linux, Nginx, MySQL и PHP), что может занять много времени. С помощью таких инструментов, как <a href="https://www.docker.com/">Docker</a> и <a href="https://docs.docker.com/compose/">Docker Compose</a>, вы можете упростить процесс настройки предпочитаемого стека и установки WordPress. Вместо установки отдельных компонентов вручную, вы можете использовать <em>образы</em>, которые обладают такими стандартными элементами как библиотеки, файлы конфигурации и переменные среды, и запускать эти образы в <em>контейнерах</em>, т.е. изолированных процессов, запущенных в общей операционной системе. Кроме того, используя Compose, вы можете координировать действия нескольких контейнеров, например, приложения и базы данных, которые будут коммуницировать друг с другом.</p>

<p>В этом обучающем руководстве вы будете выполнять установку WordPress с несколькими контейнерами. Ваши контейнеры будут включать базу данных MySQL, веб-сервер Nginx и непосредственно WordPress. Также вы должны будете обеспечить защиту установки, получая с помощью <a href="https://letsencrypt.org/">Let&rsquo;s Encrypt​​​​​​</a> сертификаты TLS/SSL для доменов, которые вы хотите привязать к вашему сайту. Наконец, вы настроите задание <a href="https://www.digitalocean.com/community/tutorials/how-to-schedule-routine-tasks-with-cron-and-anacron-on-a-vps"><code>cron</code></a> для обновления ваших сертификатов, чтобы ваш домен оставался защищенным.</p>

<h2 id="Предварительные-требования">Предварительные требования</h2>

<p>Для данного обучающего модуля вам потребуется следующее:</p>

<ul>
<li>Сервер на базе Ubuntu 18.04, а также пользователь без прав root с привилегиями <code>sudo</code> и активный брандмауэр. Дополнительную информацию о настройке этих параметров см. в <a href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04">руководстве по первоначальной настройке сервера</a>.</li>
<li>Система Docker, установленная на сервере в соответствии с шагами 1 и 2 руководства <a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-18-04">«Установка и использование Docker в Ubuntu 18.04»</a>.</li>
<li>Docker Compose, установленный на сервере, в соответствии с шагом 1 руководства <a href="https://www.digitalocean.com/community/tutorials/how-to-install-docker-compose-on-ubuntu-18-04">Установка Docker Compose в Ubuntu 18.04</a>.</li>
<li>Зарегистрированное доменное имя. В этом обучающем руководстве мы будем использовать <strong>example.com</strong>. Вы можете получить бесплатный домен на <a href="http://www.freenom.com/en/index.html">Freenom</a> или зарегистрировать доменное имя по вашему выбору.</li>
<li><p>На вашем сервере должны быть настроены обе нижеследующие записи DNS. Вы можете воспользоваться <a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-digitalocean-dns">введением в работу с DigitalOcean DNS</a>, чтобы получить подробную информацию о добавлении доменов в учетную запись DigitalOcean, если вы используете этот способ:</p>

<ul>
<li>Запись A, где <code><span class="highlight">example.com</span></code> указывает на публичный IP-адрес вашего сервера.</li>
<li>Запись A, где <code>www.<span class="highlight">example.com</span></code> указывает на публичный IP-адрес вашего сервера.</li>
</ul></li>
</ul>

<h2 id="Шаг-1-—-Настройка-конфигурации-веб-сервера">Шаг 1 — Настройка конфигурации веб-сервера</h2>

<p>Перед запуском контейнеров прежде всего необходимо настроить конфигурацию нашего веб-сервера Nginx. Наш файл конфигурации будет включать несколько специфических для Wordpress блоков расположения наряду с блоками расположения, которые будут направлять передаваемые Let&rsquo;s Encrypt запросы верификации клиенту Certbot для автоматизированного обновления сертификатов.</p>

<p>Во-первых, создайте директорию проекта для настройки WordPress с именем <code>&lt; <span class="highlight">wordpress</span></code> и перейдите в эту директорию:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir <span class="highlight">wordpress</span> &amp;&amp; cd <span class="highlight">wordpress</span>
</li></ul></code></pre>
<p>Затем создайте директорию для файла конфигурации:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir nginx-conf
</li></ul></code></pre>
<p>Откройте файл с помощью <code>nano</code> или своего любимого редактора:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano nginx-conf/nginx.conf
</li></ul></code></pre>
<p>В этом файле мы добавим серверный блок с директивами для имени нашего сервера и корневого каталога документов, а также блок расположения для направления запросов сертификатов от клиента Certbot, обработки PHP и запросов статичных активов.</p>

<p>Добавьте в файл следующий код. Обязательно замените <code><span class="highlight">example.com</span></code> на ваше доменное имя.</p>
<div class="code-label " title="~/wordpress/nginx-conf/nginx.conf">~/wordpress/nginx-conf/nginx.conf</div><pre class="code-pre "><code langs="">server {
        listen 80;
        listen [::]:80;

        server_name <span class="highlight">example.com</span> www.<span class="highlight">example.com</span>;

        index <span class="highlight">index.php</span> index.html index.htm;

        root /var/www/html;

        location ~ /.well-known/acme-challenge {
                allow all;
                root /var/www/html;
        }

        location / {
                try_files $uri $uri/ /index.php$is_args$args;
        }

        location ~ \.php$ {
                try_files $uri =404;
                fastcgi_split_path_info ^(.+\.php)(/.+)$;
                fastcgi_pass <span class="highlight">wordpress</span>:9000;
                fastcgi_index index.php;
                include fastcgi_params;
                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
                fastcgi_param PATH_INFO $fastcgi_path_info;
        }

        location ~ /\.ht {
                deny all;
        }

        location = /favicon.ico {
                log_not_found off; access_log off;
        }
        location = /robots.txt {
                log_not_found off; access_log off; allow all;
        }
        location ~* \.(css|gif|ico|jpeg|jpg|js|png)$ {
                expires max;
                log_not_found off;
        }
}
</code></pre>
<p>Наш серверный блок содержит следующую информацию:</p>

<p><strong>Директивы:</strong></p>

<ul>
<li><code>listen</code>: данный элемент просит Nginx прослушивать порт <code>80</code>, что позволит нам использовать плагин <a href="https://certbot.eff.org/docs/using.html#webroot">webroot</a> Certbot для наших запросов сертификатов. Обратите внимание, что мы пока <em>не</em> будем включать порт <code>443</code>, мы обновим нашу конфигурацию и добавим SSL после успешного получения наших сертификатов.</li>
<li><code>server_name</code>: этот элемент определяет имя вашего сервера и серверный блок, который должны использоваться для запросов к вашему серверу. Обязательно замените <code><span class="highlight">example.com</span></code> в этой строке на ваше собственное доменное имя.</li>
<li><code>index</code>: директива <code>index</code> определяет файлы, которые будут использоваться в качестве индексов при обработке запросов к вашему серверу. Здесь мы изменили порядок приоритета по умолчанию, поставив <code>index.html</code> перед <code>index.html,</code> в результате чего Nginx будет давать приоритет файлам с именем <code>index.php</code> при наличии возможности.</li>
<li><code>root</code>: наша директива <code>root</code> назначает имя корневой директории для запросов к нашему серверу. Эта директория, <code>/var/www/html</code>, <a href="https://github.com/docker-library/wordpress/blob/07958d19ed465fb7fe50626be740d88a2c2260a7/php7.2/fpm-alpine/Dockerfile#L53">создается в качестве точки монтирования</a> в момент сборки с помощью инструкций в <a href="https://github.com/docker-library/wordpress/blob/07958d19ed465fb7fe50626be740d88a2c2260a7/php7.2/fpm-alpine/Dockerfile">Dockerfile WordPress</a>. Эти инструкции Dockerfile также гарантируют, что файлы релиза  WordPress монтируются в этот том.</li>
</ul>

<p><strong>Блоки расположения:</strong></p>

<ul>
<li><code>location ~ /.well-known/acme-challenge</code>: этот блок расположения будет обрабатывать запросы в директории <code>.well-known</code>, где Certbot будет размещать временный файл для подтверждения того, что DNS для нашего домена будет работать с нашим сервером. Настроив данную конфигурацию, мы сможем использовать плагин webroot Certbot для получения сертификатов для нашего домена.</li>
<li><code>location /</code>: в этом блоке расположения мы будем использовать директиву <code>try_files</code> для проверки файлов, соответствующих отдельным запросам URI. Вместо того, чтобы возвращать по умолчанию статус <code>404</code> не найдено, мы будем передавать контроль файлу <code>index.php</code> Wordpress с аргументами запроса.</li>
<li><code>location ~\.php$</code>: этот блок расположения будет обрабатывать PHP запросы и проксировать эти запросы в наш контейнер <code>wordpress</code>. Поскольку наш образ WordPress Docker будет опираться на образ <a href="https://github.com/docker-library/php/blob/e63194a0006848edb13b7eff5a7f9d790d679428/7.2/alpine3.9/fpm/Dockerfile"><code>php:fpm</code></a>, мы также добавим параметры конфигурации, принадлежащие <a href="https://en.wikipedia.org/wiki/FastCGI">протоколу FastCGI</a>, в этом блоке. Nginx требует наличия независимого процессора PHP для запросов PHP: в нашем случае эти запросы будут обрабатываться процессором <code>php-fpm</code>, который будет включать образ <code>php:fpm</code>. Кроме того, этот блок расположения содержит директивы FastCGI, переменные и опции, которые будут проксировать запросы для приложения WordPress, запущенного в нашем контейнере <code>wordpress</code>, задавать предпочитаемый индекс захваченного URI запроса, а также выполнять парсинг URI запросов.</li>
<li><code>location ~ /\.ht</code>: этот блок будет обрабатывать файлы <code>.htaccess</code>, поскольку Nginx не будет обслуживать их. Директива <code>deny_all</code> гарантирует, что файлы <code>.htaccess</code> никогда не будут отображаться для пользователей.</li>
<li><code>location = /favicon.ico</code>, <code>location = /robots.txt</code>: эти блоки гарантируют, что запросы для <code>/favicon.ico</code> и <code>/robots.txt</code> не будут регистрироваться.</li>
<li><code>location ~*\ (css|gif|ico|jpeg|jpg|js|png)$</code>: этот блок отключает запись в журнал для запросов статичных активов и гарантирует, что эти активы будут иметь высокую кэшируемость, поскольку обычно их трудно обслуживать.</li>
</ul>

<p>Дополнительную информацию о проксировании FastCGI см. в статье <a href="https://www.digitalocean.com/community/tutorials/understanding-and-implementing-fastcgi-proxying-in-nginx">Понимание и реализация проксирования FastCGI в Nginx</a>. Информацию о серверных блоках и блоках расположения см. в статье <a href="https://www.digitalocean.com/community/tutorials/understanding-nginx-server-and-location-block-selection-algorithms">Знакомство с сервером Nginx и алгоритмы выбора блоков расположения</a>.</p>

<p>Сохраните и закройте файл после завершения редактирования. Если вы используете <code>nano</code>, нажмите <code>CTRL+X</code>, <code>Y</code>, затем <code>ENTER</code>.</p>

<p>После настройки конфигурации Nginx вы можете перейти к созданию переменных среды для передачи в контейнеры приложения и базы данных во время исполнения.</p>

<h2 id="Шаг-2-—-Настройка-переменных-среды">Шаг 2 — Настройка переменных среды</h2>

<p>Контейнеры базы данных и приложения WordPress должны получить доступ к определенным переменным среды в момент выполнения для сохранения данных приложения и предоставления доступа к этим данным для вашего приложения. Эти переменные включают чувствительные и нечувствительные данные: к чувствительным данным относятся <strong>root</strong> пароль MySQL и пароль и пользователь базы данных приложения, а к нечувствительным данным относится информация о имени и хосте базы данных приложения.</p>

<p>Вместо того, чтобы задавать эти значения в нашем файле Docker Compose, основном файле, который содержит информацию о том, как наши контейнеры будут работать, мы можем задать чувствительные значения в файле <code>.env</code> и ограничить его распространение. Это не позволит скопировать эти значения в репозиторий нашего проекта и открыть их для общего доступа.</p>

<p>В главной директории проекта <code>~/<span class="highlight">wordpress</span></code>, откройте файл с именем <code>.env</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano .env
</li></ul></code></pre>
<p>Конфиденциальные значения, которые мы зададим в этом файле, включают пароль для нашего <strong>root</strong> пользователя MySQL, имя пользователя и пароль, которые WordPress будет использовать для доступа к базе данных.</p>

<p>Добавьте в файл следующие имя и значения переменных: Обязательно предоставьте здесь <strong>ваши собственные значения</strong> для каждой переменной:</p>
<div class="code-label " title="~/wordpress/.env">~/wordpress/.env</div><pre class="code-pre "><code langs="">MYSQL_ROOT_PASSWORD=<span class="highlight">your_root_password</span>
MYSQL_USER=<span class="highlight">your_wordpress_database_user</span>
MYSQL_PASSWORD=<span class="highlight">your_wordpress_database_password</span>
</code></pre>
<p>Мы включили пароль для административной учетной записи <strong>root</strong>, а также предпочитаемые имя пользователя и пароль для нашей базы данных приложения.</p>

<p>Сохраните и закройте файл после завершения редактирования.</p>

<p>Поскольку ваш файл <code>.env</code> содержит чувствительную информацию, вы можете убедиться, что в файлы <code>.gitignore</code> и <code>.dockerignore</code> вашего проекта включены инструкции, указывающие <a href="https://www.digitalocean.com/community/tutorials/how-to-use-git-a-reference-guide">Git</a> и <strong>Docker</strong>, какие файлы не копировать в ваши репозитории Git и образы Docker.</p>

<p>Если вы планируете использовать Git для контроля версий, <a href="https://www.digitalocean.com/community/tutorials/how-to-use-git-a-reference-guide#set-up-and-initialization">инициализируйте текущую рабочую директорию в качестве репозитория</a> с помощью <code>git init</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">git init
</li></ul></code></pre>
<p>Затем откройте файл <code>.gitignore</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano .gitignore
</li></ul></code></pre>
<p>Добавьте <code>.env</code> в файл:</p>
<div class="code-label " title="~/wordpress/.gitignore">~/wordpress/.gitignore</div><pre class="code-pre "><code langs="">.env
</code></pre>
<p>Сохраните и закройте файл после завершения редактирования.</p>

<p>Также в качестве дополнительной меры предосторожности рекомендуется добавить <code>.env</code> в файл <code>.dockerignore</code>, чтобы он не потерялся в ваших контейнерах, когда вы используете эту директорию в качестве контекста для сборки.</p>

<p>Откройте файл:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano .dockerignore
</li></ul></code></pre>
<p>Добавьте <code>.env</code> в файл:</p>
<div class="code-label " title="~/wordpress/.dockerignore">~/wordpress/.dockerignore</div><pre class="code-pre "><code langs="">.env
</code></pre>
<p>Ниже вы можете дополнительно добавить файлы и директории, связанные с разработкой вашего приложения:</p>
<div class="code-label " title="~/wordpress/.dockerignore">~/wordpress/.dockerignore</div><pre class="code-pre "><code langs="">.env
.git
docker-compose.yml
.dockerignore
</code></pre>
<p>Сохраните файл и закройте его после завершения.</p>

<p>Теперь, когда все чувствительные данные на месте, вы можете перейти к определению ваших служб в файле <code>docker-compose.yml</code>.</p>

<h2 id="Шаг-3-—-Определение-служб-с-помощью-docker-compose">Шаг 3 — Определение служб с помощью Docker Compose</h2>

<p>Ваш файл <code>docker-compose.yml</code> будет содержать определения службы для вашей настройки. <em>Служба</em> в Compose — это запущенный контейнер, а определения службы содержат информацию о том, как каждый контейнер будет работать.</p>

<p>Используя Compose, вы можете определить различные службы для запуска приложений с несколькими контейнерами, поскольку Compose позволяет привязать эти службы к общим сетям и томам. Это будет полезно для нашей текущей настройки, поскольку мы создадим различные контейнеры для нашей базы данных, приложения WordPress и веб-сервера. Также мы создадим контейнер для запуска <a href="https://certbot.eff.org/">клиента Certbot</a>, чтобы получить сертификаты для нашего веб-сервера.</p>

<p>Откройте файл <code>docker-compose.yml</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano docker-compose.yml
</li></ul></code></pre>
<p>Добавьте следующий код для определения версии файла Compose и базы данных <code>db</code>:</p>
<div class="code-label " title="~/wordpress/docker-compose.yml">~/wordpress/docker-compose.yml</div><pre class="code-pre "><code langs="">version: '3'

services:
  db:
    image: mysql:<span class="highlight">8.0</span>
    container_name: db
    restart: unless-stopped
    env_file: .env
    environment:
      - MYSQL_DATABASE=<span class="highlight">wordpress</span>
    volumes:
      - dbdata:/var/lib/mysql
    command: '--default-authentication-plugin=mysql_native_password'
    networks:
      - app-network
</code></pre>
<p>Определение службы <code>db</code> включает следующие параметры:</p>

<ul>
<li><code>image</code>: данный элемент указывает Compose, какой образ будет загружаться для создания контейнера. Мы закрепим здесь <a href="https://github.com/docker-library/mysql/blob/130bd8e46a3da1adfc1732a08c70673e20aa5977/8.0/Dockerfile">образ <code>mysql:<span class="highlight">8.0</span></code></a>, чтобы избежать будущих конфликтов, так как образ <code>mysql:latest</code> продолжит обновляться. Дополнительную информацию о закреплении версии и предотвращении конфликтов зависимостей см. документацию Docker и раздел <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">Рекомендации по работе с Dockerfile</a>.</li>
<li><code>container_name</code>: данный элемент указывает имя контейнера.</li>
<li><code>restart</code>: данный параметр определяет политику перезапуска контейнера. По умолчанию установлено значение <code>no</code>, но мы задали значение, согласно которому контейнер будет перезапускаться, пока не будет остановлен вручную.</li>
<li><code>env_file</code>: этот параметр указывает Compose, что мы хотим добавить переменные среды из файла с именем <code>.env</code>, расположенного в контексте сборки. В этом случае в качестве контекста сборки используется наша текущая директория.</li>
<li><code>environment</code>: этот параметр позволяет добавить дополнительные переменные среды, не определенные в файле <code>.env</code>. Мы настроим переменную <code>MYSQL_DATABASE</code> со значением <code><span class="highlight">wordpress</span></code>, которая будет предоставлять имя нашей базы данных приложения. Поскольку эта информация не является чувствительной, мы можем включить ее напрямую в файл <code>docker-compose.yml</code>.</li>
<li><code>volumes</code>: здесь мы монтируем <a href="https://docs.docker.com/storage/volumes/">именованный том с</a> названием <code>dbdata</code> в директорию <code>/var/lib/mysql</code> в контейнере. Это стандартная директория данных для  в большинстве дистрибутивов.</li>
<li><code>command</code>: данный параметр указывает команду, которая будет переопределять используемое по умолчанию значение <a href="https://docs.docker.com/engine/reference/builder/#cmd">инструкции CMD</a> для образа. В нашем случае мы добавим параметр для стандартной <a href="https://dev.mysql.com/doc/refman/8.0/en/mysqld.html">команды <code>mysqld</code></a> образа Docker, которая запускает сервер MySQL в контейнере. Эта опция <code>--default-authentication-plugin=mysql_native_password</code> устанавливает для системной переменной <code>--default-authentication-plugin</code> значение <code>mysql_native_password</code>, которое указывает, какой механизм аутентификации должен управлять новыми запросами аутентификации для сервера. Поскольку PHP и наш образ WordPress <a href="https://github.com/docker-library/wordpress/issues/313">не будут поддерживать</a> <a href="https://mysqlserverteam.com/upgrading-to-mysql-8-0-default-authentication-plugin-considerations/">новое значение аутентификации MySQL по умолчанию</a>, мы должны внести изменения, чтобы выполнить аутентификацию пользователя базы данных приложения.</li>
<li><code>networks</code>: данный параметр указывает, что служба приложения будет подключаться к сети <code>app-network</code>, которую мы определим внизу файла.</li>
</ul>

<p>Затем под определением службы <code>db</code> добавьте определение для вашей службы приложения <code>wordpress</code>:</p>
<div class="code-label " title="~/wordpress/docker-compose.yml">~/wordpress/docker-compose.yml</div><pre class="code-pre "><code langs="">...
  wordpress:
    depends_on:
      - db
    image: wordpress:<span class="highlight">5.1.1</span>-fpm-alpine
    container_name: wordpress
    restart: unless-stopped
    env_file: .env
    environment:
      - WORDPRESS_DB_HOST=db:3306
      - WORDPRESS_DB_USER=$MYSQL_USER
      - WORDPRESS_DB_PASSWORD=$MYSQL_PASSWORD
      - WORDPRESS_DB_NAME=<span class="highlight">wordpress</span>
    volumes:
      - wordpress:/var/www/html
    networks:
      - app-network
</code></pre>
<p>В этом определении службы мы называем наш контейнер и определяем политику перезапуска, как уже делали это для службы <code>db</code>. Также мы добавляем в этот контейнер ряд параметров:</p>

<ul>
<li><code>depends_on</code>: этот параметр гарантирует, что наши контейнеры будут запускаться в порядке зависимости, и контейнер  <code>wordpress</code> запускается после контейнера <code>db</code>. Наше приложение WordPress зависит от наличия базы данных приложения и пользователя, поэтому установка такого порядка зависимостей позволит выполнять запуск приложения корректно.</li>
<li><code>image</code>: для этой настройки мы будем использовать <a href="https://github.com/docker-library/wordpress/blob/07958d19ed465fb7fe50626be740d88a2c2260a7/php7.2/fpm-alpine/Dockerfile">образ Wordpress <code><span class="highlight">5.11</span>-fpm-alpine</code></a>. Как  было показано в <a href="https://www.digitalocean.com/community/tutorials/how-to-install-wordpress-with-docker-compose#step-1-%E2%80%94-defining-the-web-server-configuration">шаге 1</a>, использование этого образа гарантирует, что наше приложение будет иметь процессор <code>php-fpm</code>, который требуется Nginx для обработки PHP. Это еще и образ <code>alpine</code>, полученный из <a href="https://alpinelinux.org/">проекта Alpine Linux</a>, который поможет снизить общий размер образа. Дополнительную информацию о преимуществах и недостатках использования образов <code>alpine</code>, а также о том, имеет ли это смысл в случае вашего приложения, см. полное описание в разделе <strong>Варианты образа</strong> на <a href="https://hub.docker.com/_/wordpress">странице образа WordPress на Docker Hub</a>.</li>
<li><code>env_file</code>: и снова мы укажем, что хотим загрузить значения из файла <code>.env</code>, поскольку там мы определили пользователя базы данных приложения и пароль.</li>
<li><code>environment</code>: здесь мы будем использовать значения, определенные в файле <code>.env</code>, но мы привяжем их к именам переменных, которые требуются для образа WordPress: <code>WORDPRESS_DB_USER</code> и <code>WORDPRESS_DB_PASSWORD</code>. Также мы определяем значение <code>WORDPRESS_DB_HOST</code>, которое будет указывать сервер MySQL, который будет работать в контейнере <code>db</code>, доступный на используемом по умолчанию порту MySQL <code>3306</code>. Наше значение <code>WORDPRESS_DB_NAME</code> будет тем же, которое мы указали при определении службы MySQL для <code>MYSQL_DATABASE:</code> <code><span class="highlight">wordpress</span></code>.</li>
<li><code>volumes</code>: мы монтируем том с именем <code>wordpress</code> на точку монтирования <code>/var/www/html</code>, <a href="https://github.com/docker-library/wordpress/blob/07958d19ed465fb7fe50626be740d88a2c2260a7/php7.2/fpm-alpine/Dockerfile#L53">созданную образом WordPress</a>. Использование тома с именем таким образом позволит разделить наш код приложения с другими контейнерами.</li>
<li><code>networks</code>: мы добавляем контейнер <code>wordpress</code> в сеть <code>app-network</code>.</li>
</ul>

<p>Далее под определением службы приложения <code>wordpress</code> добавьте следующее определение для службы Nginx <code>webserver</code>:</p>
<div class="code-label " title="~/wordpress/docker-compose.yml">~/wordpress/docker-compose.yml</div><pre class="code-pre "><code langs="">...
  webserver:
    depends_on:
      - wordpress
    image: nginx:<span class="highlight">1.15.12</span>-alpine
    container_name: webserver
    restart: unless-stopped
    ports:
      - "80:80"
    volumes:
      - wordpress:/var/www/html
      - ./nginx-conf:/etc/nginx/conf.d
      - certbot-etc:/etc/letsencrypt
    networks:
      - app-network
</code></pre>
<p>Мы снова присвоим имя нашему контейнеру и сделаем его зависимым от контейнера <code>wordpress</code> в отношении порядка запуска. Также мы используем образ <code>alpine</code> — <a href="https://github.com/nginxinc/docker-nginx/blob/e5123eea0d29c8d13df17d782f15679458ff899e/mainline/stretch/Dockerfile">образ Nginx <code><span class="highlight">1.15.12</span>-alpine</code></a>.</p>

<p>Это определение службы также включает следующие параметры:</p>

<ul>
<li><code>ports</code>: этот параметр открывает порт <code>80</code>, чтобы активировать параметры конфигурации, определенные нами в файле <code>nginx.conf</code> в <a href="">шаге 1</a>.</li>
<li><code>volumes</code>: здесь мы определяем комбинацию названных томов и <a href="https://docs.docker.com/storage/bind-mounts/">связанных монтируемых образов</a>:

<ul>
<li><code>wordpress:/var/www/html</code>: этот параметр будет монтировать код нашего приложения WordPress в директорию <code>/var/www/html</code>, директорию, которую мы задали в качестве <code>root</code> директории в нашем серверном блоке Nginx.</li>
<li><code>./nginx-conf:/etc/nginx/conf.d</code>: этот элемент будет монтировать директорию конфигурации Nginx на хост в соответствующую директорию в контейнере, гарантируя, что любые изменения, которые мы вносим в файлы на хосте, будут отражены в контейнере.</li>
<li><code>certbot-etc:/etc/letsencrypt</code>: этот элемент будет монтировать соответствующие сертификаты и ключи Let&rsquo;s Encrypt для нашего домена в соответствующую директорию контейнера.</li>
</ul></li>
</ul>

<p>Здесь мы снова добавили этот контейнер в сеть <code>app-network</code>.</p>

<p>Наконец, под определением <code>webserver</code> добавьте последнее определение для службы <code>certbot</code>. Обязательно замените адрес электронной почты и доменные имена, перечисленные здесь, на ваши собственные:</p>
<div class="code-label " title="~/wordpress/docker-compose.yml">~/wordpress/docker-compose.yml</div><pre class="code-pre "><code langs="">  certbot:
    depends_on:
      - webserver
    image: certbot/certbot
    container_name: certbot
    volumes:
      - certbot-etc:/etc/letsencrypt
      - wordpress:/var/www/html
    command: certonly --webroot --webroot-path=/var/www/html --email <span class="highlight">sammy@example.com</span> --agree-tos --no-eff-email --staging -d <span class="highlight">example.com</span> -d www.<span class="highlight">example.com</span>
</code></pre>
<p>Это определение попросит Compose извлекать <a href="https://hub.docker.com/r/certbot/certbot/">образ <code>certbot/certbot</code></a> из Docker Hub. Также оно использует имена томов для обмена ресурсами с контейнером Nginx, включая доменные сертификаты и ключ в <code>certbot-etc</code> и код приложения в <code>wordpress</code>.</p>

<p>Мы использовали <code>depends_on</code>, чтобы указать, что контейнер <code>certbot</code> следует запускать только после запуска службы <code>webserver</code>.</p>

<p>Также мы включили параметр <code>command</code>, указывающий субкоманду для запуска с используемой контейнером по умолчанию командой <code>certbot</code>. <a href="https://certbot.eff.org/docs/using.html#certbot-command-line-options">Субкоманда <code>certonly</code></a> будет получать сертификат со следующими параметрами:</p>

<ul>
<li><code>--webroot</code>: данный элемент говорит Certbot о необходимости использования плагина webroot для размещения файлов в папке webroot для аутентификации. Работа плагина основана на <a href="https://tools.ietf.org/html/draft-ietf-acme-acme-03#section-7.2">методе валидации HTTP-01</a>, который использует запрос HTTP, чтобы доказать, что Certbot может получить доступ к ресурсам с сервера, который отвечает на заданное доменное имя.</li>
<li><code>--webroot-path</code>: данный элемент указывает путь директории webroot.</li>
<li><code>--email</code>: предпочитаемый адрес электронной почты для регистрации и восстановления.</li>
<li><code>--agree-tos</code>: данный элемент указывает, что вы принимаете <a href="https://letsencrypt.org/documents/LE-SA-v1.2-November-15-2017.pdf">Соглашение о подписке ACME</a>.</li>
<li><code>--no-eff-email</code>: данный элемент указывает Certbot, что вы не хотите делиться адресом электронной почты с <a href="https://www.eff.org/">Electronic Frontier Foundation​​​</a> (EFF). Вы можете пропустить этот элемент.</li>
<li><code>--staging</code>: данный элемент говорит Certbot, что вы хотите использовать промежуточную среду Let&rsquo;s Encrypt для получения тестовых сертификатов. При использовании этого параметра вы можете протестировать параметры конфигурации и избежать возможных пределов для запросов домена. Дополнительную информацию об этих предельных <a href="https://letsencrypt.org/docs/rate-limits/">значениях см. в документации по ограничениям скорости Let&rsquo;s Encrypt</a>.</li>
<li><code>-d</code>: данный элемент позволяет указать доменные имена, которые вы хотите использовать для вашего запроса. В нашем случае мы включили <code><span class="highlight">example.com</span></code> и <code>www.<span class="highlight">example.com</span></code>. Обязательно замените эти данные на имя вашего домена.</li>
</ul>

<p>Под определением службы <code>certbot</code> добавьте определения сети и тома:</p>
<div class="code-label " title="~/wordpress/docker-compose.yml">~/wordpress/docker-compose.yml</div><pre class="code-pre "><code langs="">...
volumes:
  certbot-etc:
  wordpress:
  dbdata:

networks:
  app-network:
    driver: bridge  
</code></pre>
<p>Наш ключ верхнего уровня <code>volumes</code> определяет тома <code>certbot-etc</code>, <code>wordpress</code> и <code>dbdata</code>. Когда Docker создает тома, содержимое тома сохраняется в директории файловой системы хоста, <code>/var/lib/docker/volumes/</code>, а данным процессом управляет Docker. После этого содержимое каждого тома монтируется из этой директории в любой контейнер, использующий том. Таким образом мы можем делиться кодом и данными между контейнерами.</p>

<p>Создаваемая пользователем мостовая система <code>app-network</code> позволяет организовать коммуникацию между нашими контейнерами, поскольку они находятся на одном хосте демона Docker. Это позволяет организовать трафик и коммуникации внутри приложения, поскольку она открывает все порты между контейнерами в одной мостовой сети, скрывая все порты от внешнего мира. Таким образом, наши контейнеры <code>db</code>, <code>wordpress</code> и <code>webserver</code> могут взаимодействовать друг с другом, и нам нужно будет только открыть порт <code>80</code> для внешнего доступа к приложению.</p>

<p>Итоговый файл <code>docker-compose.yml</code> будет выглядеть примерно так:</p>
<div class="code-label " title="~/wordpress/docker-compose.yml">~/wordpress/docker-compose.yml</div><pre class="code-pre "><code langs="">version: '3'

services:
  db:
    image: mysql:<span class="highlight">8.0</span>
    container_name: db
    restart: unless-stopped
    env_file: .env
    environment:
      - MYSQL_DATABASE=<span class="highlight">wordpress</span>
    volumes:
      - dbdata:/var/lib/mysql
    command: '--default-authentication-plugin=mysql_native_password'
    networks:
      - app-network

  wordpress:
    depends_on:
      - db
    image: wordpress:<span class="highlight">5.1.1</span>-fpm-alpine
    container_name: wordpress
    restart: unless-stopped
    env_file: .env
    environment:
      - WORDPRESS_DB_HOST=db:3306
      - WORDPRESS_DB_USER=$MYSQL_USER
      - WORDPRESS_DB_PASSWORD=$MYSQL_PASSWORD
      - WORDPRESS_DB_NAME=<span class="highlight">wordpress</span>
    volumes:
      - wordpress:/var/www/html
    networks:
      - app-network

  webserver:
    depends_on:
      - wordpress
    image: nginx:<span class="highlight">1.15.12</span>-alpine
    container_name: webserver
    restart: unless-stopped
    ports:
      - "80:80"
    volumes:
      - wordpress:/var/www/html
      - ./nginx-conf:/etc/nginx/conf.d
      - certbot-etc:/etc/letsencrypt
    networks:
      - app-network

  certbot:
    depends_on:
      - webserver
    image: certbot/certbot
    container_name: certbot
    volumes:
      - certbot-etc:/etc/letsencrypt
      - wordpress:/var/www/html
    command: certonly --webroot --webroot-path=/var/www/html --email <span class="highlight">sammy@example.com</span> --agree-tos --no-eff-email --staging -d <span class="highlight">example.com</span> -d www.<span class="highlight">example.com</span>

volumes:
  certbot-etc:
  wordpress:
  dbdata:

networks:
  app-network:
    driver: bridge  
</code></pre>
<p>Сохраните и закройте файл после завершения редактирования.</p>

<p>После добавления определений службы вы можете запустить контейнеры и протестировать запросы сертификата.</p>

<h2 id="Шаг-4-—-Получение-сертификатов-ssl-и-учетных-данных">Шаг 4 — Получение сертификатов SSL и учетных данных</h2>

<p>Мы можем запустить наши контейнеры с помощью команды <a href="https://docs.docker.com/compose/reference/up/"><code>docker-compose up</code></a>, которая будет создавать и запускать наши контейнеры и службы в указанном нами порядке. Если наши запросы доменов будут выполнены успешно, мы увидим корректный статус выхода в нашем выводе и нужные сертификаты, установленные в папке <code>/etc/letsencrypt/live</code> на контейнере <code>webserver</code>.</p>

<p>Создайте контейнеры с помощью команды <a href="https://docs.docker.com/compose/reference/up/"><code>docker-compose up</code></a> и флага <code>-d</code>, которые будут запускать контейнеры <code>db​​​</code>, <code>wordpress</code> и <code>webserver</code> в фоновом режиме:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose up -d
</li></ul></code></pre>
<p>Вы увидите вывод, подтверждающий, что ваши службы были успешно созданы:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Creating db ... done
Creating wordpress ... done
Creating webserver ... done
Creating certbot   ... done
</code></pre>
<p>С помощью <a href="https://docs.docker.com/compose/reference/ps/"><code>docker-compose ps</code></a> проверьте статус ваших служб:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose ps
</li></ul></code></pre>
<p>Если все будет выполнено успешно, ваши службы <code>db</code>, <code>wordpress</code> и <code>webserver</code> должны иметь статус <code>Up</code>, а работа контейнера <code>certbot</code> будет завершена с сообщением о статусе <code>0</code>:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>  Name                 Command               State           Ports       
-------------------------------------------------------------------------
certbot     certbot certonly --webroot ...   Exit 0                      
db          docker-entrypoint.sh --def ...   Up       3306/tcp, 33060/tcp
webserver   nginx -g daemon off;             Up       0.0.0.0:80-&gt;80/tcp
wordpress   docker-entrypoint.sh php-fpm     Up       9000/tcp           
</code></pre>
<p>Если вы увидите любое значение, кроме <code>Up</code> в столбце <code>State</code> для служб <code>db</code>, <code>wordpress</code> и <code>webserver</code>, или любое сообщение о статусе выхода, отличающееся от <code>0</code>, для контейнера <code>certbot</code>, проверьте журналы службы с помощью команды <a href="https://docs.docker.com/compose/reference/logs/"><code>docker-compose logs</code></a>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose logs <span class="highlight">service_name</span>
</li></ul></code></pre>
<p>Теперь вы можете убедиться, что ваши сертификаты были смонтированы в контейнер <code>webserver</code> с помощью команды <a href="https://docs.docker.com/compose/reference/exec/"><code>docker-compose exec</code></a>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose exec webserver ls -la /etc/letsencrypt/live
</li></ul></code></pre>
<p>Если запросы сертификата были выполнены успешно, вы увидите следующий результат:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>total 16
drwx------    3 root     root          4096 May 10 15:45 .
drwxr-xr-x    9 root     root          4096 May 10 15:45 ..
-rw-r--r--    1 root     root           740 May 10 15:45 README
drwxr-xr-x    2 root     root          4096 May 10 15:45 <span class="highlight">example.com</span>
</code></pre>
<p>Теперь, когда вы убедились, что ваш запрос будет выполнен успешно, вы можете изменить определение службы <code>certbot</code> для удаления флага <code>--staging</code>.</p>

<p>Откройте <code>docker-compose.yml</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano docker-compose.yml
</li></ul></code></pre>
<p>Найдите раздел файла с определением службы <code>certbot</code> и замените флаг <code>--staging</code> в параметрах <code>command</code> на флаг <code>--force-renewal</code>, который будет указывать Certbot, что вы хотите запросить новый сертификат с теми же доменами, что и в уже существующем сертификате. Определение службы <code>certbot</code> должно будет выглядеть следующим образом:</p>
<div class="code-label " title="~/wordpress/docker-compose.yml">~/wordpress/docker-compose.yml</div><pre class="code-pre "><code langs="">...
  certbot:
    depends_on:
      - webserver
    image: certbot/certbot
    container_name: certbot
    volumes:
      - certbot-etc:/etc/letsencrypt
      - certbot-var:/var/lib/letsencrypt
      - wordpress:/var/www/html
    command: certonly --webroot --webroot-path=/var/www/html --email <span class="highlight">sammy@example.com</span> --agree-tos --no-eff-email <span class="highlight">--force-renewal</span> -d <span class="highlight">example.com</span> -d www.<span class="highlight">example.com</span>
...
</code></pre>
<p>Теперь вы можете запустить команду <code>docker-compose</code> up для воссоздания контейнера <code>certbot</code>. Также мы будем использовать параметр <code>--no-deps</code>, чтобы сообщить Compose о том, что можно пропустить запуск службы <code>webserver</code>, поскольку она уже запущена:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose up --force-recreate --no-deps certbot
</li></ul></code></pre>
<p>Вы увидите вывод, указывающий, что запрос сертификата выполнен успешно:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Recreating certbot ... done
Attaching to certbot
certbot      | Saving debug log to /var/log/letsencrypt/letsencrypt.log
certbot      | Plugins selected: Authenticator webroot, Installer None
certbot      | Renewing an existing certificate
certbot      | Performing the following challenges:
certbot      | http-01 challenge for <span class="highlight">example.com</span>
certbot      | http-01 challenge for www.<span class="highlight">example.com</span>
certbot      | Using the webroot path /var/www/html for all unmatched domains.
certbot      | Waiting for verification...
certbot      | Cleaning up challenges
certbot      | IMPORTANT NOTES:
certbot      |  - Congratulations! Your certificate and chain have been saved at:
certbot      |    /etc/letsencrypt/live/<span class="highlight">example.com</span>/fullchain.pem
certbot      |    Your key file has been saved at:
certbot      |    /etc/letsencrypt/live/<span class="highlight">example.com</span>/privkey.pem
certbot      |    Your cert will expire on 2019-08-08. To obtain a new or tweaked
certbot      |    version of this certificate in the future, simply run certbot
certbot      |    again. To non-interactively renew *all* of your certificates, run
certbot      |    "certbot renew"
certbot      |  - Your account credentials have been saved in your Certbot
certbot      |    configuration directory at /etc/letsencrypt. You should make a
certbot      |    secure backup of this folder now. This configuration directory will
certbot      |    also contain certificates and private keys obtained by Certbot so
certbot      |    making regular backups of this folder is ideal.
certbot      |  - If you like Certbot, please consider supporting our work by:
certbot      |
certbot      |    Donating to ISRG / Let's Encrypt:   https://letsencrypt.org/donate
certbot      |    Donating to EFF:                    https://eff.org/donate-le
certbot      |
certbot exited with code 0
</code></pre>
<p>После добавления ваших сертификатов вы можете перейти к изменению конфигурации Nginx для использования SSL.</p>

<h2 id="Шаг-5-—-Изменение-конфигурации-веб-сервера-и-определения-службы">Шаг 5 — Изменение конфигурации веб-сервера и определения службы</h2>

<p>Активация SSL в нашей конфигурации Nginx будет включать организацию перенаправления HTTP на HTTPS, указание расположения сертификата и ключей SSL и добавление параметров безопасности и заголовков.</p>

<p>Поскольку вы будете воссоздавать службу <code>webserver</code> для включения этих нововведений, сейчас вы можете остановить ее работу:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose stop webserver
</li></ul></code></pre>
<p>Прежде чем мы самостоятельно изменим файл конфигурации, нам нужно предварительно получить <a href="https://github.com/certbot/certbot/blob/master/certbot-nginx/certbot_nginx/tls_configs/options-ssl-nginx.conf">рекомендуемые параметры безопасности Nginx</a> от Certbot с помощью <code>curl</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">curl -sSLo nginx-conf/options-ssl-nginx.conf https://raw.githubusercontent.com/certbot/certbot/master/certbot-nginx/certbot_nginx/tls_configs/options-ssl-nginx.conf
</li></ul></code></pre>
<p>Данная команда будет сохранять эти параметры в файле с именем <code>options-ssl-nginx.conf</code>, расположенном в директории <code>nginx-conf</code>.</p>

<p>Затем удалите ранее созданный файл конфигурации Nginx:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">rm nginx-conf/nginx.conf
</li></ul></code></pre>
<p>Откройте другую версию файла:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano nginx-conf/nginx.conf
</li></ul></code></pre>
<p>Добавьте следующий код в файл для перенаправления HTTP на HTTPS и добавления учетных данных, протоколов и заголовков безопасности SSL. Обязательно замените <code><span class="highlight">example.com</span>​​</code> на ваше доменное имя:</p>
<div class="code-label " title="~/wordpress/nginx-conf/nginx.conf">~/wordpress/nginx-conf/nginx.conf</div><pre class="code-pre "><code langs="">server {
        listen 80;
        listen [::]:80;

        server_name <span class="highlight">example.com</span> www.<span class="highlight">example.com</span>;

        location ~ /.well-known/acme-challenge {
                allow all;
                root /var/www/html;
        }

        location / {
                rewrite ^ https://$host$request_uri? permanent;
        }
}

server {
        listen 443 ssl http2;
        listen [::]:443 ssl http2;
        server_name <span class="highlight">example.com</span> www.<span class="highlight">example.com</span>;

        index index.php index.html index.htm;

        root /var/www/html;

        server_tokens off;

        ssl_certificate /etc/letsencrypt/live/<span class="highlight">example.com</span>/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/<span class="highlight">example.com</span>/privkey.pem;

        include /etc/nginx/conf.d/options-ssl-nginx.conf;

        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header Referrer-Policy "no-referrer-when-downgrade" always;
        add_header Content-Security-Policy "default-src * data: 'unsafe-eval' 'unsafe-inline'" always;
        # add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
        # enable strict transport security only if you understand the implications

        location / {
                try_files $uri $uri/ /index.php$is_args$args;
        }

        location ~ \.php$ {
                try_files $uri =404;
                fastcgi_split_path_info ^(.+\.php)(/.+)$;
                fastcgi_pass <span class="highlight">wordpress</span>:9000;
                fastcgi_index index.php;
                include fastcgi_params;
                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
                fastcgi_param PATH_INFO $fastcgi_path_info;
        }

        location ~ /\.ht {
                deny all;
        }

        location = /favicon.ico {
                log_not_found off; access_log off;
        }
        location = /robots.txt {
                log_not_found off; access_log off; allow all;
        }
        location ~* \.(css|gif|ico|jpeg|jpg|js|png)$ {
                expires max;
                log_not_found off;
        }
}
</code></pre>
<p>Блок сервера HTTP указывает webroot для запросов обновления Certbot в директории <code>.well-known/acme-challenge</code>. Также он содержит <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite">директиву перезаписи</a>, которая перенаправляет запросы HTTP в корневую директорию HTTPS.</p>

<p>Блок сервера HTTPS активирует <code>ssl</code> и <code>http2</code>. Дополнительную информацию о том, как выполняется итерация HTTP/2 в протоколах HTTP и какие преимущества это может дать для повышения производительности веб-сайта, см. во вводной части <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-nginx-with-http-2-support-on-ubuntu-18-04">руководства по настройке Nginx с поддержкой HTTP/2 в Ubuntu 18.04</a>.</p>

<p>Этот блок также включает расположение наших сертификата SSL и ключа, а также рекомендованные параметры безопасности Certbot, которые мы сохранили в <code>nginx-conf/options-ssl-nginx.conf</code>.</p>

<p>Кроме того, мы включили ряд заголовков безопасности, которые позволят нам получить оценки <strong>A</strong> на сайтах серверных тестов <a href="https://www.ssllabs.com/ssltest/">SSL Labs</a> и <a href="https://securityheaders.com/">Security Headers</a>. Эти заголовки включают <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options"><code>X-Frame-Options</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options"><code>X-Content-Type-Options</code></a>, <a href="https://scotthelme.co.uk/a-new-security-header-referrer-policy/"><code>Referrer Policy</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy"><code>Content-Security-Policy</code></a> и <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection"><code>X-XSS-Protection</code></a>. Заголовок <a href="https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security">HTTP <code>Strict Transport Security (Строгая безопасность передачи информации по протоколу HTTP)</code></a> закомментирован, активируйте этот элемент, только если вы понимаете возможные последствия и оценили его <a href="https://hstspreload.org/">«предварительно загруженный» функционал</a>.</p>

<p>Наши директивы <code>root</code> и <code>index</code> также расположены в этом блоке, равно как и остальные блоки расположения WordPress, описанные в <a href="https://www.digitalocean.com/community/tutorials/how-to-install-wordpress-with-docker-compose#step-1-%E2%80%94-defining-the-web-server-configuration">шаге 1</a>.</p>

<p>После завершения редактирования сохраните и закройте файл.</p>

<p>Перед повторным созданием службы <code>webserver</code> вам потребуется добавить распределение порта <code>443</code> в определение службы <code>webserver</code>.</p>

<p>Откройте ваш файл <code>docker-compose.yml​​​</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano docker-compose.yml
</li></ul></code></pre>
<p>В определении службы <code>webserver</code> добавьте следующее распределение порта:</p>
<div class="code-label " title="~/wordpress/docker-compose.yml">~/wordpress/docker-compose.yml</div><pre class="code-pre "><code langs="">...
  webserver:
    depends_on:
      - wordpress
    image: nginx:<span class="highlight">1.15.12</span>-alpine
    container_name: webserver
    restart: unless-stopped
    ports:
      - "80:80"
      - <span class="highlight">"443:443"</span>
    volumes:
      - wordpress:/var/www/html
      - ./nginx-conf:/etc/nginx/conf.d
      - certbot-etc:/etc/letsencrypt
    networks:
      - app-network
</code></pre>
<p>Файл <code>docker-compose.yml</code> будет выглядеть следующим образом после завершения настройки:</p>
<div class="code-label " title="~/wordpress/docker-compose.yml">~/wordpress/docker-compose.yml</div><pre class="code-pre "><code langs="">version: '3'

services:
  db:
    image: mysql:<span class="highlight">8.0</span>
    container_name: db
    restart: unless-stopped
    env_file: .env
    environment:
      - MYSQL_DATABASE=wordpress
    volumes:
      - dbdata:/var/lib/mysql
    command: '--default-authentication-plugin=mysql_native_password'
    networks:
      - app-network

  wordpress:
    depends_on:
      - db
    image: wordpress:<span class="highlight">5.1.1</span>-fpm-alpine
    container_name: wordpress
    restart: unless-stopped
    env_file: .env
    environment:
      - WORDPRESS_DB_HOST=db:3306
      - WORDPRESS_DB_USER=$MYSQL_USER
      - WORDPRESS_DB_PASSWORD=$MYSQL_PASSWORD
      - WORDPRESS_DB_NAME=wordpress
    volumes:
      - wordpress:/var/www/html
    networks:
      - app-network

  webserver:
    depends_on:
      - wordpress
    image: nginx:<span class="highlight">1.15.12</span>-alpine
    container_name: webserver
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - wordpress:/var/www/html
      - ./nginx-conf:/etc/nginx/conf.d
      - certbot-etc:/etc/letsencrypt
    networks:
      - app-network

  certbot:
    depends_on:
      - webserver
    image: certbot/certbot
    container_name: certbot
    volumes:
      - certbot-etc:/etc/letsencrypt
      - wordpress:/var/www/html
    command: certonly --webroot --webroot-path=/var/www/html --email <span class="highlight">sammy@example.com</span> --agree-tos --no-eff-email --force-renewal -d <span class="highlight">example.com</span> -d www.<span class="highlight">example.com</span>

volumes:
  certbot-etc:
  wordpress:
  dbdata:

networks:
  app-network:
    driver: bridge  
</code></pre>
<p>Сохраните и закройте файл после завершения редактирования.</p>

<p>Повторно создайте службу <code>webserver</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose up -d --force-recreate --no-deps webserver
</li></ul></code></pre>
<p>Проверьте ваши службы с помощью <code>команды docker-compose ps:</code></p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose ps
</li></ul></code></pre>
<p>Вы должны получить результат, указывающий, что ваши службы <code>db</code>, <code>wordpress</code>  и <code>webserver</code> запущены:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>  Name                 Command               State                     Ports                  
----------------------------------------------------------------------------------------------
certbot     certbot certonly --webroot ...   Exit 0                                           
db          docker-entrypoint.sh --def ...   Up       3306/tcp, 33060/tcp                     
webserver   nginx -g daemon off;             Up       0.0.0.0:443-&gt;443/tcp, 0.0.0.0:80-&gt;80/tcp
wordpress   docker-entrypoint.sh php-fpm     Up       9000/tcp    
</code></pre>
<p>После запуска ваших контейнеров вы можете завершить процесс установки WordPress через веб-интерфейс.</p>

<h2 id="Шаг-6-—-Завершение-установки-через-веб-интерфейс">Шаг 6 — Завершение установки через веб-интерфейс</h2>

<p>После запуска контейнеров мы можем завершить установку через веб-интерфейс WordPress.</p>

<p>В браузере перейдите на домен вашего сервера. Не забудьте заменить здесь <code><span class="highlight">example.com</span></code>  на ваше доменное имя:</p>
<pre class="code-pre "><code langs="">https://<span class="highlight">example.com</span>
</code></pre>
<p>Выберите язык, который вы хотите использовать:</p>

<p><img src="https://assets.digitalocean.com/articles/docker-wordpress/wp_language_select.png" alt="Средство выбор языка WordPress"></p>

<p>После нажатия <strong>Continue</strong> (Продолжить) вы перейдете на главную страницу настройки, где вам нужно будет выбрать имя вашего сайта и пользователя. Рекомендуется выбрать запоминающееся имя пользователя (не просто «admin») и надежный пароль. Вы можете использовать пароль, который генерирует WordPress автоматически, или задать собственный пароль.</p>

<p>Наконец, вам нужно будет ввести ваш адрес электронной почты и указать, хотите ли вы, чтобы движки поисковых систем могли индексировать ваш сайт:</p>

<p><img src="https://assets.digitalocean.com/articles/docker-wordpress/wp_main_setup.png" alt="Главная страница настройки WordPress"></p>

<p>После нажатия <strong>Install WordPress</strong> (Установить Wordpress) внизу страницы на экране появится запрос выполнения входа:</p>

<p><img src="https://assets.digitalocean.com/articles/docker-wordpress/wp_login.png" alt="Экран входа WordPress"></p>

<p>После входа вы получите доступ к панели управления WordPress:</p>

<p><img src="https://assets.digitalocean.com/articles/docker-wordpress/wp_main_dash.png" alt="Панель управления WordPress"></p>

<p>После завершения установки WordPress вы можете выполнить определенные действия, необходимые для гарантии того, что ваши сертификаты SSL будут обновляться автоматически.</p>

<h2 id="Шаг-7-—-Обновление-сертификатов">Шаг 7 — Обновление сертификатов</h2>

<p>Сертификаты Let&rsquo;s Encrypt действительны в течение 90 дней, поэтому вам нужно будет настроить автоматический процесс обновления, чтобы гарантировать, что сертификаты не окажутся просроченными. Один из способов — создание задания с помощью утилиты планирования <code>cron</code>. В нашем случае мы настроим задание для <code>cron</code> с помощью скрипта, который будет обновлять наши сертификаты и перезагружать конфигурацию Nginx.</p>

<p>Откройте скрипт под названием <code>ssl_renew.sh</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano ssl_renew.sh
</li></ul></code></pre>
<p>Добавьте следующий код в скрипт, чтобы обновить ваши сертификаты и перезагрузить конфигурацию веб-сервера. Не забудьте заменить приведенное в качестве примера имя пользователя своим именем пользователя:</p>
<div class="code-label " title="~/wordpress/ssl_renew.sh">~/wordpress/ssl_renew.sh</div><pre class="code-pre "><code class="code-highlight language-bash">#!/bin/bash

COMPOSE="/usr/local/bin/docker-compose --no-ansi"
DOCKER="/usr/bin/docker"

cd /home/<span class="highlight">sammy</span>/wordpress/
$COMPOSE run certbot renew --dry-run &amp;&amp; $COMPOSE kill -s SIGHUP webserver
$DOCKER system prune -af
</code></pre>
<p>Данный скрипт привязывает двоичный код <code>docker-compose</code> для переменной <code>COMPOSE</code> и задает параметр <code>--no-ansi</code>, который запускает команды <code>docker-compose</code> без <a href="https://vt100.net/docs/vt510-rm/chapter4.html">управляющих символов ANSI</a>. Затем он делает то же самое с двоичным файлом <code>docker</code>. В заключение он меняет каталог проекта на <code>~/wordpress</code> и запускает следующие команды <code>docker-compose</code>:</p>

<ul>
<li><code>docker-compose run</code>: данный параметр запускает контейнер <code>certbot</code> и переопределяет параметр <code>command</code>, указанный в определении службы <code>certbot</code>. Вместо использования субкоманды <code>certonly</code> мы используем здесь субкоманду <code>renew</code>, которая будет обновлять сертификаты, срок действия которых близок к окончанию. Мы включили параметр <code>--dry-run</code>, чтобы протестировать наш скрипт.</li>
<li><a href="https://docs.docker.com/compose/reference/kill/"><code>docker-compose kill</code></a>: данный параметр отправляет сигнал <a href="https://en.wikipedia.org/wiki/SIGHUP"><code>SIGHUP</code></a> контейнеру <code>webserver</code> для перезагрузки конфигурации Nginx. Дополнительную информацию об использовании этого процесса для перезагрузки конфигурации Nginx см. в этой <a href="https://blog.docker.com/2015/04/tips-for-deploying-nginx-official-image-with-docker/">публикации блога Docker, посвященной развертыванию официального образа Nginx с помощью Docker</a>.</li>
</ul>

<p>После этого он выполняет команду <a href="https://docs.docker.com/engine/reference/commandline/system_prune/"><code>docker system prune</code></a> для удаления всех неиспользуемых контейнеров и образов.</p>

<p>Закройте файл после завершения редактирования. Сделайте его исполняемым:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">chmod +x ssl_renew.sh
</li></ul></code></pre>
<p>Далее откройте <strong>root</strong> файл <code>crontab</code> для запуска скрипта обновления с заданным интервалом:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo crontab -e
</li></ul></code></pre>
<p>Если вы в первый раз редактируете этот файл, вам будет предложено выбрать редактор:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>no crontab for root - using an empty one

Select an editor.  To change later, run 'select-editor'.
  1. /bin/nano        &lt;---- easiest
  2. /usr/bin/vim.basic
  3. /usr/bin/vim.tiny
  4. /bin/ed

Choose 1-4 [1]:
...
</code></pre>
<p>Добавьте внизу файла следующую строку:</p>
<div class="code-label " title="crontab">crontab</div><pre class="code-pre "><code langs="">...
*/5 * * * * /home/<span class="highlight">sammy</span>/wordpress/ssl_renew.sh &gt;&gt; /var/log/cron.log 2&gt;&amp;1
</code></pre>
<p>В результате будет установлен интервал в 5 минут для выполнения работы, и вы можете проверить, работает ли запрос обновления так, как предполагается. Также мы создали файл журнала, <code>cron.log</code>, чтобы записывать соответствующий вывод выполнения задания.</p>

<p>Через 5 минут проверьте <code>cron.log</code>, чтобы убедиться, что запрос обновления выполнен успешно:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">tail -f /var/log/cron.log
</li></ul></code></pre>
<p>Вы должны увидеть вывод, подтверждающий успешное обновление:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** DRY RUN: simulating 'certbot renew' close to cert expiry
**          (The test certificates below have not been saved.)

Congratulations, all renewals succeeded. The following certs have been renewed:
  /etc/letsencrypt/live/<span class="highlight">example.com</span>/fullchain.pem (success)
** DRY RUN: simulating 'certbot renew' close to cert expiry
**          (The test certificates above have not been saved.)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
</code></pre>
<p>Теперь вы можете изменить файл <code>crontab</code> для настройки ежедневного интервала. Чтобы запускать скрипт каждый день в полдень, например, вы должны изменить последнюю строку файла, которая должна выглядеть следующим образом:</p>
<div class="code-label " title="crontab">crontab</div><pre class="code-pre "><code langs="">...
0 12 * * * /home/<span class="highlight">sammy</span>/wordpress/ssl_renew.sh &gt;&gt; /var/log/cron.log 2&gt;&amp;1
</code></pre>
<p>Также вы можете изменить параметр <code>--dry-run</code> из скрипта <code>ssl_renew.sh</code>:</p>
<div class="code-label " title="~/wordpress/ssl_renew.sh">~/wordpress/ssl_renew.sh</div><pre class="code-pre "><code class="code-highlight language-bash">#!/bin/bash

COMPOSE="/usr/local/bin/docker-compose --no-ansi"
DOCKER="/usr/bin/docker"

cd /home/<span class="highlight">sammy</span>/wordpress/
$COMPOSE run certbot renew &amp;&amp; $COMPOSE kill -s SIGHUP webserver
$DOCKER system prune -af
</code></pre>
<p>Ваше задание <code>cron</code> гарантирует, что ваши сертификаты Let&rsquo;s Encrypt не окажутся устаревшими, обновляя их в случае истечения срока действия. Также вы можете <a href="https://www.digitalocean.com/community/tutorials/how-to-manage-logfiles-with-logrotate-on-ubuntu-16-04">настроить замену журнала с помощью утилиты Logrotate</a>, которая будет выполнять ротацию и сжатие файлов журнала.</p>

<h2 id="Заключение">Заключение</h2>

<p>В этом руководстве вы использовали Docker Compose для создания установки WordPress с веб-сервером Nginx. В рамках этого рабочего процесса вы получили сертификаты TLS/SSL для домена, который вы хотите подключить к вашему сайту WordPress. Кроме того, вы создали задание <code>cron</code> для обновления этих сертификатов при необходимости.</p>

<p>В качестве дополнительных мер по повышению производительности сайта и создания запаса мощности, вы можете ознакомиться со следующими статьями, посвященными передаче и поддержке активов WordPress:</p>

<ul>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-speed-up-wordpress-asset-delivery-using-digitalocean-spaces-cdn">Ускорение предоставления актива WordPress с помощью DigitalOcean Spaces CDN</a>.</li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-back-up-a-wordpress-site-to-spaces">Резервирование сайта WordPress с помощью Spaces</a>.</li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-store-wordpress-assets-on-digitalocean-spaces">Хранение активов WordPress в DigitalOcean Spaces</a>.</li>
</ul>

<p>Если вы заинтересованы в изучении контейнеризированного рабочего процесса с помощью Kubernetes, вы также можете ознакомиться со следующими материалами:</p>

<ul>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-wordpress-with-mysql-on-kubernetes-using-helm">Настройка WordPress с MySQL с использование Kubernetes и Helm</a>.</li>
</ul>
