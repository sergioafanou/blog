---
layout: post
title: Información sobre clases de JavaScript
network: digitalocean
date: December 05, 2019 at 08:06PM
url: https://www.digitalocean.com/community/tutorials/informacion-sobre-clases-de-javascript-es
image: http://ifttt.com/images/no_image_card.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="introducción">Introducción</h3>

<p>JavaScript es un lenguaje basado en prototipos y cada objeto en él tiene una propiedad interna oculta llamada <code>[[Prototype]]</code> que puede usarse para extender propiedades y métodos de objetos. Puede obtener más información sobre los prototipos de nuestro tutorial <a href="https://www.digitalocean.com/community/tutorials/understanding-prototypes-and-inheritance-in-javascript">Información sobre los prototipos y la herencia en JavaScript</a>.</p>

<p>Hasta hace poco, los desarrolladores esforzados usaban <a href="https://www.digitalocean.com/community/tutorials/understanding-prototypes-and-inheritance-in-javascript#constructor-functions">funciones constructoras</a> para imitar un patrón de diseño orientado a objetos en JavaScript. La especificación de lenguaje ECMAScript 2015, a menudo denominada ES6, introdujo clases en el lenguaje JavaScript. Las clases de JavaScript no ofrecen realmente una funcionalidad adicional y a menudo se describen como elementos que aportan “azúcar sintáctico&quot; en comparación con los prototipos y la herencia, ya que ofrecen una sintaxis más limpia y elegante. Debido a que otros lenguajes de programación usan clases, la sintaxis de clase de JavaScript permite que los desarrolladores alternen lenguajes de forma más directa.</p>

<h2 id="las-clases-son-funciones">Las clases son funciones</h2>

<p>Una clase de JavaScript es un tipo de función. Las clases se declaran con la palabra clave <code>class</code>. Usaremos sintaxis de expresión de función para inicializar una sintaxis de expresión de función y clase para inicializar una clase.</p>
<pre class="code-pre  second-environment"><code class="code-highlight language-js">// Initializing a function with a function expression
const x = function() {}
</code></pre><pre class="code-pre  fourth-environment"><code class="code-highlight language-js">// Initializing a class with a class expression
const y = class {}
</code></pre>
<p>Podemos acceder a <code>[[Prototype]]</code> de un objeto usando el método<a href="https://www.digitalocean.com/community/tutorials/understanding-prototypes-and-inheritance-in-javascript#javascript-prototypes"><code>Object.getPrototypeOf()</code></a>. Usaremos eso para probar la <strong>función</strong> vacía que creamos.</p>
<pre class="code-pre  second-environment"><code class="code-highlight language-js">Object.getPrototypeOf(x);
</code></pre><pre class="code-pre  second-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>ƒ () { [native code] }
</code></pre>
<p>También podemos usar ese método en la <strong>clase</strong> que acabamos de crear.</p>
<pre class="code-pre  fourth-environment"><code class="code-highlight language-js">Object.getPrototypeOf(y);
</code></pre><pre class="code-pre  fourth-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>ƒ () { [native code] }
</code></pre>
<p>El código declarado con <code>function</code> y <code>class</code> muestra una función <code>[[Prototype]]</code>. Con prototipos, cualquier función puede convertirse en una instancia de constructor mediane la palabra clave <code>new</code>.</p>
<pre class="code-pre  second-environment"><code class="code-highlight language-js">const x = function() {}

// Initialize a constructor from a function
const constructorFromFunction = new x();

console.log(constructorFromFunction);
</code></pre><pre class="code-pre  second-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>x {}
constructor: ƒ ()
</code></pre>
<p>Esto se aplica a clases también.</p>
<pre class="code-pre  fourth-environment"><code class="code-highlight language-js">const y = class {}

// Initialize a constructor from a class
const constructorFromClass = new y();

console.log(constructorFromClass);
</code></pre><pre class="code-pre  fourth-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>y {}
constructor: class
</code></pre>
<p>Estos ejemplos de constructores de prototipos, de lo contrario, están vacíos. Sin embargo, podemos ver que debajo de la sintaxis ambos métodos logran el mismo resultado final.</p>

<h2 id="definir-una-clase">Definir una clase</h2>

<p>En el <a href="https://www.digitalocean.com/community/tutorials/understanding-prototypes-and-inheritance-in-javascript#constructor-functions">tutorial de prototipos y herencia</a>, confeccionamos un ejemplo basado en la creación de personajes en un juego de roles basado en texto. Continuaremos con ese ejemplo aquí para actualizar la sintaxis de funciones a clases.</p>

<p>Una <strong>función constructora</strong> se inicializa con varios parámetros que se asignarían como propiedades de <code>this</code>, en alusión a la propia función. La primera letra del identificador sería mayúscula por convención.</p>
<div class="code-label " title="constructor.js">constructor.js</div><pre class="code-pre  second-environment"><code class="code-highlight language-js">// Initializing a constructor function
function Hero(name, level) {
    this.name = name;
    this.level = level;
}
</code></pre>
<p>Cuando traducimos esto a la sintaxis de <strong>clase</strong>, que se muestra a continuación, vemos que su estructura es bastante similar.</p>
<div class="code-label " title="class.js">class.js</div><pre class="code-pre  fourth-environment"><code class="code-highlight language-js">// Initializing a class definition
class Hero {
    constructor(name, level) {
        this.name = name;
        this.level = level;
    }
}
</code></pre>
<p>Sabemos que una función constructora está pensada para ser un esquema de objeto por el uso de mayúscula en la primera letra del inicializador (opcional) y a través de la familiaridad con la sintaxis. La palabra clave <code>class</code> comunica de una manera más directa el objetivo de nuestra función.</p>

<p>La única diferencia en la sintaxis de la inicialización tiene que ver con el uso de la palabra clave <code>class</code> en lugar de <code>function</code>, y con la asignación de las propiedades dentro de un método <code>constructor()</code>.</p>

<h2 id="definir-métodos">Definir métodos</h2>

<p>La práctica común con funciones constructoras consiste en asignar métodos directamente a <code>prototype</code> en lugar de hacerlo con la initialización, como se aprecia en el método <code>greet()</code> a continuación.</p>
<div class="code-label " title="constructor.js">constructor.js</div><pre class="code-pre  second-environment"><code class="code-highlight language-js">function Hero(name, level) {
    this.name = name;
    this.level = level;
}

// Adding a method to the constructor
Hero.prototype.greet = function() {
    return `${this.name} says hello.`;
}
</code></pre>
<p>Con clases, esta sintaxis se simplifica y el método puede agregarse directamente a las clases. Al usar la <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions">abreviatura de definición de método</a> introducida en ES6, se logra una concisión aun mayor al definir un método.</p>
<div class="code-label " title="class.js">class.js</div><pre class="code-pre  fourth-environment"><code class="code-highlight language-js">class Hero {
    constructor(name, level) {
        this.name = name;
        this.level = level;
    }

    // Adding a method to the constructor
    greet() {
        return `${this.name} says hello.`;
    }
}
</code></pre>
<p>Observemos estas propiedades y métodos en acción. Crearemos una nueva instancia de <code>Hero</code> usando la palabra clave <code>new</code> y asignaremos algunos valores.</p>
<pre class="code-pre  fourth-environment"><code class="code-highlight language-js">const hero1 = new Hero('Varg', 1);
</code></pre>
<p>Si imprimimos más información sobre nuestro nuevo objeto con <code>console.log(hero1)</code>, podemos apreciar más detalles sobre lo que sucede con la inicialización de clase.</p>
<pre class="code-pre  fourth-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>Hero {name: "Varg", level: 1}
__proto__:
  ▶ constructor: class Hero
  ▶ greet: ƒ greet()
</code></pre>
<p>Podemos ver en el resultado que las funciones <code>constructor()</code> y <code>greet()</code> se aplicaron a <code>__proto__</code>, o <code>[[Prototype]]</code> de <code>hero1</code>, y no directamente como método en el objeto <code>hero1</code>. Aunque esto queda de manifiesto en la creación de funciones de constructor, no resulta evidente al crear clases. Las clases permiten una sintaxis más sencilla y sucinta, aunque sacrifican algo de claridad en el proceso.</p>

<h2 id="ampliar-una-clase">Ampliar una clase</h2>

<p>Una característica ventajosa de las funciones y clases constructoras es que pueden ampliarse a nuevos esquemas de objeto basados en el elemento principal. Esto impide la repetición de código para objetos similares, pero necesitan características adicionales o más específicas.</p>

<p>Se pueden crear nuevas funciones constructoras desde el elemento principal usando el método <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call"><code>call()</code></a>. En el siguiente ejemplo, crearemos una clase de carácter más específica llamada <code>Mage</code> y le asignaremos las propiedades de <code>Hero</code> usando <code>call()</code>, además de agregar una propiedad.</p>
<div class="code-label " title="constructor.js">constructor.js</div><pre class="code-pre  second-environment"><code class="code-highlight language-js">// Creating a new constructor from the parent
function Mage(name, level, spell) {
    // Chain constructor with call
    Hero.call(this, name, level);

    this.spell = spell;
}
</code></pre>
<p>En este punto, podemos crear una nueva instancia de <code>Mage</code> usando las mismas propiedades de <code>Hero</code>, así como también una nueva que agregamos.</p>
<pre class="code-pre  second-environment"><code class="code-highlight language-js">const hero2 = new Mage('Lejon', 2, 'Magic Missile');
</code></pre>
<p>Al enviar <code>hero2</code> a la consola, podemos apreciar que creamos una nueva clase <code>Mage</code> basada en la constructora.</p>
<pre class="code-pre  second-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>Mage {name: "Lejon", level: 2, spell: "Magic Missile"}
__proto__:
    ▶ constructor: ƒ Mage(name, level, spell)
</code></pre>
<p>Con clases de ES6, la palabra clave <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super"><code>super</code></a> se usa en lugar de <code>call</code> para acceder a las funciones principales. Usaremos <code>extends</code> para hacer referencia a la clase principal.</p>
<div class="code-label " title="class.js">class.js</div><pre class="code-pre  fourth-environment"><code class="code-highlight language-js">// Creating a new class from the parent
class Mage extends Hero {
    constructor(name, level, spell) {
        // Chain constructor with super
        super(name, level);

        // Add a new property
        this.spell = spell;
    }
}
</code></pre>
<p>Ahora podemos crear una nueva instancia de <code>Mage</code> de la misma manera.</p>
<pre class="code-pre  fourth-environment"><code class="code-highlight language-js">const hero2 = new Mage('Lejon', 2, 'Magic Missile');
</code></pre>
<p>Imprimiremos <code>hero2</code> en la consola y veremos el resultado.</p>
<pre class="code-pre  fourth-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>Mage {name: "Lejon", level: 2, spell: "Magic Missile"}
__proto__: Hero
    ▶ constructor: class Mage
</code></pre>
<p>El resultado es casi exactamente el mismo, con la diferencia de que en la construcción de clase <code>[[Prototype]]</code> se vincula al elemento principal; en este caso, <code>Hero</code>.</p>

<p>A continuación, se muestra una comparación en paralelo de todo el proceso de inicialización, incorporación de métodos y herencia de una función constructor y una clase.</p>
<div class="code-label " title="constructor.js">constructor.js</div><pre class="code-pre  second-environment"><code class="code-highlight language-js">function Hero(name, level) {
    this.name = name;
    this.level = level;
}

// Adding a method to the constructor
Hero.prototype.greet = function() {
    return `${this.name} says hello.`;
}

// Creating a new constructor from the parent
function Mage(name, level, spell) {
    // Chain constructor with call
    Hero.call(this, name, level);

    this.spell = spell;
}
</code></pre><div class="code-label " title="class.js">class.js</div><pre class="code-pre  fourth-environment"><code class="code-highlight language-js">// Initializing a class
class Hero {
    constructor(name, level) {
        this.name = name;
        this.level = level;
    }

    // Adding a method to the constructor
    greet() {
        return `${this.name} says hello.`;
    }
}

// Creating a new class from the parent
class Mage extends Hero {
    constructor(name, level, spell) {
        // Chain constructor with super
        super(name, level);

        // Add a new property
        this.spell = spell;
    }
}
</code></pre>
<p>Aunque la sintaxis es bastante distinta, el resultado subyacente es casi el mismo para ambos métodos. Las clases nos ofrecen una alternativa más concisa para crear esquemas de objeto y las funciones constructor describen con mayor precisión lo que sucede en segundo plano.</p>

<h2 id="conclusión">Conclusión</h2>

<p>En este tutorial, incorporó conocimientos sobre las similitudes y diferencias entre las funciones constructor de JavaScript y las clases de ES6. Tanto las clases como las funciones constructor imitan un modelo de herencia orientado hacia objetos para JavaScript, que es un lenguaje de herencia basado en prototipos.</p>

<p>Comprender la herencia prototípica es primordial para desempeñarse con eficacia como desarrollador de JavaScript. Familiarizarse con las clases es extremadamente útil, ya que en las bibliotecas de JavaScript populares como <a href="https://reactjs.org/">React</a> se usa con frecuencia la sintaxis <code>class</code>.</p>
