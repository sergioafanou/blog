---
layout: post
title: Использование ldflags для установки информации о версиях в приложениях Go
network: digitalocean
date: January 24, 2020 at 04:42AM
url: https://www.digitalocean.com/community/tutorials/using-ldflags-to-set-version-information-for-go-applications-ru
image: http://ifttt.com/images/no_image_card.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="Введение">Введение</h3>

<p>При развертывании приложений в производственной среде сборка двоичных файлов с информацией о версии и другими метаданными помогает улучшить процессы мониторинга, регистрации данных и отладки за счет добавления идентификационной информации для отслеживания версий сборок. Информация о версии часто содержит динамические данные, такие как время сборки, компьютер или пользователя, выполняющих сборку двоичного файла, идентификатор в <a href="https://www.atlassian.com/git/tutorials/what-is-version-control">системе контроля версий (VCS)</a> и т. д. Поскольку эти значения постоянно меняются, внесение этих данных в исходный код и их изменение при каждой сборке становится непростой задачей, где могут возникнуть ошибки. Файлы исходного кода могут перемещаться, <a href="https://www.digitalocean.com/community/tutorials/how-to-use-variables-and-constants-in-go">переменные и константы</a> могут менять файлы во время разработки, и все это может нарушить процесс сборки.</p>

<p>В Go эту проблему можно решить с помощью опции <code>-ldflags</code> команды <code>go build</code>. Эта опция вставляет в двоичный файл во время сборки динамическую информацию, не требуя изменения исходного кода. В этой опции <code>ld</code> означает программу <a href="https://en.wikipedia.org/wiki/Linker_(computing)"><em>linker</em></a>, которая связывает разные фрагменты скомпилированного исходного кода в двоичном файле. Таким образом, название опции <code>ldflags</code> означает <em>флаги linker</em>. Данная опция передает файл в инструмент linker цепи инструментов Go  <a href="https://golang.org/cmd/link"><code>cmd/link</code></a>, позволяющий изменять значения импортированных пакетов во время сборки из командной строки.</p>

<p>В этом обучающем руководстве вы научитесь использовать <code>-ldflags</code> для изменения значения переменных во время сборки и внесения в двоичный файл собственных динамических данных, используя для этого образец приложения, которое распечатывает на экране информацию о версии.</p>

<h2 id="Предварительные-требования">Предварительные требования</h2>

<p>Для выполнения примера из этой статьи вам потребуется следующее:</p>

<ul>
<li>Рабочее пространство Go, настроенное согласно руководству <a href="https://www.digitalocean.com/community/tutorial_series/how-to-install-and-set-up-a-local-programming-environment-for-go">по установке Go и настройке локальной среды для разработки</a>.</li>
</ul>

<h2 id="Создание-образца-приложения">Создание образца приложения</h2>

<p>Прежде чем вы сможете использовать <code>ldflags</code> для внесения динамических данных, вам потребуется приложение, куда нужно вставлять эти данные. На этом шаге вы создадите такое приложение, которое на данном этапе будет только выводить статическую информацию о версии. Давайте создадим это приложение.</p>

<p>Создайте внутри каталога <code>src</code> подкаталог с именем вашего приложения. В этом обучающем руководстве мы будем использовать имя приложения <code><span class="highlight">app</span></code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir <span class="highlight">app</span>
</li></ul></code></pre>
<p>Смените рабочий каталог на эту папку:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd <span class="highlight">app</span>
</li></ul></code></pre>
<p>Затем используйте предпочитаемый текстовый редактор для создания входной точки программы, <code>main.go</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano main.go
</li></ul></code></pre>
<p>Добавьте следующий код, чтобы ваше приложение распечатывало информацию о версии:</p>
<div class="code-label " title="app/main.go">app/main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import (
    "fmt"
)

var Version = "development"

func main() {
    fmt.Println("Version:\t", Version)
}
</code></pre>
<p>Внутри функции <code>main()</code> вы декларировали переменную <code>Version</code>, затем распечатали <a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-working-with-strings-in-go">строку</a> <code>Version:</code> с символом табуляции <code>\t</code>, а затем декларированную переменную.</p>

<p>На данном этапе переменная <code>Version</code> имеет заданное значение <code>development</code>, и эта версия будет использоваться для приложения по умолчанию. Впоследствии вы сможете заменить это значение на официальный номер версии, соответствующий <a href="https://semver.org/">желаемому семантическому формату версий</a>.</p>

<p>Сохраните и закройте файл. После этого выполните сборку и запустите приложение, чтобы подтвердить распечатку правильной версии:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go build
</li><li class="line" prefix="$">./<span class="highlight">app</span>
</li></ul></code></pre>
<p>Результат будет выглядеть следующим образом:</p>
<pre class="code-pre command"><code langs=""><div class="secondary-code-label " title="Output">Output</div><ul class="prefixed"><li class="line" prefix="$">Version:     development
</li></ul></code></pre>
<p>Теперь у вас есть приложение, которое распечатывает информацию о версии по умолчанию, однако у вас еще нет способа передачи информации о текущей версии во время сборки. На следующем шаге вы используете <code>-ldflags</code> и <code>go build</code> для решения этой проблемы.</p>

<h2 id="Использование-ldflags-с-go-build">Использование <code>ldflags</code> с <code>go build</code></h2>

<p>Как указывалось выше, <code>ldflags</code> означает <em>флаги linker</em> и используется для передачи флагов в linker через цепочку инструментов Go. При этом используется следующий синтаксис:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go build -ldflags="-<span class="highlight">flag</span>"
</li></ul></code></pre>
<p>В этом примере мы передали <code>флаг</code> в соответствующую команду <code>go tool link</code>, которая запускается в рамках <code>go build</code>. Эта команда заключает в двойные кавычки передаваемое в <code>ldflags</code> содержимое, чтобы предотвратить разрыв символов или неправильную интерпретацию передаваемых символов командной строкой. Отсюда вы можете передать <a href="https://golang.org/cmd/link/">много разных флагов <code>link</code></a>. В этом обучающем руководстве мы используем флаг <code>-X</code> для записи информации в переменную во время связи, а затем указываем путь <a href="https://www.digitalocean.com/community/tutorials/importing-packages-in-go">пакета</a> к переменной и ее новое значение:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go build -ldflags="-X '<span class="highlight">package_path</span>.<span class="highlight">variable_name</span>=<span class="highlight">new_value</span>'"
</li></ul></code></pre>
<p>Внутри кавычек содержится опция <code>-X</code> и <a href="https://www.digitalocean.com/community/tutorials/understanding-maps-in-go#keys-and-values">пара ключ-значение</a>, соответствующая изменяемой переменной и ее новому значению. Символ <code>.</code> разделяет путь пакета и имя переменной, а одинарные кавычки используются для предотвращения разрыва символов в паре ключ-значение.</p>

<p>Чтобы заменить переменную <code>Version</code> в нашем примере приложения, используйте синтаксис последнего блока команд для передачи нового значения и сборки нового двоичного файла:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go build -ldflags="-X 'main.Version=v1.0.0'"
</li></ul></code></pre>
<p>В этой команде <code>main</code> — это путь пакета переменной <code>Version</code>, поскольку данная переменная содержится в файле <code>main.go</code>. <code>Version</code> — это переменная, в которую выполняется запись, а <code>v1.0.0</code> — это новое значение.</p>

<p>Для использования <code>ldflags</code> необходимо, чтобы изменяемое значение  существовало и относилось к переменной уровня пакета типа <code>string</code>. Эта переменная может быть экспортированной или неэкспортированной. Значение не может быть <code>const</code> и не может задаваться результатом вызова функции. К счастью, <code>Version</code> соответствует всем этим требованиям. Она уже декларирована как переменная в файле <code>main.go</code> и ее текущее значение (<code>development</code>) и желаемое значение (<code>v1.0.0</code>) являются строками.</p>

<p>После сборки нового двоичного файла <code><span class="highlight">app</span></code> запустите приложение:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">./<span class="highlight">app</span>
</li></ul></code></pre>
<p>Результат будет выглядеть следующим образом:</p>
<pre class="code-pre command"><code langs=""><div class="secondary-code-label " title="Output">Output</div><ul class="prefixed"><li class="line" prefix="$">Version:     <span class="highlight">v1.0.0</span>
</li></ul></code></pre>
<p>С помощью <code>-ldflags</code> вы успешно изменили значение переменной <code>Version</code> с <code>development</code> на <code>v1.0.0</code>.</p>

<p>Теперь вы изменили переменную <code>string</code> внутри простого приложения во время сборки. С помощью <code>ldflags</code> вы можете вставлять в двоичный файл сведения о версии, информацию о лицензирование и другие данные, используя только командную строку.</p>

<p>В этом примере измененная переменная находилась в программе <code>main</code>, и благодаря этому было  проще определить имя пути. Однако иногда путь к таким переменным бывает сложнее найти. На следующем шаге вы запишете значения в переменные в субпакетах, используя наилучший способ определения более сложных путей пакетов.</p>

<h2 id="Таргетирование-переменных-субпакета">Таргетирование переменных субпакета</h2>

<p>В последнем разделе вы внесли изменения в переменную <code>Version</code> в пакете верхнего уровня приложения. Однако ситуация не всегда такая простая. Очень часто наиболее практичным способом будет поместить эти переменные в другой пакет, поскольку пакет <code>main</code> не является импортируемым. Чтобы смоделировать это в образце приложения вы создадите новый субпакет <code><span class="highlight">app</span>/build</code>, в котором будет храниться информация о времени сборки двоичного файла и имени пользователя, отправившего команду сборки.</p>

<p>Чтобы добавить новый субпакет, добавьте в проект новый каталог с именем <code>build</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir -p build
</li></ul></code></pre>
<p>Затем создайте новый файл с именем <code>build.go</code> для хранения новых переменных:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano build/build.go
</li></ul></code></pre>
<p>Добавьте в текстовом редакторе новые переменные <code>Time</code> и <code>User</code>:</p>
<div class="code-label " title="app/build/build.go">app/build/build.go</div><pre class="code-pre "><code class="code-highlight language-go">package build

var Time string

var User string
</code></pre>
<p>Переменная <code>Time</code> хранит время сборки двоичного файла в форме строки. Переменная <code>User</code> хранит имя пользователя, который выполнил сборку двоичного файла. Поскольку эти две переменные всегда имеют значения, их не нужно инициализировать с помощью значений по умолчанию, как вы это делали для переменной <code>Version</code>.</p>

<p>Сохраните и закройте файл.</p>

<p>Затем откройте файл <code>main.go</code> для добавления этих переменных в ваше приложение:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano main.go
</li></ul></code></pre>
<p>Добавьте в файл <code>main.go</code> следующие выделенные строки:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code langs="">package main

import (
    <span class="highlight">"app/build"</span>
    "fmt"
)

var Version = "development"

func main() {
    fmt.Println("Version:\t", Version)
    <span class="highlight">fmt.Println("build.Time:\t", build.Time)</span>
    <span class="highlight">fmt.Println("build.User:\t", build.User)</span>
}
</code></pre>
<p>В этих строках вы вначале импортируете пакет <code><span class="highlight">app</span>/build</code>, а затем выполняете печать <code>build.Time</code> и <code>build.User</code> точно так же, как и при печати переменной <code>Version</code>.</p>

<p>Сохраните файл и закройте текстовый редактор.</p>

<p>Чтобы сделать эти переменные целью опции <code>ldflags</code>, вы можете использовать путь импорта <code><span class="highlight">app</span>/build</code> с символом  <code>.</code> в конце User или <code>. Time</code>, поскольку вам уже известен путь импорта. Для моделирования более сложной ситуации, когда путь к переменной не очевиден, мы используем команду <code>nm</code> в цепочке инструментов Go.</p>

<p>Команда <code>go tool nm</code> выводит <em>символы</em> из заданного исполняемого файла, объектного файла или архива. В данном случае символ относится к объекту в коде, например, к определенной или импортированной переменной или функции. Генерирование таблицы символов с помощью команды <code>nm</code> и использование <code>grep</code> для поиска переменной позволяет быстро найти информацию о пути.</p>

<p><span class='note'><strong>Примечание:</strong> команда <code>nm</code> не поможет найти путь к переменной, если имя пакета содержит любые символы, кроме символов <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a>, или содержит символ <code>"</code> или <code>%</code>, поскольку это ограничение относится к самому инструменту.<br></span></p>

<p>Для использования этой команды выполните сборку двоичного файла для <code><span class="highlight">app</span></code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go build
</li></ul></code></pre>
<p>После сборки <code><span class="highlight">app</span></code> укажите на него инструменту <code>nm</code> и выполните поиск в результатах:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go tool nm ./<span class="highlight">app</span> | grep <span class="highlight">app</span>
</li></ul></code></pre>
<p>Инструмент <code>nm</code> выводит большое количество данных. В связи с этим в предыдущей команде использовался оператор <code>|</code> для передачи результатов в команду <code>grep</code>, которая выполняет поиск терминов с <code><span class="highlight">app</span></code> верхнего уровня в заголовке.</p>

<p>Результат должен выглядеть примерно так:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>  <span class="highlight">55d2c0 D app/build.Time</span>
  <span class="highlight">55d2d0 D app/build.User</span>
  4069a0 T runtime.appendIntStr
  462580 T strconv.appendEscapedRune
. . .
</code></pre>
<p>В данном случае первые две строки набора результатов содержат пути к двум переменным, которые вы ищете: <code><span class="highlight">app</span>/build.Time</code> и <code><span class="highlight">app</span>/build.User</code>.</p>

<p>Теперь вам известны пути, и вы можете снова выполнить сборку приложения с изменением переменных <code>Version</code>, <code>User</code> и <code>Time</code> во время сборки. Для этого нужно передать несколько флагов <code>-X</code> в <code>-ldflags</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go build -v -ldflags="-X 'main.Version=v1.0.0' -X 'app/build.User=$(id -u -n)' -X 'app/build.Time=$(date)'"
</li></ul></code></pre>
<p>Вы передали команду Bash <code>id -u -n</code> для вывода текущего пользователя и команду <code>date</code> для вывода текущей даты.</p>

<p>После сборки исполняемого файла запустите программу:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">./<span class="highlight">app</span>
</li></ul></code></pre>
<p>В системе Unix эта команда выводит примерно следующие результаты:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Version:     v1.0.0
build.Time:  <span class="highlight">Fri Oct  4 19:49:19 UTC 2019</span>
build.User:  <span class="highlight">sammy</span>
</code></pre>
<p>Теперь у вас имеется двоичный файл с информацией о версии и сборке, который будет полезен при решении возможных проблем в производственной среде.</p>

<h2 id="Заключение">Заключение</h2>

<p>В этом обучающем руководстве показано, как правильно использовать мощный инструмент <code>ldflags</code> для вставки в двоичные файлы ценной информации во время сборки. Так вы можете контролировать флаги функций, информацию о среде, информацию о версиях и другие данные, не внося изменений в исходный код. Использование <code>ldflags</code> в рабочем процессе сборки позволяет в полной мере получить преимущества самодостаточного формата распространения двоичных файлов Go.</p>

<p>Дополнительную информацию о языке программирования Go можно найти в серии статей и обучающих статей <a href="https://www.digitalocean.com/community/tutorial_series/how-to-code-in-go">Программирование на Go</a>. Если вам нужно больше решений для контроля версий, воспользуйтесь справочным руководством <a href="https://www.digitalocean.com/community/tutorials/how-to-use-git-a-reference-guide">Использование Git</a>.</p>
