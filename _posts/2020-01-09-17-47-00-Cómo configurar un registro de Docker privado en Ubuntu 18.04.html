---
layout: post
title: Cómo configurar un registro de Docker privado en Ubuntu 18.04
network: digitalocean
date: January 09, 2020 at 05:47PM
url: https://www.digitalocean.com/community/tutorials/how-to-set-up-a-private-docker-registry-on-ubuntu-18-04-es
image: http://ifttt.com/images/no_image_card.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<p><em>El autor seleccionó la <a href="https://www.brightfunds.org/organizations/apache-software-foundation">Apache Software Foundation</a>  para recibir una donación como parte del programa <a href="https://do.co/w4do-cta">Write for DOnations</a>.</em></p>

<h3 id="introducción">Introducción</h3>

<p><a href="https://docs.docker.com/registry/#what-it-is">Docker Registry</a> es una aplicación que gestiona el almacenamiento y el envío de imágenes de contenedores de Docker. Los registros centralizan las imágenes de contenedores y reducen el tiempo de compilación para los desarrolladores. Las imágenes de Docker garantizan el mismo entorno de ejecución a través de la virtualización, pero crear una imagen puede suponer una inversión significativa en términos de tiempo. Por ejemplo, en vez de instalar dependencias y paquetes por separado para usar Docker, los desarrolladores pueden descargar una imagen comprimida de un registro que contenga todos los componentes necesarios. Además, los desarrolladores pueden automatizar la introducción de imágenes en un registro usando herramientas de integración continua, como <a href="https://travis-ci.com/">TravisCI</a>, para actualizar imágenes sin problemas durante la producción y el desarrollo.</p>

<p>Docker también tiene un registro público gratuito, <a href="https://hub.docker.com/">Docker Hub</a>, que puede alojar sus imágenes de Docker personalizadas, pero existen situaciones en las que no le convendrá que su imagen esté disponible públicamente. Las imágenes normalmente contienen todo el código necesario para ejecutar una aplicación. Por lo tanto, usar un registro privado es preferible cuando se utiliza software propio.</p>

<p>A través de este tutorial, configurará y protegerá su propio Docker Registry privado. Usará <a href="https://docs.docker.com/compose/">Docker Compose</a> para definir las configuraciones a fin de ejecutar Nginx y sus aplicaciones de Docker para reenviar el tráfico del servidor de HTTPS al contenedor de Docker en ejecución. Una vez que complete este tutorial, podrá introducir una imagen de Docker personalizada en su registro privado y extraer la imagen de forma segura desde un servidor remoto.</p>

<h2 id="requisitos-previos">Requisitos previos</h2>

<p>Antes de iniciar esta guía, necesitará lo siguiente:</p>

<ul>
<li>Dos servidores de Ubuntu 18.04 configurados conform<a href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04">e a la guía de configuración inicial para servidores de Ubunt</a>u 18.04, incluidos un usuario sudo no root y un firewall. Un servidor alojará su Docker Registry privado y el otro será su servidor <strong>cliente</strong>.</li>
<li>Docker y Docker Compose instalados en ambos servidores siguiendo el tutorial <a href="https://www.digitalocean.com/community/tutorials/how-to-install-docker-compose-on-ubuntu-18-04">Cómo instalar Docker Compose en Ubuntu 18.04</a>. Solo necesitará completar el primer paso de este tutorial para instalar Docker Compose. En este tutorial se explica la forma de instalar Docker como parte de sus requisitos previos.</li>
<li>Nginx instalado en su servidor de Docker Registry privado, conforme al tutorial <a href="https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-ubuntu-18-04">Cómo instalar Nginx en Ubuntu 18.04</a>.</li>
<li>Nginx protegido con Let´s Encrypt en su servidor para el Docker Registry privado, conforme a <a href="https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-18-04">Cómo proteger Nginx con Let´s Encrypt</a>. Asegúrese de redireccionar todo el tráfico de HTTP a HTTPS en el paso 4.</li>
<li>Un nombre de dominio que resuelve en el servidor que está usando para el Docker Registry privado. Configurará esto como parte del requisito previo de Let´s Encrypt.</li>
</ul>

<h2 id="paso-1-instalar-y-configurar-el-docker-registry">Paso 1: Instalar y configurar el Docker Registry</h2>

<p>La herramienta de línea de comandos de Docker es útil para iniciar y administrar uno o dos contenedores de Docker. Sin embargo, para una implementación completa la mayoría de las aplicaciones que se ejecutan dentro de contenedores de Docker requieren que otros componentes se ejecuten en paralelo. Por ejemplo, muchas aplicaciones web constan de un servidor web, como Nginx, que presente el código de la aplicación, un lenguaje de creación de secuencia de comandos interpretado como PHP, y un servidor de base de datos como MySQL.</p>

<p>Con Docker Compose, puede escribir un archivo <code>.yml</code> para configurar los ajustes de cada uno de los contenedores y la información que estos deben transmitirse entre sí. Puede usar la herramienta de línea de comandos <code>docker-componse</code> para emitir comandos a todos los componentes que forman su aplicación.</p>

<p>Docker Registry es en sí misma una aplicación con varios componentes, por lo que utilizará Docker Compose para administrar su configuración. Para iniciar una instancia del registro, configurará un archivo <code>docker-compose.yml</code>  para definir la ubicación en la que su registro almacenará sus datos.</p>

<p>En el servidor que creó para alojar su Docker Registry privado, puede crear un directorio <code>docker-registry</code>, moverlo a él, y luego crear una subcarpeta <code>data</code> con los siguientes comandos:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir ~/docker-registry &amp;&amp; cd $_
</li><li class="line" prefix="$">mkdir data
</li></ul></code></pre>
<p>Utilice su editor de texto para crear el archivo de configuración <code>docker-compose.yml</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano docker-compose.yml
</li></ul></code></pre>
<p>Añada el siguiente contenido al archivo, que describe la configuración básica para un Docker Registry:</p>
<div class="code-label " title="docker-compose.yml">docker-compose.yml</div><pre class="code-pre docker-compose"><code langs="">version: '3'

services:
  registry:
    image: registry:2
    ports:
    - "5000:5000"
    environment:
      REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY: /data
    volumes:
      - ./data:/data
</code></pre>
<p>En la sección <code>environment</code> se establece una variable de entorno en el contenedor de Docker Registry con la ruta <code>/data</code>. La aplicación Docker Registry verifica esta variable de entorno cuando se inicia, y como resultado, comienza a guardar sus datos en la carpeta <code>/data</code>.</p>

<p>Sin embargo, debido a que incluyó la línea <code>volumes: - ./data:/data</code>, Docker comenzará a asignar el directorio <code>/data</code> de ese contenedor a <code>/data</code> en su servidor de registro. Como resultado final, los datos de Docker Registry se almacenan en <code>~/docker-registry/data</code> en el servidor de registro.</p>

<p>La sección <code>ports</code>, con la configuración <code>5000:5000</code>, indica a Docker que asigne el puerto <code>5000</code> en el servidor al puerto <code>5000</code> en el contenedor en ejecución. Esto le permite enviar una solicitud al puerto <code>5000</code> en el servidor, y que la solicitud se reenvíe a la aplicación de registro.</p>

<p>Ahora puede iniciar Docker Compose para comprobar la configuración:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose up
</li></ul></code></pre>
<p>Verá las barras de descarga en su resultado, que muestran que Docker está descargando la imagen de Docker Registry del registro propio de Docker. En un minuto o dos, verá un resultado similar al siguiente (las versiones pueden variar):</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output of docker-compose up">Output of docker-compose up</div>Starting docker-registry_registry_1 ... done
Attaching to docker-registry_registry_1
registry_1  | time="2018-11-06T18:43:09Z" level=warning msg="No HTTP secret provided - generated random secret. This may cause problems with uploads if multiple registries are behind a load-balancer. To provide a shared secret, fill in http.secret in the configuration file or set the REGISTRY_HTTP_SECRET environment variable." go.version=go1.7.6 instance.id=c63483ee-7ad5-4205-9e28-3e809c843d42 version=v2.6.2
registry_1  | time="2018-11-06T18:43:09Z" level=info msg="redis not configured" go.version=go1.7.6 instance.id=c63483ee-7ad5-4205-9e28-3e809c843d42 version=v2.6.2
registry_1  | time="2018-11-06T18:43:09Z" level=info msg="Starting upload purge in 20m0s" go.version=go1.7.6 instance.id=c63483ee-7ad5-4205-9e28-3e809c843d42 version=v2.6.2
registry_1  | time="2018-11-06T18:43:09Z" level=info msg="using inmemory blob descriptor cache" go.version=go1.7.6 instance.id=c63483ee-7ad5-4205-9e28-3e809c843d42 version=v2.6.2
registry_1  | time="2018-11-06T18:43:09Z" level=info msg="listening on [::]:5000" go.version=go1.7.6 instance.id=c63483ee-7ad5-4205-9e28-3e809c843d42 version=v2.6.2
</code></pre>
<p>Abordará el mensaje de advertencia <code>No HTTP secret provided</code> posteriormente en este tutorial. El resultado muestra que el contenedor se está iniciando. La última línea del resultado muestra que comenzó a escuchar correctamente en el puerto <code>5000</code>.</p>

<p>Por defecto, Docker Compose esperará su intervención. Por ello, pulse <code>CTRL+C</code> para apagar su contenedor de Docker Registry.</p>

<p>Configuró una escucha completa de Docker Registry en el puerto <code>5000</code>. En este momento, el registro no se iniciará a menos que lo abra manualmente. Además, Docker Registry no tiene ningún mecanismo de autenticación incorporado, por lo que actualmente no es seguro y está completamente abierto al público. En los siguientes pasos, abordará estos problemas de seguridad.</p>

<h2 id="paso-2-configurar-el-reenvío-de-puertos-de-nginx">Paso 2: Configurar el reenvío de puertos de Nginx</h2>

<p>Ya tiene HTTPS configurado en su servidor de Docker Registry con Nginx, lo que significa que ahora puede configurar el enrutamiento de puertos de Nginx al puerto <code>5000</code>. Una vez que complete este paso, podrá acceder a su registro directamente en <span class="highlight">example.com</span>.</p>

<p>Como parte del requisito previo de <a href="https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-18-04">Cómo proteger Nginx con Let´s Encrypt</a>, ya configuró el archivo <code>/etc/nginx/sites-available/<span class="highlight">example.com</span></code> que contiene la configuración de su servidor.</p>

<p>Abra este archivo con su editor de texto:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nano /etc/nginx/sites-available/<span class="highlight">example.com</span>
</li></ul></code></pre>
<p>Encuentre la línea <code>location</code> existente. Tendrá el siguiente aspecto:</p>
<div class="code-label " title="/etc/nginx/sites-available/example.com">/etc/nginx/sites-available/example.com</div><pre class="code-pre "><code langs="">...
location / {
  ...
}
...
</code></pre>
<p>Deberá reenviar el tráfico al puerto <code>5000</code>, donde se ejecutará su registro. También le conviene adjuntar encabezados a la solicitud al registro, que proporcionan información adicional desde el servidor con cada solicitud y respuesta. Elimine el contenido de la sección <code>location</code>, y añada el siguiente contenido a dicha sección:</p>
<div class="code-label " title="/etc/nginx/sites-available/example.com">/etc/nginx/sites-available/example.com</div><pre class="code-pre "><code langs="">...
location / {
    # Do not allow connections from docker 1.5 and earlier
    # docker pre-1.6.0 did not properly set the user agent on ping, catch "Go *" user agents
    if ($http_user_agent ~ "^(docker\/1\.(3|4|5(?!\.[0-9]-dev))|Go ).*$" ) {
      return 404;
    }

    proxy_pass                          http://localhost:5000;
    proxy_set_header  Host              $http_host;   # required for docker client's sake
    proxy_set_header  X-Real-IP         $remote_addr; # pass on real client's IP
    proxy_set_header  X-Forwarded-For   $proxy_add_x_forwarded_for;
    proxy_set_header  X-Forwarded-Proto $scheme;
    proxy_read_timeout                  900;
}
...
</code></pre>
<p>La sección <code>$http_user_agent</code> verifica que la versión de Docker del cliente sea superior a la <code>1.5</code> y garantiza que <code>UserAgent</code> no sea una aplicación de <code>Go</code>. Debido a que usa la versión <code>2.0</code> del registro, los clientes más antiguos no son compatibles. Para obtener más información, puede encontrar la configuración de encabezados <code>nginx</code> en la <a href="https://docs.docker.com/registry/recipes/nginx/#setting-things-up">guía Nginx Docker Registry.</a></p>

<p>Guarde el archivo y ciérrelo. Aplique los cambios reiniciando Nginx:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo service nginx restart
</li></ul></code></pre>
<p>Puede confirmar que Nginx enrute el tráfico al puerto <code>5000</code> ejecutando el registro:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd ~/docker-registry
</li><li class="line" prefix="$">docker-compose up
</li></ul></code></pre>
<p>En una ventana del navegador, abra la siguiente URL:</p>
<pre class="code-pre "><code langs="">https://<span class="highlight">example.com</span>/v2
</code></pre>
<p>Verá un objeto JSON vacío, o lo siguiente:</p>
<pre class="code-pre "><code langs="">{}
</code></pre>
<p>En su terminal, verá un resultado similar al siguiente:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output of docker-compose up">Output of docker-compose up</div>registry_1  | time="2018-11-07T17:57:42Z" level=info msg="response completed" go.version=go1.7.6 http.request.host=cornellappdev.com http.request.id=a8f5984e-15e3-4946-9c40-d71f8557652f http.request.method=GET http.request.remoteaddr=128.84.125.58 http.request.uri="/v2/" http.request.useragent="Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_2) AppleWebKit/604.4.7 (KHTML, like Gecko) Version/11.0.2 Safari/604.4.7" http.response.contenttype="application/json; charset=utf-8" http.response.duration=2.125995ms http.response.status=200 http.response.written=2 instance.id=3093e5ab-5715-42bc-808e-73f310848860 version=v2.6.2
registry_1  | 172.18.0.1 - - [07/Nov/2018:17:57:42 +0000] "GET /v2/ HTTP/1.0" 200 2 "" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_2) AppleWebKit/604.4.7 (KHTML, like Gecko) Version/11.0.2 Safari/604.4.7"
</code></pre>
<p>Puede ver la última línea desde la cual se realizó una solicitud <code>GET</code> a <code>/v2/</code>, que es el punto final al que envío la solicitud desde su navegador. El contenedor recibió la solicitud que realizó, desde el puerto del enrutamiento, y devolvió una respuesta <code>{}</code>. El código <code>200</code> en la última línea del resultado significa que el contenedor gestionó la solicitud correctamente.</p>

<p>Ahora que configuró el enrutamiento de puertos, puede mejorar la seguridad de su registro.</p>

<h2 id="paso-3-configurar-la-autenticación">Paso 3: Configurar la autenticación</h2>

<p>Con las solicitudes de proxy de Nginx, puede proteger su registro con autenticación HTTP para administrar el acceso a su Docker Registry. Para conseguir esto, creará un archivo de autenticación con <code>htpasswd</code> y le añadirá usuarios. La autenticación HTTP se configura rápidamente y es segura a través de una conexión HTTPS, que es la que el registro usará.</p>

<p>Puede instalar el paquete <code>htpasswd</code> ejecutando lo siguiente:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt install apache2-utils
</li></ul></code></pre>
<p>Ahora creará el directorio en el que almacenará nuestras credenciales de autenticación y se posicionará en ese directorio. <code>$</code> se expande al último argumento del comando anterior; en este caso, <code>~/docker-registry/auth</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir ~/docker-registry/auth &amp;&amp; cd $_
</li></ul></code></pre>
<p>A continuación, creará el primer usuario de como se muestra a continuación, sustituyendo <code><span class="highlight">username</span></code> por el nombre de usuario que desee usar. El indicador <code>-B</code> especifica el cifrado <code>bcrypt</code>, que es más seguro que el cifrado predeterminado. Introduzca la contraseña cuando se le solicite:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">htpasswd -Bc registry.password <span class="highlight">username</span>
</li></ul></code></pre>
<span class='note '><p>*<em>Nota: *</em>Para agregar más usuarios, vuelva a ejecutar el comando anterior sin la opción -c, (la “<code>c</code>” significa “crear”):</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">htpasswd registry.password <span class="highlight">username</span>
</li></ul></code></pre>
<p></p></span>

<p>A continuación, editará el archivo <code>docker-compose.yml</code> para indicar a Docker que utilice el archivo que creó con el propósito de autenticar usuarios.</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd ~/docker-registry
</li><li class="line" prefix="$">nano docker-compose.yml
</li></ul></code></pre>
<p>Puede añadir variables de entorno y un volumen para el directorio <code>auth/</code> que creó editando el archivo <code>docker-compose.yml</code>, para indicar a Docker la forma en que desea autenticar usuarios. Añada el siguiente contenido resaltado al archivo:</p>
<div class="code-label " title="docker-compose.yml">docker-compose.yml</div><pre class="code-pre docker-compose"><code langs="">version: '3'

services:
  registry:
    image: registry:2
    ports:
    - "5000:5000"
    environment:
      <span class="highlight">REGISTRY_AUTH: htpasswd</span>
      <span class="highlight">REGISTRY_AUTH_HTPASSWD_REALM: Registry</span>
      <span class="highlight">REGISTRY_AUTH_HTPASSWD_PATH: /auth/registry.password</span>
      REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY: /data
    volumes:
      <span class="highlight">- ./auth:/auth</span>
      - ./data:/data
</code></pre>
<p>Para <code>REGISTRY_AUTH</code> especificó <code>htpasswd</code>, que es el esquema de autenticación que está usando, y fijó <code>REGISTRY_AUTH_HTPASSWD_PATH</code> en la ruta del archivo de autenticación. Por último, <code>REGISTRY_AUTH_HTPASSWD_REALM</code> es el nombre de dominio de <code>htpasswd</code>.</p>

<p>Ahora puede verificar que su autenticación funcione correctamente ejecutando el registro y comprobando que solicite a los usuarios un nombre de usuario y una contraseña.</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose up
</li></ul></code></pre>
<p>En una ventana del navegador, abra <code>https://<span class="highlight">example.com</span>/v2</code>.</p>

<p>Después de ingresar <code><span class="highlight">username</span></code> y la contraseña correspondiente, verá <code>{}</code> una vez más. Con esto, confirmó la configuración básica de autenticación; el registro solo mostró el resultado después de que usted introducido el nombre de usuario y la contraseña correctos. De esta manera, protegió su registro y puede continuar usándolo.</p>

<h2 id="paso-4-iniciar-docker-registry-como-un-servicio">Paso 4: Iniciar Docker Registry como un servicio</h2>

<p>Le convendrá asegurarse de que su registro se inicie siempre que el sistema se cargue. Si se produce un error imprevisto en el sistema, le convendrá asegurarse de que el registro se reinicie cuando el servidor lo haga. Abra <code>docker-compose.yml</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano docker-compose.yml
</li></ul></code></pre>
<p>Añada la siguiente línea de contenido en <code>registry</code>:</p>
<div class="code-label " title="docker-compose.yml">docker-compose.yml</div><pre class="code-pre docker-compose"><code langs="">...
  registry:
    <span class="highlight">restart: always</span>
...
</code></pre>
<p>Puede iniciar su registro como proceso en segundo plano, lo que le permitirá cerrar la sesión <code>ssh</code> y persistir el proceso:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose up -d
</li></ul></code></pre>
<p>Con su registro ejecutándose en segundo plano, ahora podrá preparar Nginx para subir archivos.</p>

<h2 id="paso-5-aumentar-el-tamaño-para-la-carga-de-archivos-para-nginx">Paso 5: Aumentar el tamaño para la carga de archivos para Nginx</h2>

<p>Para poder introducir una imagen en el registro, deberá asegurarse de que este pueda gestionar cargas de archivos grandes. Aunque Docker divide las cargas de imágenes grandes en capas separadas, a veces pueden ocupar más de <code>1 GB</code>. Por defecto, Nginx tiene un límite de <code>1 MB</code> para las cargas de archivos, de modo que deberá editar el archivo de configuración para <code>nginx</code> y fijar en <code>2 GB</code> el tamaño máximo para la carga de archivos.</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nano /etc/nginx/nginx.conf
</li></ul></code></pre>
<p>Busque la sección <code>http</code> y añada la siguiente línea:</p>
<div class="code-label " title="/etc/nginx/nginx.conf">/etc/nginx/nginx.conf</div><pre class="code-pre "><code langs="">...
http {
        <span class="highlight">client_max_body_size 2000M;</span>
        ...
}
...
</code></pre>
<p>Finalmente, reinicie Nginx para aplicar los cambios en la configuración:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo service nginx restart
</li></ul></code></pre>
<p>Ahora puede subir imágenes grandes a su Docker Registry sin errores de Nginx.</p>

<h2 id="paso-6-hacer-publicaciones-en-su-docker-registry-privado">Paso 6: Hacer publicaciones en su Docker Registry privado</h2>

<p>Ahora estará listo para publicar una imagen en su Docker Registry privado, pero primero deberá crear una imagen. Para este tutorial, creará una imagen sencilla basada en la imagen de <code>ubuntu</code>  de Docker Hub. Docker Hub es un registro alojado públicamente, con muchas imágenes preconfiguradas que pueden utilizarse para “dockerizar” rápidamente aplicaciones. Usando la imagen de <code>ubuntu</code>, probará la introducción en su registro y la y extracción de este.</p>

<p>Desde su servidor <strong>cliente</strong>, cree una imagen pequeña y vacía para la introducción en su nuevo registro; los indicadores <code>-i</code> y <code>-t</code> le proporcionan acceso  de shell interactivo al contenedor:</p>
<pre class="code-pre command second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker run -t -i ubuntu /bin/bash
</li></ul></code></pre>
<p>Tras terminar la descarga, se posicionará dentro de una instrucción de Docker. Tenga en cuenta que el ID de su contenedor después de <code>root@</code> variará. Realice un cambio rápido en el sistema de archivos creando un archivo llamado <code>SUCCESS</code>. En el siguiente paso, podrá usar este archivo para determinar si el proceso de publicación se realiza correctamente:</p>
<pre class="code-pre custom_prefix second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="root@f7e13d5464d1:/#">touch /SUCCESS
</li></ul></code></pre>
<p>Cierre el contenedor de Docker:</p>
<pre class="code-pre custom_prefix second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="root@f7e13d5464d1:/#">exit
</li></ul></code></pre>
<p>Con el siguiente comando, se crea una nueva imagen llamada <code>test-image</code> basada en la imagen que ya está en ejecución y se suma cualquier cambio que haya realizado. En nuestro caso, la adición del archivo <code>/SUCCESS</code> se incluye en la nueva imagen.</p>

<p>Aplique el cambio:</p>
<pre class="code-pre command second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker commit $(docker ps -lq) test-image
</li></ul></code></pre>
<p>En este punto, la imagen solo existe a nivel local. Ahora podrá introducirla en el nuevo registro que creó. Inicie sesión en su Docker Registry:</p>
<pre class="code-pre command second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker login https://<span class="highlight">example.com</span>
</li></ul></code></pre>
<p>Introduzca el <code><span class="highlight">username</span></code>  y la contraseña correspondiente antes utilizados. A continuación, etiquetará la imagen con la ubicación del registro privado para introducirla en él:</p>
<pre class="code-pre command second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker tag test-image <span class="highlight">example.com</span>/test-image
</li></ul></code></pre>
<p>Introduzca la imagen recién etiquetada en el registro:</p>
<pre class="code-pre command second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker push <span class="highlight">example.com</span>/test-image
</li></ul></code></pre>
<p>El resultado debe tener un aspecto similar al siguiente:</p>
<pre class="code-pre  second-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>The push refers to a repository [<span class="highlight">example.com</span>/test-image]
e3fbbfb44187: Pushed
5f70bf18a086: Pushed
a3b5c80a4eba: Pushed
7f18b442972b: Pushed
3ce512daaf78: Pushed
7aae4540b42d: Pushed
...

</code></pre>
<p>Con esto, habrá verificado que su registro gestione la autenticación de usuarios y permita que los usuarios autenticados introduzcan imágenes en el registro. A continuación, confirmará que también puede extraer imágenes del registro.</p>

<h2 id="paso-7-realizar-extracciones-desde-su-docker-registry-privado">Paso 7: Realizar extracciones desde su Docker Registry privado</h2>

<p>Vuelva al servidor de su registro para poder probar la extracción de la imagen desde su servidor de <strong>cliente</strong>. También es posible probar esto desde un tercer servidor.</p>

<p>Inicie sesión con el nombre de usuario y la contraseña que estableció previamente:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker login https://<span class="highlight">example.com</span>
</li></ul></code></pre>
<p>Con esto, estará listo para extraer la imagen. Utilice el nombre de su dominio e imagen, que etiquetó en el paso previo:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker pull <span class="highlight">example.com</span>/test-image
</li></ul></code></pre>
<p>Docker descargará la imagen y lo conducirá a la línea de comandos. Si ejecuta la imagen en el servidor de registro, verá que el archivo <code>SUCCESS</code> que creó antes estará allí:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker run -it <span class="highlight">example.com</span>/test-image /bin/bash
</li></ul></code></pre>
<p>Liste sus archivos dentro del shell de bash:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">ls
</li></ul></code></pre>
<p>Verá el archivo <code>SUCCESS</code> que creó para esta imagen:</p>
<pre class="code-pre "><code langs="">SUCCESS  bin  boot  dev  etc  home  lib  lib64  media   mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
</code></pre>
<p>Con esto, habrá terminado de configurar un registro seguro en el cual los usuarios puedan introducir imágenes personalizadas y desde el cual pueden extraerlas.</p>

<h2 id="conclusión">Conclusión</h2>

<p>A través de este tutorial, configuró su propio Docker Registry privado y publicó una imagen de Docker. Como se mencionó en la introducción, también puede usar <a href="https://docs.travis-ci.com/user/docker/">TravisCI</a> o una herramienta CI similar para automatizar la introducción directa en un registro privado. Al aprovechar Docker y los registros en su flujo de trabajo, puede garantizar que la imagen que contiene el código tendrá el mismo comportamiento en cualquier máquina, ya sea para la producción o el desarrollo. Para obtener más información sobre la escritura de archivos de Docker, puede leer este <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">tutorial de Docker</a> en el que se explica el proceso.</p>
