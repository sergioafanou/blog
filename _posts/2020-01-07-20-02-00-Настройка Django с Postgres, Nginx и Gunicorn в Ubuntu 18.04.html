---
layout: post
title: Настройка Django с Postgres, Nginx и Gunicorn в Ubuntu 18.04
network: digitalocean
date: January 07, 2020 at 08:02PM
url: https://www.digitalocean.com/community/tutorials/how-to-set-up-django-with-postgres-nginx-and-gunicorn-on-ubuntu-18-04-ru
image: https://assets.digitalocean.com/articles/django_gunicorn_nginx_1804/django_index.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="Введение">Введение</h3>

<p>Django — это мощная веб-система, помогающая создать приложение или сайт Python с нуля. Django включает упрощенный сервер разработки для локального тестирования кода, однако для серьезных производственных задач требуется более защищенный и мощный веб-сервер.</p>

<p>В этом руководстве мы покажем, как установить и настроить определенные компоненты Ubuntu 18.04 для поддержки и обслуживания приложений Django. Вначале мы создадим базу данных PostgreSQL вместо того, чтобы использовать базу данных по умолчанию SQLite. Мы настроим сервер приложений Gunicorn для взаимодействия с нашими приложениями. Затем мы настроим Nginx для работы в качестве обратного прокси-сервера Gunicorn, что даст нам доступ к функциям безопасности и повышения производительности для обслуживания наших приложений.</p>

<h2 id="Предварительные-требования-и-цели">Предварительные требования и цели</h2>

<p>Для прохождения этого обучающего модуля вам потребуется новый экземпляр сервера Ubuntu 18.04 с базовым брандмауэром и пользователем с привилегиями <code>sudo</code> и без привилегий root. Чтобы узнать, как настроить такой сервер, воспользуйтесь нашим модулем <a href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04">Руководство по начальной настройке сервера</a>.</p>

<p>Мы будем устанавливать Django в виртуальной среде. Установка Django в отдельную среду проекта позволит отдельно обрабатывать проекты и их требования.</p>

<p>Когда база данных будет работать, мы выполним установку и настройку сервера приложений Gunicorn. Он послужит интерфейсом нашего приложения и будет обеспечивать преобразование запросов клиентов по протоколу HTTP в вызовы Python, которые наше приложение сможет обрабатывать. Затем мы настроим Nginx в качестве обратного прокси-сервера для Gunicorn, чтобы воспользоваться высокоэффективными механизмами обработки соединений и удобными функциями безопасности.</p>

<p>Давайте приступим.</p>

<h2 id="Установка-пакетов-из-хранилищ-ubuntu">Установка пакетов из хранилищ Ubuntu</h2>

<p>Чтобы начать данную процедуру нужно загрузить и установить все необходимые нам элементы из хранилищ Ubuntu. Для установки дополнительных компонентов мы немного позднее используем диспетчер пакетов Python <code>pip</code>.</p>

<p>Нам нужно обновить локальный индекс пакетов <code>apt</code>, а затем загрузить и установить пакеты. Конкретный состав устанавливаемых пакетов зависит от того, какая версия Python будет использоваться в вашем проекте.</p>

<p>Если вы используете Django с <strong>Python 3</strong>, введите:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt update
</li><li class="line" prefix="$">sudo apt install python3-pip python3-dev libpq-dev postgresql postgresql-contrib nginx curl
</li></ul></code></pre>
<p>Версия Django 1.11 — последняя версия Django с поддержкой Python 2. Если вы создаете новый проект, мы настоятельно рекомендуем использовать Python 3. Если вам необходимо использовать <strong>Python 2</strong>, введите:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt update
</li><li class="line" prefix="$">sudo apt install python-pip python-dev libpq-dev postgresql postgresql-contrib nginx curl
</li></ul></code></pre>
<p>Эта команда устанавливает <code>pip</code>, файлы разработки Python для последующего построения сервера Gunicorn, СУБД Postgres и необходимые для взаимодействия с ней библиотеки, а также веб-сервер Nginx.</p>

<h2 id="Создание-базы-данных-и-пользователя-postgresql">Создание базы данных и пользователя PostgreSQL</h2>

<p>Вначале мы создадим базу данных и пользователя базы данных для нашего приложения Django.</p>

<p>По умолчанию Postgres использует для локальных соединений схему аутентификации «peer authentication». Это означает, что если имя пользователя операционной системы совпадает с действительным именем пользователя Postgres, этот пользователь может войти без дополнительной аутентификации.</p>

<p>Во время установки Postgres был создан пользователь операционной системы с именем <code>postgres</code>, соответствующий пользователю <code>postgres</code> базы данных PostgreSQL, имеющему права администратора. Этот пользователь нам потребуется для выполнения административных задач. Мы можем использовать sudo и передать это имя пользователя с опцией <code>-u</code>.</p>

<p>Выполните вход в интерактивный сеанс Postgres, введя следующую команду:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo -u postgres psql
</li></ul></code></pre>
<p>Вы увидите диалог PostgreSQL, где можно будет задать наши требования.</p>

<p>Вначале создайте базу данных для своего проекта:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="postgres=#">CREATE DATABASE <span class="highlight">myproject</span>;
</li></ul></code></pre>
<p><span class='note'><strong>Примечание.</strong> Каждое выражение Postgres должно заканчиваться точкой с запятой. Если с вашей командой возникнут проблемы, проверьте это.<br></span></p>

<p>Затем создайте пользователя базы данных для нашего проекта. Обязательно выберите безопасный пароль:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="postgres=#">CREATE USER <span class="highlight">myprojectuser</span> WITH PASSWORD '<span class="highlight">password</span>';
</li></ul></code></pre>
<p>Затем мы изменим несколько параметров подключения для только что созданного нами пользователя. Это ускорит работу базы данных, поскольку теперь при каждом подключении не нужно будет запрашивать и устанавливать корректные значения.</p>

<p>Мы зададим кодировку по умолчанию <code>UTF-8</code>, чего и ожидает Django. Также мы зададим схему изоляции транзакций по умолчанию «read committed», которая будет блокировать чтение со стороны неподтвержденных транзакций. В заключение мы зададим часовой пояс. По умолчанию наши проекты Django настроены на использование времени по Гринвичу (<code>UTC</code>). Все эти рекомендации взяты из <a href="https://docs.djangoproject.com/en/2.0/ref/databases/#optimizing-postgresql-s-configuration">проекта Django</a>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="postgres=#">ALTER ROLE <span class="highlight">myprojectuser</span> SET client_encoding TO 'utf8';
</li><li class="line" prefix="postgres=#">ALTER ROLE <span class="highlight">myprojectuser</span> SET default_transaction_isolation TO 'read committed';
</li><li class="line" prefix="postgres=#">ALTER ROLE <span class="highlight">myprojectuser</span> SET timezone TO 'UTC';
</li></ul></code></pre>
<p>Теперь мы предоставим созданному пользователю доступ для администрирования новой базы данных:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="postgres=#">GRANT ALL PRIVILEGES ON DATABASE <span class="highlight">myproject</span> TO <span class="highlight">myprojectuser</span>;
</li></ul></code></pre>
<p>Завершив настройку, закройте диалог PostgreSQL с помощью следующей команды:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="postgres=#">\q
</li></ul></code></pre>
<p>Теперь настройка Postgres завершена, и Django может подключаться к базе данных и управлять своей информацией в базе данных.</p>

<h2 id="Создание-виртуальной-среды-python-для-вашего-проекта">Создание виртуальной среды Python для вашего проекта</h2>

<p>Мы создали базу данных, и теперь можем перейти к остальным требованиям нашего проекта. Для удобства управления мы установим наши требования Python в виртуальной среде.</p>

<p>Для этого нам потребуется доступ к команде <code>virtualenv</code>. Для установки мы можем использовать <code>pip</code>.</p>

<p>Если вы используете <strong>Python 3</strong>, обновите <code>pip</code> и установите пакет с помощью следующей команды:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo -H pip3 install --upgrade pip
</li><li class="line" prefix="$">sudo -H pip3 install virtualenv
</li></ul></code></pre>
<p>Если вы используете <strong>Python 2</strong>, обновите <code>pip</code> и установите пакет с помощью следующей команды:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo -H pip install --upgrade pip
</li><li class="line" prefix="$">sudo -H pip install virtualenv
</li></ul></code></pre>
<p>После установки <code>virtualenv</code> мы можем начать формирование нашего проекта. Создайте каталог для файлов нашего проекта и перейдите в этот каталог:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir ~/<span class="highlight">myprojectdir</span>
</li><li class="line" prefix="$">cd ~/<span class="highlight">myprojectdir</span>
</li></ul></code></pre>
<p>Создайте в каталоге проекта виртуальную среду Python с помощью следующей команды:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">virtualenv <span class="highlight">myprojectenv</span>
</li></ul></code></pre>
<p>Эта команда создаст каталог <code><span class="highlight">myprojectenv</span></code> в каталоге <code><span class="highlight">myprojectdir</span></code>. В этот каталог будут установлены локальная версия Python и локальная версия <code>pip</code>. Мы можем использовать эту команду для установки и настройки изолированной среды Python для нашего проекта.</p>

<p>Прежде чем установить требования Python для нашего проекта, необходимо активировать виртуальную среду. Для этого можно использовать следующую команду:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">source <span class="highlight">myprojectenv</span>/bin/activate
</li></ul></code></pre>
<p>Командная строка изменится, показывая, что теперь вы работаете в виртуальной среде Python. Она будет выглядеть примерно следующим образом: <code>(<span class="highlight">myprojectenv</span>)<span class="highlight">user</span>@<span class="highlight">host</span>:~/<span class="highlight">myprojectdir</span>$</code>.</p>

<p>После запуска виртуальной среды установите Django, Gunicorn и адаптер <code>psycopg2</code> PostgreSQL с помощью локального экземпляра <code>pip</code>:</p>

<p><span class='note'><strong>Примечание.</strong> Если виртуальная среда активна (когда перед командной строкой стоит <code>(myprojectenv)</code>), необходимо использовать <code>pip</code> вместо <code>pip3</code>, даже если вы используете Python 3. Копия инструмента в виртуальной среде всегда имеет имя <code>pip</code> вне зависимости от версии Python.<br></span></p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(myprojectenv) $">pip install django gunicorn psycopg2-binary
</li></ul></code></pre>
<p>Теперь у вас должно быть установлено все программное обеспечение, необходимое для запуска проекта Django.</p>

<h2 id="Создание-и-настройка-нового-проекта-django">Создание и настройка нового проекта Django</h2>

<p>Установив компоненты Python, мы можем создать реальные файлы проекта Django.</p>

<h3 id="Создание-проекта-django">Создание проекта Django</h3>

<p>Поскольку у нас уже есть каталог проекта, мы укажем Django установить файлы в него. В этом каталоге будет создан каталог второго уровня с фактическим кодом (это нормально) и размещен скрипт управления. Здесь мы явно определяем каталог, а не даем Django принимать решения относительно текущего каталога:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(myprojectenv) $">django-admin.py startproject <span class="highlight">myproject</span> ~/<span class="highlight">myprojectdir</span>
</li></ul></code></pre>
<p>Сейчас каталог вашего проекта (в нашем случае <code>~/<span class="highlight">myprojectdir</span></code>) должен содержать следующее:</p>

<ul>
<li><code>~/myprojectdir/manage.py</code>: скрипт управления проектами Django.</li>
<li><code>~/myprojectdir/myproject/</code>: пакет проекта Django. В нем должны содержаться файлы <code>__init__.py</code>, <code>settings.py</code>, <code>urls.py</code> и <code>wsgi.py</code>.</li>
<li><code>~/myprojectdir/myprojectenv/</code>: виртуальный каталог, которы мы создали до этого.</li>
</ul>

<h3 id="Изменение-настроек-проекта">Изменение настроек проекта</h3>

<p>Прежде всего, необходимо изменить настройки созданных файлов проекта. Откройте файл настроек в текстовом редакторе:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(myprojectenv) $">nano ~/<span class="highlight">myprojectdir</span>/<span class="highlight">myproject</span>/settings.py
</li></ul></code></pre>
<p>Найдите директиву <code>ALLOWED_HOSTS</code>. Она определяет список адресов сервера или доменных имен, которые можно использовать для подключения к экземпляру Django. Любой входящий запрос с заголовком <strong>Host</strong>, не включенный в этот список, будет вызывать исключение. Django требует, чтобы вы использовали эту настройку, чтобы предотвратить использование определенного класса уязвимости безопасности.</p>

<p>В квадратных скобках перечислите IP-адреса или доменные имена, связанные с вашим сервером Django. Каждый элемент должен быть указан в кавычках, отдельные записи должны быть разделены запятой. Если вы хотите включить в запрос весь домен и любые субдомены, добавьте точку перед началом записи. В следующем фрагменте кода для демонстрации в строках комментариев приведено несколько примеров:</p>

<p><span class='note'><strong>Примечание.</strong> Обязательно используйте <code>localhost</code> как одну из опций, поскольку мы будем использовать локальный экземпляр Nginx как прокси-сервер.<br></span></p>
<div class="code-label " title="~/myprojectdir/myproject/settings.py">~/myprojectdir/myproject/settings.py</div><pre class="code-pre "><code langs="">. . .
# The simplest case: just add the domain name(s) and IP addresses of your Django server
# ALLOWED_HOSTS = [ 'example.com', '203.0.113.5']
# To respond to 'example.com' and any subdomains, start the domain with a dot
# ALLOWED_HOSTS = ['.example.com', '203.0.113.5']
ALLOWED_HOSTS = ['<span class="highlight">your_server_domain_or_IP</span>', '<span class="highlight">second_domain_or_IP</span>', <span class="highlight">. . .</span>, 'localhost']
</code></pre>
<p>Затем найдите раздел. который будет настраивать доступ к базе данных. Он будет начинаться со слова <code>DATABASES</code>. Конфигурация в файле предназначена для базы данных SQLite. Мы уже создали базу данных PostgreSQL для нашего проекта, и поэтому нужно изменить настройки.</p>

<p>Измените настройки, указав параметры базы данных PostgreSQL. Мы укажем Django использовать адаптер <code>psycopg2,</code> который мы установили вместе с <code>pip</code>. Нам нужно указать имя базы данных, имя пользователя базы данных, пароль пользователя базы данных, и указать, что база данных расположена на локальном компьютере. Вы можете оставить для параметра <code>PORT</code> пустую строку:</p>
<div class="code-label " title="~/myprojectdir/myproject/settings.py">~/myprojectdir/myproject/settings.py</div><pre class="code-pre "><code langs="">. . .

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.<span class="highlight">postgresql_psycopg2</span>',
        'NAME': '<span class="highlight">myproject</span>',
        'USER': '<span class="highlight">myprojectuser</span>',
        'PASSWORD': '<span class="highlight">password</span>',
        'HOST': 'localhost',
        'PORT': '',
    }
}

. . .
</code></pre>
<p>Затем перейдите в конец файла и добавьте параметр, указывающий, где следует разместить статичные файлы. Это необходимо, чтобы Nginx мог обрабатывать запросы для этих элементов. Следующая строка указывает Django, что они помещаются в каталог <code>static</code> в базовом каталоге проекта:</p>
<div class="code-label " title="~/myprojectdir/myproject/settings.py">~/myprojectdir/myproject/settings.py</div><pre class="code-pre "><code langs="">. . .

STATIC_URL = '/static/'
<span class="highlight">STATIC_ROOT = os.path.join(BASE_DIR, 'static/')</span>
</code></pre>
<p>Сохраните файл и закройте его после завершения.</p>

<h3 id="Завершение-начальной-настройки-проекта">Завершение начальной настройки проекта</h3>

<p>Теперь мы можем перенести начальную схему базы данных для нашей базы данных PostgreSQL, используя скрипт управления:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(myprojectenv) $">~/<span class="highlight">myprojectdir</span>/manage.py makemigrations
</li><li class="line" prefix="(myprojectenv) $">~/<span class="highlight">myprojectdir</span>/manage.py migrate
</li></ul></code></pre>
<p>Создайте административного пользователя проекта с помощью следующей команды:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(myprojectenv) $">~/<span class="highlight">myprojectdir</span>/manage.py createsuperuser
</li></ul></code></pre>
<p>Вам нужно будет выбрать имя пользователя, указать адрес электронной почты, а затем задать и подтвердить пароль.</p>

<p>Мы можем собрать весь статичный контент в заданном каталоге с помощью следующей команды:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(myprojectenv) $">~/<span class="highlight">myprojectdir</span>/manage.py collectstatic
</li></ul></code></pre>
<p>Данную операцию нужно будет подтвердить. Статичные файлы будут помещены в каталог <code>static</code> в каталоге вашего проекта.</p>

<p>Если вы следовали указаниям модуля по начальной настройке сервера, ваш сервер должен защищать брандмауэр UFW. Чтобы протестировать сервер разработки, необходимо разрешить доступ к порту, который мы будем использовать.</p>

<p>Создайте исключение для порта 8000 с помощью следующей команды:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(myprojectenv) $">sudo ufw allow 8000
</li></ul></code></pre>
<p>Теперь вы можете протестировать ваш проект, запустив сервер разработки Django с помощью следующей команды:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(myprojectenv) $">~/<span class="highlight">myprojectdir</span>/manage.py runserver 0.0.0.0:8000
</li></ul></code></pre>
<p>Откройте в браузере доменное имя или IP-адрес вашего сервера с суффиксом <code>:8000</code>:</p>
<pre class="code-pre "><code langs="">http://<span class="highlight">server_domain_or_IP</span>:8000
</code></pre>
<p>Вы увидите страницу индекса Django по умолчанию:</p>

<p><img src="https://assets.digitalocean.com/articles/django_gunicorn_nginx_1804/django_index.png" alt="Страница индекса Django"></p>

<p>Если вы добавите <code>/admin</code> в конце URL в панели адреса, вам будет предложено ввести имя пользователя и пароль администратора, созданные с помощью команды <code>createsuperuser</code>:</p>

<p><img src="https://assets.digitalocean.com/articles/django_gunicorn_nginx_1804/admin_login.png" alt="Вход в панель администратора Django"></p>

<p>После аутентификации вы получите доступ к интерфейсу администрирования Django по умолчанию:</p>

<p><img src="https://assets.digitalocean.com/articles/django_gunicorn_nginx_1804/admin_interface.png" alt="Интерфейс администрирования Django"></p>

<p>Завершив изучение, нажмите <strong>CTRL+C</strong> в окне терминала, чтобы завершить работу сервера разработки.</p>

<h3 id="Тестирование-способности-gunicorn-обслуживать-проект">Тестирование способности Gunicorn обслуживать проект</h3>

<p>Перед выходом из виртуальной среды нужно протестировать способность Gunicorn обслуживать приложение. Для этого нам нужно войти в каталог нашего проекта и использовать <code>gunicorn</code> для загрузки модуля WSGI проекта:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(myprojectenv) $">cd ~/<span class="highlight">myprojectdir</span>
</li><li class="line" prefix="(myprojectenv) $">gunicorn --bind 0.0.0.0:8000 <span class="highlight">myproject</span>.wsgi
</li></ul></code></pre>
<p>Gunicorn будет запущен на том же интерфейсе, на котором работал сервер разработки Django. Теперь вы можете вернуться и снова протестировать приложение.</p>

<p><span class='note'><strong>Примечание.</strong> В интерфейсе администратора не будут применяться в стили, поскольку Gunicorn неизвестно, как находить требуемый статичный контент CSS.<br></span></p>

<p>Мы передали модуль в Gunicorn, указав относительный путь к файлу Django <code>wsgi.py</code>, который представляет собой точку входа в наше приложение. Для этого мы использовали синтаксис модуля Python. В этом файле определена функция <code>application</code>, которая используется для взаимодействия с приложением. Дополнительную информацию о спецификации WSGI можно найти <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-uwsgi-and-nginx-to-serve-python-apps-on-ubuntu-14-04#definitions-and-concepts">здесь</a>.</p>

<p>После завершения тестирования нажмите <strong>CTRL+C</strong> в окне терминала, чтобы остановить работу Gunicorn.</p>

<p>Мы завершили настройку нашего приложения Django. Теперь мы можем выйти из виртуальной среды с помощью следующей команды:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(myprojectenv) $">deactivate
</li></ul></code></pre>
<p>Индикатор виртуальной среды будет убран из командной строки.</p>

<h2 id="Создание-файлов-сокета-и-служебных-файлов-systemd-для-gunicorn">Создание файлов сокета и служебных файлов systemd для Gunicorn</h2>

<p>Мы убедились, что Gunicorn может взаимодействовать с нашим приложением Django, но теперь нам нужно реализовать более надежный способ запуска и остановки сервера приложений. Для этого мы создадим служебные файлы и файлы сокета systemd.</p>

<p>Сокет Gunicorn создается при загрузке и прослушивает подключения. При подключении systemd автоматически запускает процесс Gunicorn для обработки подключения.</p>

<p>Создайте и откройте файл сокета systemd для Gunicorn с привилегиями <code>sudo</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nano /etc/systemd/system/gunicorn.socket
</li></ul></code></pre>
<p>В этом файле мы создадим раздел  <code>[Unit]</code> для описания сокета, раздел <code>[Socket]</code> для определения расположения сокета и раздел <code>[Install]</code>, чтобы обеспечить установку сокета в нужное время:</p>
<div class="code-label " title="/etc/systemd/system/gunicorn.socket">/etc/systemd/system/gunicorn.socket</div><pre class="code-pre "><code langs="">[Unit]
Description=gunicorn socket

[Socket]
ListenStream=/run/gunicorn.sock

[Install]
WantedBy=sockets.target
</code></pre>
<p>Сохраните файл и закройте его после завершения.</p>

<p>Теперь создайте и откройте служебный файл systemd для Gunicorn в текстовом редакторе с привилегиями <code>sudo</code>. Имя файла службы должно соответствовать имени файла сокета за исключением расширения:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nano /etc/systemd/system/gunicorn.service
</li></ul></code></pre>
<p>Начните с раздела <code>[Unit]</code>, предназначенного для указания метаданных и зависимостей. Здесь мы разместим описание службы и предпишем системе инициализации запускать ее только после достижения сетевой цели: Поскольку наша служба использует сокет из файла сокета, нам потребуется директива <code>Requires</code>, чтобы задать это отношение:</p>
<div class="code-label " title="/etc/systemd/system/gunicorn.service">/etc/systemd/system/gunicorn.service</div><pre class="code-pre "><code langs="">[Unit]
Description=gunicorn daemon
Requires=gunicorn.socket
After=network.target
</code></pre>
<p>Теперь откроем раздел <code>[Service]</code>. Здесь указываются пользователь и группа, от имени которых мы хотим запустить данный процесс. Мы сделаем владельцем процесса учетную запись обычного пользователя, поскольку этот пользователь является владельцем всех соответствующих файлов. Групповым владельцем мы сделаем группу <code>www-data</code>, чтобы Nginx мог легко взаимодействовать с Gunicorn.</p>

<p>Затем мы составим карту рабочего каталога и зададим команду для запуска службы. В данном случае мы укажем полный путь к исполняемому файлу Gunicorn, установленному в нашей виртуальной среде. Мы привяжем процесс к сокету Unix, созданному в каталоге  <code>/run</code>, чтобы процесс мог  взаимодействовать с Nginx. Мы будем регистрировать все данные на стандартном выводе, чтобы процесс <code>journald</code> мог собирать журналы Gunicorn. Также здесь можно указать любые необязательные настройки Gunicorn. Например, в данном случае мы задали 3 рабочих процесса:</p>
<div class="code-label " title="/etc/systemd/system/gunicorn.service">/etc/systemd/system/gunicorn.service</div><pre class="code-pre "><code langs="">[Unit]
Description=gunicorn daemon
Requires=gunicorn.socket
After=network.target

[Service]
User=<span class="highlight">sammy</span>
Group=www-data
WorkingDirectory=/home/<span class="highlight">sammy</span>/<span class="highlight">myprojectdir</span>
ExecStart=/home/<span class="highlight">sammy</span>/<span class="highlight">myprojectdir</span>/<span class="highlight">myprojectenv</span>/bin/gunicorn \
          --access-logfile - \
          --workers 3 \
          --bind unix:/run/gunicorn.sock \
          <span class="highlight">myproject</span>.wsgi:application
</code></pre>
<p>Наконец, добавим раздел <code>[Install]</code>. Это покажет systemd, куда привязывать эту службу, если мы активируем ее запуск при загрузке. Нам нужно, чтобы эта служба запускалась во время работы обычной многопользовательской системы:</p>
<div class="code-label " title="/etc/systemd/system/gunicorn.service">/etc/systemd/system/gunicorn.service</div><pre class="code-pre "><code langs="">[Unit]
Description=gunicorn daemon
Requires=gunicorn.socket
After=network.target

[Service]
User=<span class="highlight">sammy</span>
Group=www-data
WorkingDirectory=/home/<span class="highlight">sammy</span>/<span class="highlight">myprojectdir</span>
ExecStart=/home/<span class="highlight">sammy</span>/<span class="highlight">myprojectdir</span>/<span class="highlight">myprojectenv</span>/bin/gunicorn \
          --access-logfile - \
          --workers 3 \
          --bind unix:/run/gunicorn.sock \
          <span class="highlight">myproject</span>.wsgi:application

[Install]
WantedBy=multi-user.target
</code></pre>
<p>Теперь служебный файл systemd готов. Сохраните и закройте его.</p>

<p>Теперь мы можем запустить и активировать сокет Gunicorn. Файл сокета <code>/run/gunicorn.sock</code> будет создан сейчас и будет создаваться при загрузке. При подключении к этому сокету systemd автоматически запустит <code>gunicorn.service</code> для его обработки:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl start gunicorn.socket
</li><li class="line" prefix="$">sudo systemctl enable gunicorn.socket
</li></ul></code></pre>
<p>Успешность операции можно подтвердить, проверив файл сокета.</p>

<h2 id="Проверка-файла-сокета-gunicorn">Проверка файла сокета Gunicorn</h2>

<p>Проверьте состояние процесса, чтобы узнать, удалось ли его запустить:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl status gunicorn.socket
</li></ul></code></pre>
<p>Затем проверьте наличие файла <code>gunicorn.sock</code> в каталоге <code>/run</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">file /run/gunicorn.sock
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>/run/gunicorn.sock: socket
</code></pre>
<p>Если команда <code>systemctl status</code> указывает на ошибку, или если в каталоге отсутствует файл <code>gunicorn.sock</code>, это означает, что сокет Gunicorn не удалось создать. Проверьте журналы сокета Gunicorn с помощью следующей команды:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo journalctl -u gunicorn.socket
</li></ul></code></pre>
<p>Еще раз проверьте файл <code>/etc/systemd/system/gunicorn.socket</code> и устраните любые обнаруженные проблемы, прежде чем продолжить.</p>

<h2 id="Тестирование-активации-сокета">Тестирование активации сокета</h2>

<p>Если вы запустили только <code>gunicorn.socket</code>, служба <code>gunicorn.service</code> не будет активна в связи с отсутствием подключений к совету. Для проверки можно ввести следующую команду:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl status gunicorn
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>● gunicorn.service - gunicorn daemon
   Loaded: loaded (/etc/systemd/system/gunicorn.service; disabled; vendor preset: enabled)
   <span class="highlight">Active: inactive (dead)</span>
</code></pre>
<p>Чтобы протестировать механизм активации сокета, установим соединение с сокетом через <code>curl</code> с помощью следующей команды:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">curl --unix-socket /run/gunicorn.sock localhost
</li></ul></code></pre>
<p>Выводимые данные приложения должны отобразиться в терминале в формате HTML. Это показывает, что Gunicorn запущен и может обслуживать ваше приложение Django. Вы можете убедиться, что служба Gunicorn работает, с помощью следующей команды:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl status gunicorn
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>● gunicorn.service - gunicorn daemon
   Loaded: loaded (/etc/systemd/system/gunicorn.service; disabled; vendor preset: enabled)
   <span class="highlight">Active: active (running)</span> since Mon 2018-07-09 20:00:40 UTC; 4s ago
 Main PID: 1157 (gunicorn)
    Tasks: 4 (limit: 1153)
   CGroup: /system.slice/gunicorn.service
           ├─1157 /home/sammy/myprojectdir/myprojectenv/bin/python3 /home/sammy/myprojectdir/myprojectenv/bin/gunicorn --access-logfile - --workers 3 --bind unix:/run/gunicorn.sock myproject.wsgi:application
           ├─1178 /home/sammy/myprojectdir/myprojectenv/bin/python3 /home/sammy/myprojectdir/myprojectenv/bin/gunicorn --access-logfile - --workers 3 --bind unix:/run/gunicorn.sock myproject.wsgi:application
           ├─1180 /home/sammy/myprojectdir/myprojectenv/bin/python3 /home/sammy/myprojectdir/myprojectenv/bin/gunicorn --access-logfile - --workers 3 --bind unix:/run/gunicorn.sock myproject.wsgi:application
           └─1181 /home/sammy/myprojectdir/myprojectenv/bin/python3 /home/sammy/myprojectdir/myprojectenv/bin/gunicorn --access-logfile - --workers 3 --bind unix:/run/gunicorn.sock myproject.wsgi:application

Jul 09 20:00:40 django1 systemd[1]: Started gunicorn daemon.
Jul 09 20:00:40 django1 gunicorn[1157]: [2018-07-09 20:00:40 +0000] [1157] [INFO] Starting gunicorn 19.9.0
Jul 09 20:00:40 django1 gunicorn[1157]: [2018-07-09 20:00:40 +0000] [1157] [INFO] Listening at: unix:/run/gunicorn.sock (1157)
Jul 09 20:00:40 django1 gunicorn[1157]: [2018-07-09 20:00:40 +0000] [1157] [INFO] Using worker: sync
Jul 09 20:00:40 django1 gunicorn[1157]: [2018-07-09 20:00:40 +0000] [1178] [INFO] Booting worker with pid: 1178
Jul 09 20:00:40 django1 gunicorn[1157]: [2018-07-09 20:00:40 +0000] [1180] [INFO] Booting worker with pid: 1180
Jul 09 20:00:40 django1 gunicorn[1157]: [2018-07-09 20:00:40 +0000] [1181] [INFO] Booting worker with pid: 1181
Jul 09 20:00:41 django1 gunicorn[1157]:  - - [09/Jul/2018:20:00:41 +0000] "GET / HTTP/1.1" 200 16348 "-" "curl/7.58.0"
</code></pre>
<p>Если результат вывода <code>curl</code> или <code>systemctl status</code> указывают на наличие проблемы, поищите в журналах более подробные данные:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo journalctl -u gunicorn
</li></ul></code></pre>
<p>Проверьте файл <code>/etc/systemd/system/gunicorn.service</code> на наличие проблем. Если вы внесли изменения в файл <code>/etc/systemd/system/gunicorn.service</code>, перезагрузите демона, чтобы заново считать определение службы, и перезапустите процесс Gunicorn с помощью следующей команды:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl daemon-reload
</li><li class="line" prefix="$">sudo systemctl restart gunicorn
</li></ul></code></pre>
<p>Обязательно устраните вышеперечисленные проблемы, прежде чем продолжить.</p>

<h2 id="Настройка-nginx-как-прокси-для-gunicorn">Настройка Nginx как прокси для Gunicorn</h2>

<p>Мы настроили Gunicorn, и теперь нам нужно настроить Nginx для передачи трафика в процесс.</p>

<p>Для начала нужно создать и открыть новый серверный блок в каталоге Nginx <code>sites-available</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nano /etc/nginx/sites-available/<span class="highlight">myproject</span>
</li></ul></code></pre>
<p>Откройте внутри него новый серверный блок. Вначале мы укажем, что этот блок должен прослушивать обычный порт 80, и что он должен отвечать на доменное имя или IP-адрес нашего сервера:</p>
<div class="code-label " title="/etc/nginx/sites-available/myproject">/etc/nginx/sites-available/myproject</div><pre class="code-pre "><code langs="">server {
    listen 80;
    server_name <span class="highlight">server_domain_or_IP</span>;
}
</code></pre>
<p>Затем мы укажем Nginx игнорировать любые проблемы при поиске favicon. Также мы укажем, где можно найти статичные ресурсы, собранные нами в каталоге <code>~/<span class="highlight">myprojectdir</span>/static</code>. Все эти строки имеют стандартный префикс URI «/static», так что мы можем создать блок location для соответствия этим запросам:</p>
<div class="code-label " title="/etc/nginx/sites-available/myproject">/etc/nginx/sites-available/myproject</div><pre class="code-pre "><code langs="">server {
    listen 80;
    server_name <span class="highlight">server_domain_or_IP</span>;

    location = /favicon.ico { access_log off; log_not_found off; }
    location /static/ {
        root /home/<span class="highlight">sammy</span>/<span class="highlight">myprojectdir</span>;
    }
}
</code></pre>
<p>В заключение мы создадим блок <code>location / {}</code> для соответствия всем другим запросам. В этот блок мы включим стандартный файл <code>proxy_params</code>, входящий в комплект установки Nginx, и тогда трафик будет передаваться напрямую на сокет Gunicorn:</p>
<div class="code-label " title="/etc/nginx/sites-available/myproject">/etc/nginx/sites-available/myproject</div><pre class="code-pre "><code langs="">server {
    listen 80;
    server_name <span class="highlight">server_domain_or_IP</span>;

    location = /favicon.ico { access_log off; log_not_found off; }
    location /static/ {
        root /home/<span class="highlight">sammy</span>/<span class="highlight">myprojectdir</span>;
    }

    location / {
        include proxy_params;
        proxy_pass http://unix:/run/gunicorn.sock;
    }
}
</code></pre>
<p>Сохраните файл и закройте его после завершения. Теперь мы можем активировать файл, привязав его к каталогу <code>sites-enabled</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo ln -s /etc/nginx/sites-available/<span class="highlight">myproject</span> /etc/nginx/sites-enabled
</li></ul></code></pre>
<p>Протестируйте конфигурацию Nginx на ошибки синтаксиса:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nginx -t
</li></ul></code></pre>
<p>Если ошибок не будет найдено, перезапустите Nginx с помощью следующей команды:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl restart nginx
</li></ul></code></pre>
<p>Нам нужна возможность открыть брандмауэр для обычного трафика через порт 80. Поскольку нам больше не потребуется доступ к серверу разработки, мы можем удалить правило и открыть порт 8000:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo ufw delete allow 8000
</li><li class="line" prefix="$">sudo ufw allow 'Nginx Full'
</li></ul></code></pre>
<p>Теперь у вас должна быть возможность перейти к домену или IP-адресу вашего сервера для просмотра вашего приложения.</p>

<span class='note'><p>
<strong>Примечание.</strong> После настройки Nginx необходимо защитить трафик на сервер с помощью SSL/TLS. Это важно, поскольку в противном случае вся информация, включая пароли, будет отправляться через сеть в простом текстовом формате.</p>

<p>Если у вас имеется доменное имя, проще всего будет использовать Let&rsquo;s Encrypt для получения сертификата SSL для защиты вашего трафика. Следуйте указаниям <a href="https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-18-04">этого руководства</a>, чтобы настроить Let&rsquo;s Encrypt с Nginx в Ubuntu 18.04. Следуйте процедуре, используя серверный блок Nginx, созданный нами в этом обучающем модуле.</p>

<p>Если у вас нет доменного имени, вы можете защитить свой сайт для тестирования и обучения с помощью <a href="https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-nginx-in-ubuntu-18-04">сертификата SSL с собственной подписью</a>. Следуйте процедуре, используя серверный блок Nginx, созданный нами в этом обучающем модуле.<br></p></span>

<h2 id="Диагностика-и-устранение-неисправностей-nginx-и-gunicorn">Диагностика и устранение неисправностей Nginx и Gunicorn</h2>

<p>Если на последнем шаге не будет показано ваше приложение, вам нужно будет провести диагностику и устранение неисправностей установки.</p>

<h3 id="nginx-показывает-страницу-по-умолчанию-а-не-приложение-django">Nginx показывает страницу по умолчанию, а не приложение Django</h3>

<p>Если Nginx показывает страницу по умолчанию, а не выводит ваше приложение через прокси, это обычно означает, что вам нужно изменить параметр <code>server_name</code> в файле <code>/etc/nginx/sites-available/<span class="highlight">myproject</span></code>, чтобы он указывал на IP-адрес или доменное имя вашего сервера.</p>

<p>Nginx использует <code>server_name</code>, чтобы определять, какой серверный блок использовать для ответа на запросы. Если вы увидите страницу Nginx по умолчанию, это будет означать, что Nginx не может найти явное соответствие запросу в серверном блоке и выводит блок по умолчанию, заданный в <code>/etc/nginx/sites-available/default</code>.</p>

<p>Параметр <code>server_name</code> в серверном блоке вашего проекта должен быть более конкретным, чем содержащийся в серверном блоке, выбираемом по умолчанию.</p>

<h3 id="nginx-выводит-ошибку-502-bad-gateway-вместо-приложения-django">Nginx выводит ошибку 502 Bad Gateway вместо приложения Django</h3>

<p>Ошибка 502 означает, что Nginx не может выступать в качестве прокси для запроса. Ошибка 502 может сигнализировать о разнообразных проблемах конфигурации, поэтому для диагностики и устранения неисправности потребуется больше информации.</p>

<p>В первую очередь эту информацию следует искать в журналах ошибок Nginx. Обычно это указывает, какие условия вызвали проблемы во время прокси-обработки. Изучите журналы ошибок Nginx с помощью следующей команды:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo tail -F /var/log/nginx/error.log
</li></ul></code></pre>
<p>Теперь выполните в браузере еще один запрос, чтобы получить свежее сообщение об ошибке (попробуйте обновить страницу). В журнал будет записано свежее сообщение об ошибке. Если вы изучите его, это поможет идентифицировать проблему.</p>

<p>Возможно вы увидите сообщение следующего вида:</p>

<p><strong>connect() to unix:/run/gunicorn.sock failed (2: No such file or directory)</strong></p>

<p>Это означает, что Nginx не удалось найти файл <code>gunicorn.sock</code> в указанном месте. Вы должны сравнить расположение <code>proxy_pass</code>, определенное в файле <code>etc/nginx/sites-available/myproject</code>, с фактическим расположением файла <code>gunicorn.sock</code>, сгенерированным блоком systemd <code>gunicorn.socket</code>.</p>

<p>Если вы не можете найти файл <code>gunicorn.sock</code> в каталоге <code>/run</code>, это означает, что файл сокета systemd не смог его создать. Вернитесь к <a href="#checking-for-the-gunicorn-socket-file">разделу проверки файла сокета Gunicorn</a> и выполните процедуру диагностики и устранения неисправностей Gunicorn.</p>

<p><strong>connect() to unix:/run/gunicorn.sock failed (13: Permission denied)</strong></p>

<p>Это означает, что Nginx не удалось подключиться к сокету Gunicorn из-за проблем с правами доступа. Это может произойти, если процедуру выполнять с привилегиями root, а не с привилегиями <code>sudo</code>. Хотя systemd может создать файл сокета Gunicorn, Nginx не может получить к нему доступ.</p>

<p>Это может произойти из-за ограничения прав доступа в любом месте между корневым каталогом  (<code>/</code>) и файлом <code>gunicorn.sock</code>. Чтобы увидеть права доступа и владельцев файла сокета и всех его родительских каталогов, нужно ввести абсолютный путь файла сокета как параметр команды <code>namei</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">namei -l /run/gunicorn.sock
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>f: /run/gunicorn.sock
drwxr-xr-x root root /
drwxr-xr-x root root run
srw-rw-rw- root root gunicorn.sock
</code></pre>
<p>Команда выведет права доступа всех компонентов каталога. Изучив права доступа (первый столбец), владельца (второй столбец) и группового владельца (третий столбец), мы можем определить, какой тип доступа разрешен для файла сокета.</p>

<p>В приведенном выше примере для файла сокета и каждого из каталогов пути к файлу сокета установлены всеобщие права доступа на чтение и исполнение (запись в столбце разрешений каталогов заканчивается на <code>r-x</code>, а не на <code>---</code>). Процесс Nginx должен успешно получить доступ к сокету.</p>

<p>Если для любого из каталогов, ведущих к сокету, отсутствуют глобальные разрешения на чтение и исполнение, Nginx не сможет получить доступ к сокету без включения таких разрешений или без передачи группового владения группе, в которую входит Nginx.</p>

<h3 id="django-выводит-ошибку-«could-not-connect-to-server-connection-refused»">Django выводит ошибку: «could not connect to server: Connection refused»</h3>

<p>При попытке доступа к частям приложения через браузер Django может вывести сообщение следующего вида:</p>
<pre class="code-pre "><code langs="">OperationalError at /admin/login/
could not connect to server: Connection refused
    Is the server running on host "localhost" (127.0.0.1) and accepting
    TCP/IP connections on port 5432?
</code></pre>
<p>Это означает, что Django не может подключиться к базе данных Postgres. Убедиться в нормальной работе экземпляра Postgres с помощью следующей команды:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl status postgresql
</li></ul></code></pre>
<p>Если он работает некорректно, вы можете запустить его и включить автоматический запуск при загрузке (если эта настройка еще не задана) с помощью следующей команды:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl start postgresql
</li><li class="line" prefix="$">sudo systemctl enable postgresql
</li></ul></code></pre>
<p>Если проблемы не исчезнут, проверьте правильность настроек базы данных, заданных в файле <code>~/myprojectdir/myproject/settings.py</code>.</p>

<h3 id="Дополнительная-диагностика-и-устранение-неисправностей">Дополнительная диагностика и устранение неисправностей</h3>

<p>В случае обнаружения дополнительных проблем журналы могут помочь в поиске первопричин. Проверяйте их по очереди и ищите сообщения, указывающие на проблемные места.</p>

<p>Следующие журналы могут быть полезными:</p>

<ul>
<li>Проверьте журналы процессов Nginx с помощью команды: <code>sudo journalctl -u nginx</code></li>
<li>Проверьте журналы доступа Nginx с помощью команды: <code>sudo less /var/log/nginx/access.log</code></li>
<li>Проверьте журналы ошибок Nginx с помощью команды: <code>sudo less /var/log/nginx/error.log</code></li>
<li>Проверьте журналы приложения Gunicorn с помощью команды: <code>sudo journalctl -u gunicorn</code></li>
<li>Проверьте журналы сокета Gunicorn с помощью команды: <code>sudo journalctl -u gunicorn.socket</code></li>
</ul>

<p>При обновлении конфигурации или приложения вам может понадобиться перезапустить процессы для адаптации к изменениям.</p>

<p>Если вы обновите свое приложение Django, вы можете перезапустить процесс Gunicorn для адаптации к изменениям с помощью следующей команды:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl restart gunicorn
</li></ul></code></pre>
<p>Если вы измените файл сокета или служебные файлы Gunicorn, перезагрузите демона и перезапустите процесс с помощью следующей команды:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl daemon-reload
</li><li class="line" prefix="$">sudo systemctl restart gunicorn.socket gunicorn.service
</li></ul></code></pre>
<p>Если вы измените конфигурацию серверного блока Nginx, протестируйте конфигурацию и Nginx с помощью следующей команды:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nginx -t &amp;&amp; sudo systemctl restart nginx
</li></ul></code></pre>
<p>Эти команды помогают адаптироваться к изменениям в случае изменения конфигурации.</p>

<h2 id="Заключение">Заключение</h2>

<p>В этом руководстве мы создали и настроили проект Django в его собственной виртуальной среде. Мы настроили Gunicorn для трансляции запросов клиентов, чтобы Django мог их обрабатывать. Затем мы настроили Nginx в качестве обратного прокси-сервера для обработки клиентских соединений и вывода проектов, соответствующих запросам клиентов.</p>

<p>Django упрощает создание проектов и приложений, предоставляя множество стандартных элементов и позволяя сосредоточиться на уникальных. Используя описанную в этой статье процедуру, вы сможете легко обслуживать создаваемые приложения на одном сервере.</p>
