---
layout: post
title: How To Analyze Managed PostgreSQL Database Statistics Using the Elastic Stack on Ubuntu 18.04
network: digitalocean
date: August 09, 2019 at 08:18PM
url: https://www.digitalocean.com/community/tutorials/how-to-analyze-managed-postgresql-database-statistics-using-the-elastic-stack-on-ubuntu-18-04
image: https://assets.digitalocean.com/articles/postgres_managed_elk/step4a.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<p><em>The author selected the <a href="https://www.brightfunds.org/funds/foss-nonprofits">Free and Open Source Fund</a> to receive a donation as part of the <a href="https://do.co/w4do-cta">Write for DOnations</a> program.</em></p>

<h3 id="introduction">Introduction</h3>

<p>Database monitoring is the continuous process of systematically tracking various metrics that show how the database is performing. By observing the performance data, you can gain valuable insights and identify possible bottlenecks, as well as find additional ways of improving database performance. Such systems often implement alerting, which notifies administrators when things go wrong. Gathered statistics can be used to not only improve the configuration and workflow of the database, but also those of client applications.</p>

<p>The benefit of using the <a href="https://www.elastic.co/products/elastic-stack">Elastic Stack</a> (ELK stack) for monitoring your managed database is its excellent support for searching and the ability to ingest new data very quickly. It does not excel at updating the data, but this trade off is acceptable for monitoring and logging purposes, where past data is almost never changed. <a href="https://www.elastic.co/products/elasticsearch">Elasticsearch</a> offers powerful means of querying the data, which you can use through <a href="https://www.elastic.co/products/kibana">Kibana</a> to get a better understanding of how the database fares through different time periods. This will allow you to correlate database load with real-life events to gain insight into how the database is being used.</p>

<p>In this tutorial, you'll import database metrics, generated by the <a href="https://www.postgresql.org/docs/9.6/monitoring-stats.html">PostgreSQL statistics collector</a>, into Elasticsearch via <a href="https://www.elastic.co/products/logstash">Logstash</a>. This entails configuring Logstash to pull data from the database using the <a href="https://jdbc.postgresql.org/">PostgreSQL JDBC connector</a> to send it to Elasticsearch for indexing immediately afterward. The imported data can later be analyzed and visualized in Kibana. Then, if your database is brand new, you'll use <a href="https://www.postgresql.org/docs/11/pgbench.html">pgbench</a>, a PostgreSQL benchmarking tool, to create more interesting visualizations. In the end, you'll have an automated system pulling in PostgreSQL statistics for later analysis.</p>

<h2 id="prerequisites">Prerequisites</h2>

<ul>
<li><p>An Ubuntu 18.04 server with at least 4 GB RAM, root privileges, and a secondary, non-root account. You can set this up by following <a href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04">this initial server setup guide</a>. For this tutorial the non-root user is <code><span class="highlight">sammy</span></code>.</p></li>
<li><p>Java 8 installed on your server. For installation instructions, visit <a href="https://www.digitalocean.com/community/tutorials/how-to-install-java-with-apt-on-ubuntu-18-04#installing-specific-versions-of-openjdk">How To Install Java with <code>apt</code> on Ubuntu 18.04</a>.</p></li>
<li><p>Nginx installed on your server. For a guide on how to do that, see <a href="https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-ubuntu-18-04">How To Install Nginx on Ubuntu 18.04</a>.</p></li>
<li><p>Elasticsearch and Kibana installed on your server. Complete the first two steps of the <a href="https://www.digitalocean.com/community/tutorials/how-to-install-elasticsearch-logstash-and-kibana-elastic-stack-on-ubuntu-18-04">How To Install Elasticsearch, Logstash, and Kibana (Elastic Stack) on Ubuntu 18.04</a> tutorial.</p></li>
<li><p>A PostgreSQL managed database provisioned from DigitalOcean with connection information available. Make sure that your server's IP address is on the whitelist. To learn more about DigitalOcean Managed Databases, visit the <a href="https://www.digitalocean.com/docs/databases/overview/">product docs</a>.</p></li>
</ul>

<h2 id="step-1-—-setting-up-logstash-and-the-postgresql-jdbc-driver">Step 1 — Setting up Logstash and the PostgreSQL JDBC Driver</h2>

<p>In this section, you will install Logstash and download the <a href="https://jdbc.postgresql.org/index.html">PostgreSQL JDBC driver</a> so that Logstash will be able to connect to your managed database.</p>

<p>Start off by installing Logstash with the following command:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt install logstash -y
</li></ul></code></pre>
<p>Once Logstash is installed, enable the service to automatically start on boot:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl enable logstash
</li></ul></code></pre>
<p>Logstash is written in Java, so in order to connect to PostgreSQL it requires the PostgreSQL JDBC (Java Database Connectivity) library to be available on the system it is running on. Because of an internal limitation, Logstash will properly load the library only if it is found under the <code>/usr/share/logstash/logstash-core/lib/jars</code> directory, where it stores third-party libraries it uses.</p>

<p>Head over to the <a href="https://jdbc.postgresql.org/download.html#current">download page</a> of the JDBC library and copy the link to latest version. Then, download it using <code>curl</code> by running the following command:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo curl https://jdbc.postgresql.org/download/postgresql-<span class="highlight">42.2.6</span>.jar -o /usr/share/logstash/logstash-core/lib/jars/postgresql-jdbc.jar
</li></ul></code></pre>
<p>At the time of writing, the latest version of the library was <code><span class="highlight">42.2.6</span></code>, with Java 8 as the supported runtime version. Ensure you download the latest version; pairing it with the correct Java version that both JDBC and Logstash support.</p>

<p>Logstash stores its configuration files under <code>/etc/logstash/conf.d</code>, and is itself stored under <code>/usr/share/logstash/bin</code>. Before you create a configuration that will pull statistics from your database, you'll need to enable the JDBC plugin in Logstash by running the following command:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo /usr/share/logstash/bin/logstash-plugin install logstash-input-jdbc
</li></ul></code></pre>
<p>You've installed Logstash using <code>apt</code> and downloaded the PostgreSQL JDBC library so that Logstash can use it to connect to your managed database. In the next step, you will configure Logstash to pull statistical data from it.</p>

<h2 id="step-2-—-configuring-logstash-to-pull-statistics">Step 2 — Configuring Logstash To Pull Statistics</h2>

<p>In this section, you will configure Logstash to pull metrics from your managed PostgreSQL database.</p>

<p>You'll configure Logstash to watch over three system databases in PostgreSQL, namely:</p>

<ul>
<li><code>pg_stat_database</code>: provides statistics about each database, including its name, number of connections, transactions, rollbacks, rows returned by querying the database, deadlocks, and so on. It has a <code>stats_reset</code> field, which specifies when the statistics were last reset.</li>
<li><code>pg_stat_user_tables</code>: provides statistics about each table created by the user, such as the number of inserted, deleted, and updated rows.</li>
<li><code>pg_stat_user_indexes</code>: collects data about all indexes in user-created tables, such as the number of times a particular index has been scanned.</li>
</ul>

<p>You'll store the configuration for indexing PostgreSQL statistics in Elasticsearch in a file named <code>postgresql.conf</code> under the <code>/etc/logstash/conf.d</code> directory, where Logstash stores configuration files. When started as a service, it will automatically run them in the background.</p>

<p>Create <code>postgresql.conf</code> using your favorite editor (for example, nano):</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nano /etc/logstash/conf.d/postgresql.conf
</li></ul></code></pre>
<p>Add the following lines:</p>
<div class="code-label " title="/etc/logstash/conf.d/postgresql.conf">/etc/logstash/conf.d/postgresql.conf</div><pre class="code-pre "><code langs="">input {
        # pg_stat_database
        jdbc {
                jdbc_driver_library =&gt; ""
                jdbc_driver_class =&gt; "org.postgresql.Driver"
                jdbc_connection_string =&gt; "jdbc:postgresql://<span class="highlight">host</span>:<span class="highlight">port</span>/defaultdb"
                jdbc_user =&gt; "<span class="highlight">username</span>"
                jdbc_password =&gt; "<span class="highlight">password</span>"
                statement =&gt; "SELECT * FROM pg_stat_database"
                schedule =&gt; "* * * * *"
                type =&gt; "pg_stat_database"
        }

        # pg_stat_user_tables
        jdbc {
                jdbc_driver_library =&gt; ""
                jdbc_driver_class =&gt; "org.postgresql.Driver"
                jdbc_connection_string =&gt; "jdbc:postgresql://<span class="highlight">host</span>:<span class="highlight">port</span>/defaultdb"
                jdbc_user =&gt; "<span class="highlight">username</span>"
                jdbc_password =&gt; "<span class="highlight">password</span>"
                statement =&gt; "SELECT * FROM pg_stat_user_tables"
                schedule =&gt; "* * * * *"
                type =&gt; "pg_stat_user_tables"
        }

        # pg_stat_user_indexes
        jdbc {
                jdbc_driver_library =&gt; ""
                jdbc_driver_class =&gt; "org.postgresql.Driver"
                jdbc_connection_string =&gt; "jdbc:postgresql://<span class="highlight">host</span>:<span class="highlight">port</span>/defaultdb"
                jdbc_user =&gt; "<span class="highlight">username</span>"
                jdbc_password =&gt; "<span class="highlight">password</span>"
                statement =&gt; "SELECT * FROM pg_stat_user_indexes"
                schedule =&gt; "* * * * *"
                type =&gt; "pg_stat_user_indexes"
        }
}

output {
        elasticsearch {
                hosts =&gt; "http://localhost:9200"
                index =&gt; "%{type}"
        }
}
</code></pre>
<p>Remember to replace <code><span class="highlight">host</span></code> with your host address, <code><span class="highlight">port</span></code> with the port to which you can connect to your database, <code><span class="highlight">username</span></code> with the database user username, and <code><span class="highlight">password</span></code> with its password. All these values can be found in the Control Panel of your managed database.</p>

<p>In this configuration, you define three JDBC inputs and one Elasticsearch output. The three inputs pull data from the <code>pg_stat_database</code>, <code>pg_stat_user_tables</code>, and <code>pg_stat_user_indexes</code> databases, respectively. They all set the <code>jdbc_driver_library</code> parameter to an empty string, because the PostgreSQL JDBC library is in a folder that Logstash automatically loads.</p>

<p>Then, they set the <code>jdbc_driver_class</code>, whose value is specific to the JDBC library, and provide a <code>jdbc_connection_string</code>, which details how to connect to the database. The <code>jdbc:</code> part signifies that it is a JDBC connection, while <code>postgres://</code> indicates that the target database is PostgreSQL. Next come the host and port of the database, and after the forward slash you also specify a database to connect to; this is because PostgreSQL requires you to be connected to a database to be able to issue any queries. Here, it is set to the default database that always exists and can not be deleted, aptly named <code>defaultdb</code>.</p>

<p>Next, they set a username and password of the user through which the database will be accessed. The <code>statement</code> parameter contains a SQL query that should return the data you wish to process—in this configuration, it selects all rows from the appropriate database.</p>

<p>The <code>schedule</code> parameter accepts a string in <a href="https://en.wikipedia.org/wiki/Cron">cron</a> syntax that defines when Logstash should run this input; omitting it completely will make Logstash run it only once. Specifying <code>* * * * *</code>, as you have done so here, will tell Logstash to run it every minute. You can specify your own cron string if you want to collect data at different intervals.</p>

<p>There is only one output, which accepts data from three inputs. They all send data to Elasticsearch, which is running locally and is reachable at <code>http://localhost:9200</code>. The <code>index</code> parameter defines to which Elasticsearch index it will send the data, and its value is passed in from the <code>type</code> field of the input.</p>

<p>When you are done with editing, save and close the file.</p>

<p>You've configured Logstash to gather data from various PostgreSQL statistical tables and send them to Elasticsearch for storage and indexing. Next, you'll run Logstash to test the configuration.</p>

<h2 id="step-3-—-testing-the-logstash-configuration">Step 3 — Testing the Logstash Configuration</h2>

<p>In this section, you will test the configuration by running Logstash to verify it will properly pull the data. Then, you will make this configuration run in the background by configuring it as a Logstash pipeline.</p>

<p>Logstash supports running a specific configuration by passing its file path to the <code>-f</code> parameter. Run the following command to test your new configuration from the last step:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo /usr/share/logstash/bin/logstash -f /etc/logstash/conf.d/postgresql.conf
</li></ul></code></pre>
<p>It may take some time before it shows any output, which will look similar to this:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Thread.exclusive is deprecated, use Thread::Mutex
WARNING: Could not find logstash.yml which is typically located in $LS_HOME/config or /etc/logstash. You can specify the path using --path.settings. Continuing using the defaults
Could not find log4j2 configuration at path /usr/share/logstash/config/log4j2.properties. Using default config which logs errors to the console
[WARN ] 2019-08-02 18:29:15.123 [LogStash::Runner] multilocal - Ignoring the 'pipelines.yml' file because modules or command line options are specified
[INFO ] 2019-08-02 18:29:15.154 [LogStash::Runner] runner - Starting Logstash {"logstash.version"=&gt;"7.3.0"}
[INFO ] 2019-08-02 18:29:18.209 [Converge PipelineAction::Create&lt;main&gt;] Reflections - Reflections took 77 ms to scan 1 urls, producing 19 keys and 39 values
[INFO ] 2019-08-02 18:29:20.195 [[main]-pipeline-manager] elasticsearch - Elasticsearch pool URLs updated {:changes=&gt;{:removed=&gt;[], :added=&gt;[http://localhost:9200/]}}
[WARN ] 2019-08-02 18:29:20.667 [[main]-pipeline-manager] elasticsearch - Restored connection to ES instance {:url=&gt;"http://localhost:9200/"}
[INFO ] 2019-08-02 18:29:21.221 [[main]-pipeline-manager] elasticsearch - ES Output version determined {:es_version=&gt;7}
[WARN ] 2019-08-02 18:29:21.230 [[main]-pipeline-manager] elasticsearch - Detected a 6.x and above cluster: the `type` event field won't be used to determine the document _type {:es_version=&gt;7}
[INFO ] 2019-08-02 18:29:21.274 [[main]-pipeline-manager] elasticsearch - New Elasticsearch output {:class=&gt;"LogStash::Outputs::ElasticSearch", :hosts=&gt;["http://localhost:9200"]}
[INFO ] 2019-08-02 18:29:21.337 [[main]-pipeline-manager] elasticsearch - Elasticsearch pool URLs updated {:changes=&gt;{:removed=&gt;[], :added=&gt;[http://localhost:9200/]}}
[WARN ] 2019-08-02 18:29:21.369 [[main]-pipeline-manager] elasticsearch - Restored connection to ES instance {:url=&gt;"http://localhost:9200/"}
[INFO ] 2019-08-02 18:29:21.386 [[main]-pipeline-manager] elasticsearch - ES Output version determined {:es_version=&gt;7}
[WARN ] 2019-08-02 18:29:21.386 [[main]-pipeline-manager] elasticsearch - Detected a 6.x and above cluster: the `type` event field won't be used to determine the document _type {:es_version=&gt;7}
[INFO ] 2019-08-02 18:29:21.409 [[main]-pipeline-manager] elasticsearch - New Elasticsearch output {:class=&gt;"LogStash::Outputs::ElasticSearch", :hosts=&gt;["http://localhost:9200"]}
[INFO ] 2019-08-02 18:29:21.430 [[main]-pipeline-manager] elasticsearch - Elasticsearch pool URLs updated {:changes=&gt;{:removed=&gt;[], :added=&gt;[http://localhost:9200/]}}
[WARN ] 2019-08-02 18:29:21.444 [[main]-pipeline-manager] elasticsearch - Restored connection to ES instance {:url=&gt;"http://localhost:9200/"}
[INFO ] 2019-08-02 18:29:21.465 [[main]-pipeline-manager] elasticsearch - ES Output version determined {:es_version=&gt;7}
[WARN ] 2019-08-02 18:29:21.466 [[main]-pipeline-manager] elasticsearch - Detected a 6.x and above cluster: the `type` event field won't be used to determine the document _type {:es_version=&gt;7}
[INFO ] 2019-08-02 18:29:21.468 [Ruby-0-Thread-7: :1] elasticsearch - Using default mapping template
[INFO ] 2019-08-02 18:29:21.538 [Ruby-0-Thread-5: :1] elasticsearch - Using default mapping template
[INFO ] 2019-08-02 18:29:21.545 [[main]-pipeline-manager] elasticsearch - New Elasticsearch output {:class=&gt;"LogStash::Outputs::ElasticSearch", :hosts=&gt;["http://localhost:9200"]}
[INFO ] 2019-08-02 18:29:21.589 [Ruby-0-Thread-9: :1] elasticsearch - Using default mapping template
[INFO ] 2019-08-02 18:29:21.696 [Ruby-0-Thread-5: :1] elasticsearch - Attempting to install template {:manage_template=&gt;{"index_patterns"=&gt;"logstash-*", "version"=&gt;60001, "settings"=&gt;{"index.refresh_interval"=&gt;"5s", "number_of_shards"=&gt;1}, "mappings"=&gt;{"dynamic_templates"=&gt;[{"message_field"=&gt;{"path_match"=&gt;"message", "match_mapping_type"=&gt;"string", "mapping"=&gt;{"type"=&gt;"text", "norms"=&gt;false}}}, {"string_fields"=&gt;{"match"=&gt;"*", "match_mapping_type"=&gt;"string", "mapping"=&gt;{"type"=&gt;"text", "norms"=&gt;false, "fields"=&gt;{"keyword"=&gt;{"type"=&gt;"keyword", "ignore_above"=&gt;256}}}}}], "properties"=&gt;{"@timestamp"=&gt;{"type"=&gt;"date"}, "@version"=&gt;{"type"=&gt;"keyword"}, "geoip"=&gt;{"dynamic"=&gt;true, "properties"=&gt;{"ip"=&gt;{"type"=&gt;"ip"}, "location"=&gt;{"type"=&gt;"geo_point"}, "latitude"=&gt;{"type"=&gt;"half_float"}, "longitude"=&gt;{"type"=&gt;"half_float"}}}}}}}
[INFO ] 2019-08-02 18:29:21.769 [Ruby-0-Thread-7: :1] elasticsearch - Attempting to install template {:manage_template=&gt;{"index_patterns"=&gt;"logstash-*", "version"=&gt;60001, "settings"=&gt;{"index.refresh_interval"=&gt;"5s", "number_of_shards"=&gt;1}, "mappings"=&gt;{"dynamic_templates"=&gt;[{"message_field"=&gt;{"path_match"=&gt;"message", "match_mapping_type"=&gt;"string", "mapping"=&gt;{"type"=&gt;"text", "norms"=&gt;false}}}, {"string_fields"=&gt;{"match"=&gt;"*", "match_mapping_type"=&gt;"string", "mapping"=&gt;{"type"=&gt;"text", "norms"=&gt;false, "fields"=&gt;{"keyword"=&gt;{"type"=&gt;"keyword", "ignore_above"=&gt;256}}}}}], "properties"=&gt;{"@timestamp"=&gt;{"type"=&gt;"date"}, "@version"=&gt;{"type"=&gt;"keyword"}, "geoip"=&gt;{"dynamic"=&gt;true, "properties"=&gt;{"ip"=&gt;{"type"=&gt;"ip"}, "location"=&gt;{"type"=&gt;"geo_point"}, "latitude"=&gt;{"type"=&gt;"half_float"}, "longitude"=&gt;{"type"=&gt;"half_float"}}}}}}}
[INFO ] 2019-08-02 18:29:21.771 [Ruby-0-Thread-9: :1] elasticsearch - Attempting to install template {:manage_template=&gt;{"index_patterns"=&gt;"logstash-*", "version"=&gt;60001, "settings"=&gt;{"index.refresh_interval"=&gt;"5s", "number_of_shards"=&gt;1}, "mappings"=&gt;{"dynamic_templates"=&gt;[{"message_field"=&gt;{"path_match"=&gt;"message", "match_mapping_type"=&gt;"string", "mapping"=&gt;{"type"=&gt;"text", "norms"=&gt;false}}}, {"string_fields"=&gt;{"match"=&gt;"*", "match_mapping_type"=&gt;"string", "mapping"=&gt;{"type"=&gt;"text", "norms"=&gt;false, "fields"=&gt;{"keyword"=&gt;{"type"=&gt;"keyword", "ignore_above"=&gt;256}}}}}], "properties"=&gt;{"@timestamp"=&gt;{"type"=&gt;"date"}, "@version"=&gt;{"type"=&gt;"keyword"}, "geoip"=&gt;{"dynamic"=&gt;true, "properties"=&gt;{"ip"=&gt;{"type"=&gt;"ip"}, "location"=&gt;{"type"=&gt;"geo_point"}, "latitude"=&gt;{"type"=&gt;"half_float"}, "longitude"=&gt;{"type"=&gt;"half_float"}}}}}}}
[WARN ] 2019-08-02 18:29:21.871 [[main]-pipeline-manager] LazyDelegatingGauge - A gauge metric of an unknown type (org.jruby.specialized.RubyArrayOneObject) has been create for key: cluster_uuids. This may result in invalid serialization.  It is recommended to log an issue to the responsible developer/development team.
[INFO ] 2019-08-02 18:29:21.878 [[main]-pipeline-manager] javapipeline - Starting pipeline {:pipeline_id=&gt;"main", "pipeline.workers"=&gt;1, "pipeline.batch.size"=&gt;125, "pipeline.batch.delay"=&gt;50, "pipeline.max_inflight"=&gt;125, :thread=&gt;"#&lt;Thread:0x470bf1ca run&gt;"}
[INFO ] 2019-08-02 18:29:22.351 [[main]-pipeline-manager] javapipeline - Pipeline started {"pipeline.id"=&gt;"main"}
[INFO ] 2019-08-02 18:29:22.721 [Ruby-0-Thread-1: /usr/share/logstash/lib/bootstrap/environment.rb:6] agent - Pipelines running {:count=&gt;1, :running_pipelines=&gt;[:main], :non_running_pipelines=&gt;[]}
[INFO ] 2019-08-02 18:29:23.798 [Api Webserver] agent - Successfully started Logstash API endpoint {:port=&gt;9600}
/usr/share/logstash/vendor/bundle/jruby/2.5.0/gems/rufus-scheduler-3.0.9/lib/rufus/scheduler/cronline.rb:77: warning: constant ::Fixnum is deprecated
/usr/share/logstash/vendor/bundle/jruby/2.5.0/gems/rufus-scheduler-3.0.9/lib/rufus/scheduler/cronline.rb:77: warning: constant ::Fixnum is deprecated
/usr/share/logstash/vendor/bundle/jruby/2.5.0/gems/rufus-scheduler-3.0.9/lib/rufus/scheduler/cronline.rb:77: warning: constant ::Fixnum is deprecated
[INFO ] 2019-08-02 18:30:02.333 [Ruby-0-Thread-22: /usr/share/logstash/vendor/bundle/jruby/2.5.0/gems/rufus-scheduler-3.0.9/lib/rufus/scheduler/jobs.rb:284] jdbc - (0.042932s) SELECT * FROM pg_stat_user_indexes
[INFO ] 2019-08-02 18:30:02.340 [Ruby-0-Thread-23: /usr/share/logstash/vendor/bundle/jruby/2.5.0/gems/rufus-scheduler-3.0.9/lib/rufus/scheduler/jobs.rb:331] jdbc - (0.043178s) SELECT * FROM pg_stat_user_tables
[INFO ] 2019-08-02 18:30:02.340 [Ruby-0-Thread-24: :1] jdbc - (0.036469s) SELECT * FROM pg_stat_database
...
</code></pre>
<p>If Logstash does not show any errors and logs that it has successfully <code>SELECT</code>ed rows from the three databases, your database metrics will be shipped to Elasticsearch. If you get an error, double check all the values in the configuration file to ensure that the machine you're running Logstash on can connect to the managed database.</p>

<p>Logstash will continue importing the data at specified times. You can safely stop it by pressing <code>CTRL+C</code>.</p>

<p>As previously mentioned, when started as a service, Logstash automatically runs all configuration files it finds under <code>/etc/logstash/conf.d</code> in the background. Run the following command to start it as a service:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl start logstash
</li></ul></code></pre>
<p>In this step, you ran Logstash to check if it can connect to your database and gather data. Next, you'll visualize and explore some of the statistical data in Kibana.</p>

<h2 id="step-4-—-exploring-imported-data-in-kibana">Step 4 — Exploring Imported Data in Kibana</h2>

<p>In this section, you'll see how you can explore the statistical data describing your database's performance in Kibana.</p>

<p>In your browser, navigate to the Kibana installation you set up as a prerequisite. You'll see the default welcome page.</p>

<p><img src="https://assets.digitalocean.com/articles/postgres_managed_elk/step4a.png" alt="Kibana - Default Welcome Page"></p>

<p>To interact with Elasticsearch indexes in Kibana, you'll need to create an index pattern. <em>Index patterns</em> specify on which indexes Kibana should operate. To create one, press on the last icon (wrench) from the left-hand vertical sidebar to open the <strong>Management</strong> page. Then, from the left menu, press on <strong>Index Patterns</strong> under <strong>Kibana</strong>. You'll see a dialog box for creating an index pattern.</p>

<p><img src="https://assets.digitalocean.com/articles/postgres_managed_elk/step4b.png" alt="Kibana - Add Index Pattern"></p>

<p>Listed are the three indexes where Logstash has been sending statistics. Type in <code>pg_stat_database</code> in the <strong>Index Pattern</strong> input box and then press <strong>Next step</strong>. You'll be asked to select a field that stores time, so you'll be able to later narrow your data by a time range. From the dropdown, select <code>@timestamp</code>.</p>

<p><img src="https://assets.digitalocean.com/articles/postgres_managed_elk/step4c.png" alt="Kibana - Index Pattern Timestamp Field"></p>

<p>Press on <strong>Create index pattern</strong> to finish creating the index pattern. You'll now be able to explore it using Kibana. To create a visualization, press on the second icon in the sidebar, and then on <strong>Create new visualization</strong>. Select the <strong>Line</strong> visualization when the form pops up, and then choose the index pattern you have just created (<code>pg_stat_database</code>). You'll see an empty visualization.</p>

<p><img src="https://assets.digitalocean.com/articles/postgres_managed_elk/step4d.png" alt="Kibana - Empty Visualisation"></p>

<p>On the central part of the screen is the resulting plot—the left-side panel governs its generation from which you can set the data for X and Y axis. In the upper right-hand side of the screen is the date range picker. Unless you specifically choose another range when configuring the data, that range will be shown on the plot.</p>

<p>You'll now visualize the average number of data tuples <code>INSERT</code>ed on minutes in the given interval. Press on <strong>Y-Axis</strong> under <strong>Metrics</strong> in the panel on the left to unfold it. Select <em>Average</em> as the <strong>Aggregation</strong> and select <code>tup_inserted</code> as the <strong>Field</strong>. This will populate the Y axis of the plot with the average values.</p>

<p>Next, press on <strong>X-Axis</strong> under <strong>Buckets</strong>. For the <strong>Aggregation</strong>, choose <strong>Date Histogram</strong>. <code>@timestamp</code> should be automatically selected as the <strong>Field</strong>. Then, press on the blue play button on the top of the panel to generate your graph. If your database is brand new and not used, you won't see anything yet. In all cases, however, you will see an accurate portrayal of database usage.</p>

<p>Kibana supports many other visualization forms—you can explore other forms in the <a href="https://www.elastic.co/guide/en/kibana/current/tutorial-visualizing.html">Kibana documentation</a>. You can also add the two remaining indexes, mentioned in Step 2, into Kibana to be able to visualize them as well.</p>

<p>In this step, you have learned how to visualize some of the PostgreSQL statistical data, using Kibana.</p>

<h2 id="step-5-—-optional-benchmarking-using-pgbench">Step 5 — (Optional) Benchmarking Using pgbench</h2>

<p>If you haven't yet worked in your database outside of this tutorial, you can complete this step to create more interesting visualizations by using pgbench to benchmark your database. pgbench will run the same SQL commands over and over, simulating real-world database use by an actual client.</p>

<p>You'll first need to install pgbench by running the following command:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt install postgresql-contrib -y
</li></ul></code></pre>
<p>Because pgbench will insert and update test data, you'll need to create a separate database for it. To do so, head over to the <strong>Users &amp; Databases</strong> tab in the Control Panel of your managed database, and scroll down to the <strong>Databases</strong> section. Type in <code>pgbench</code> as the name of the new database, and then press on <strong>Save</strong>. You'll pass this name, as well as the host, port, and username information to pgbench.</p>

<p><img src="https://assets.digitalocean.com/articles/postgres_managed_elk/step5a.png" alt="Accessing Databases section in DO control panel"></p>

<p>Before actually running <code>pgbench</code>, you'll need to run it with the <code>-i</code> flag to initialize its database:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">pgbench -h <span class="highlight">host</span> -p <span class="highlight">port</span> -U <span class="highlight">username</span> -i pgbench
</li></ul></code></pre>
<p>You'll need to replace <code><span class="highlight">host</span></code> with your host address, <code><span class="highlight">port</span></code> with the port to which you can connect to your database, and <code><span class="highlight">username</span></code> with the database user username. You can find all these values in the Control Panel of your managed database.</p>

<p>Notice that <code>pgbench</code> does not have a password argument; instead, you'll be asked for it every time you run it.</p>

<p>The output will look like the following:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NOTICE:  table "pgbench_history" does not exist, skipping
NOTICE:  table "pgbench_tellers" does not exist, skipping
NOTICE:  table "pgbench_accounts" does not exist, skipping
NOTICE:  table "pgbench_branches" does not exist, skipping
creating tables...
100000 of 100000 tuples (100%) done (elapsed 0.16 s, remaining 0.00 s)
vacuum...
set primary keys...
done.
</code></pre>
<p><code>pgbench</code> created four tables, which it will use for benchmarking, and populated them with some example rows. You'll now be able to run benchmarks.</p>

<p>The two most important arguments that limit for how long the benchmark will run are <code>-t</code>, which specifies the number of transactions to complete, and <code>-T</code>, which defines for how many seconds the benchmark should run. These two options are mutually exclusive. At the end of each benchmark, you'll receive statistics, such as the number of transactions per second (<code>tps</code>).</p>

<p>Now, start a benchmark that will last for 30 seconds by running the following command:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">pgbench -h <span class="highlight">host</span> -p <span class="highlight">port</span> -U <span class="highlight">username</span> pgbench <span class="highlight">-T 30</span>
</li></ul></code></pre>
<p>The output will look like:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>starting vacuum...end.
transaction type: &lt;builtin: TPC-B (sort of)&gt;
scaling factor: 1
query mode: simple
number of clients: 1
number of threads: 1
duration: 30 s
number of transactions actually processed: 7602
latency average = 3.947 ms
tps = 253.382298 (including connections establishing)
tps = 253.535257 (excluding connections establishing)
</code></pre>
<p>In this output, you see the general info about the benchmark, such as the total number of transactions executed. The effect of these benchmarks is that the statistics Logstash ships to Elasticsearch will reflect that number, which will in turn make visualizations in Kibana more interesting and closer to real-world graphs. You can run the preceding command a few more times, and possibly alter the duration.</p>

<p>When you are done, head over to Kibana and press on <strong>Refresh</strong> in the upper right corner. You'll now see a different line than before, which shows the number of <code>INSERT</code>s. Feel free to change the time range of the data shown by changing the values in the picker positioned above the refresh button. Here is how the graph may look after multiple benchmarks of varying duration:</p>

<p><img src="https://assets.digitalocean.com/articles/postgres_managed_elk/step5b.png" alt="Kibana - Visualization After Benchmarks"></p>

<p>You've used pgbench to benchmark your database, and evaluated the resulting graphs in Kibana.</p>

<h2 id="conclusion">Conclusion</h2>

<p>You now have the Elastic stack installed on your server and configured to pull statistics data from your managed PostgreSQL database on a regular basis. You can analyze and visualize the data using Kibana, or some other suitable software, which will help you gather valuable insights and real-world correlations into how your database is performing.</p>

<p>For more information about what you can do with your PostgreSQL Managed Database, visit the <a href="https://www.digitalocean.com/docs/databases/">product docs</a>.</p>
