---
layout: post
title: Como Fazer o Deploy de uma aplicação PHP com Kubernetes no Ubuntu 18.04
network: digitalocean
date: December 16, 2019 at 07:04PM
url: https://www.digitalocean.com/community/tutorials/how-to-deploy-a-php-application-with-kubernetes-on-ubuntu-18-04-pt
image: http://ifttt.com/images/no_image_card.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<p><em>O autor escolheu a <a href="https://www.brightfunds.org/organizations/electronic-frontier-foundation-inc">Electronic Frontier Foundation</a> para receber uma doação como parte do programa <a href="https://do.co/w4do-cta">Write for DOnations</a>.</em></p>

<h3 id="introdução">Introdução</h3>

<p>O Kubernetes é um sistema open source de orquestração de container. Ele permite criar, atualizar e escalar containers sem se preocupar com o tempo de inatividade.</p>

<p>Para executar uma aplicação PHP, o Nginx atua como um proxy para o <a href="http://php.net/manual/en/install.fpm.php">PHP-FPM</a>. <em>Containerizar</em> essa configuração em um único container pode ser um processo complicado, mas o Kubernetes ajudará a gerenciar os dois serviços em containers separados. O uso do Kubernetes permitirá a você manter seus containers reutilizáveis e substituíveis, e você não precisará reconstruir sua imagem de container toda vez que houver uma nova versão do Nginx ou do PHP.</p>

<p>Neste tutorial, você fará o deploy de uma aplicação PHP 7 em um cluster Kubernetes com o Nginx e o PHP-FPM em execução em containers separados. Você também aprenderá como manter os seus arquivos de configuração e o código da aplicação fora da imagem do container usando o sistema de <a href="https://www.digitalocean.com/products/block-storage/">Block Storage da DigitalOcean</a>. Essa abordagem o permitirá reutilizar a imagem do Nginx para qualquer aplicação que precise de um servidor web/proxy passando um volume de configuração, em vez de reconstruir a imagem.</p>

<h2 id="pré-requisitos">Pré-requisitos</h2>

<ul>
<li>Uma compreensão básica dos objetos do Kubernetes. Confira nosso artigo <a href="https://www.digitalocean.com/community/tutorials/uma-introducao-ao-kubernetes-pt">Uma Introdução ao Kubernetes</a> para mais informações.</li>
<li>Um cluster Kubernetes em execução no Ubuntu 18.04. Você pode configurar isso seguindo o tutorial <a href="https://www.digitalocean.com/community/tutorials/como-criar-um-cluster-kubernetes-1-11-usando-kubeadm-no-ubuntu-18-04-pt">Como Criar um Cluster Kubernetes 1.11 Usando Kubeadm no Ubuntu 18.04</a> </li>
<li>Uma conta na DigitalOcean e um token de acesso à API com permissões de leitura e gravação para criar nosso volume de armazenamento. Se você não possui seu token de acesso à API, pode <a href="https://www.digitalocean.com/docs/api/create-personal-access-token/">criá-lo a partir daqui</a>.</li>
<li>O código de sua aplicação hospedado em uma URL acessível ao público, como o <a href="https://github.com">Github</a>.</li>
</ul>

<h2 id="passo-1-—-criando-os-serviços-php-fpm-e-nginx">Passo 1 — Criando os Serviços PHP-FPM e Nginx</h2>

<p>Neste passo, você criará os serviços PHP-FPM e Nginx. Um serviço permite o acesso a um conjunto de pods de dentro do cluster. Os serviços em um cluster podem se comunicar diretamente por meio de seus nomes, sem a necessidade de endereços IP. O serviço PHP-FPM permitirá acesso aos pods PHP-FPM, enquanto o serviço Nginx permitirá acesso aos pods Nginx.</p>

<p>Como os pods do Nginx farão proxy dos pods do PHP-FPM, você precisará informar ao serviço como encontrá-los. Em vez de usar endereços IP, você aproveitará a descoberta automática de serviços do Kubernetes para usar nomes legíveis por humanos para rotear solicitações para o serviço apropriado.</p>

<p>Para criar o serviço, você criará um arquivo de definição de objeto. Toda definição de objeto Kubernetes é um arquivo YAML que contém pelo menos os seguintes itens:</p>

<ul>
<li><code>apiVersion</code>: A versão da API do Kubernetes à qual a definição pertence.</li>
<li><code>kind</code>: O objeto Kubernetes que este arquivo representa. Por exemplo, um <code>pod</code> ou <code>service</code>.</li>
<li><code>metadata</code>: Isso contém o <code>nome</code> do objeto, juntamente com quaisquer <code>labels</code> que você queira aplicar a ele.</li>
<li><code>spec</code>: Isso contém uma configuração específica, dependendo do tipo de objeto que você está criando, como a imagem do container ou as portas nas quais o container estará acessível.</li>
</ul>

<p>Primeiro, você criará um diretório para armazenar suas definições de objeto do Kubernetes.</p>

<p>Faça SSH no seu <strong>node master</strong> e crie o diretório <code>definitions</code> que conterá as definições do objeto Kubernetes.</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir definitions
</li></ul></code></pre>
<p>Navegue até o diretório <code>definitions</code> recém-criado:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd definitions
</li></ul></code></pre>
<p>Defina seu serviço PHP-FPM criando um arquivo <code>php_service.yaml</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano php_service.yaml
</li></ul></code></pre>
<p>Defina <code>kind</code> como <code>Service</code> para especificar que este objeto é um serviço:</p>
<div class="code-label " title="php_service.yaml">php_service.yaml</div><pre class="code-pre "><code langs="">apiVersion: v1
kind: Service
</code></pre>
<p>Nomeie o serviço como <code>php</code>, pois ele fornecerá acesso ao PHP-FPM:</p>
<div class="code-label " title="php_service.yaml">php_service.yaml</div><pre class="code-pre "><code langs="">...
metadata:
  name: php
</code></pre>
<p>Você agrupará logicamente diferentes objetos com labels ou etiquetas. Neste tutorial, você usará labels para agrupar os objetos em &ldquo;camadas&rdquo;, como front-end ou back-end. Os pods do PHP serão executados por trás desse serviço, então você o etiquetará como <code>tier: backend</code>.</p>
<div class="code-label " title="php_service.yaml">php_service.yaml</div><pre class="code-pre "><code langs="">...
  labels:
    tier: backend
</code></pre>
<p>Um serviço determina quais pods acessar usando labels <code>selector</code>. Um pod que corresponda a essas labels será atendido, independentemente de o pod ter sido criado antes ou depois do serviço. Você adicionará labels para seus pods posteriormente no tutorial.</p>

<p>Use a label <code>tier: backend</code> para atribuir o pod à camada de back-end. Você também adicionará o rótulo <code>app: php</code> para especificar que este pod executa o PHP. Adicione essas duas labels após a seção <code>metadados</code>.</p>
<div class="code-label " title="php_service.yaml">php_service.yaml</div><pre class="code-pre "><code langs="">...
spec:
  selector:
    app: php
    tier: backend
</code></pre>
<p>Em seguida, especifique a porta usada para acessar este serviço. Você usará a porta <code>9000</code> neste tutorial. Adicione-a ao arquivo <code>php_service.yaml</code> abaixo de <code>spec</code>:</p>
<div class="code-label " title="php_service.yaml">php_service.yaml</div><pre class="code-pre "><code langs="">...
  ports:
    - protocol: TCP
      port: 9000
</code></pre>
<p>O arquivo <code>php_service.yaml</code> completo será semelhante a este:</p>
<div class="code-label " title="php_service.yaml">php_service.yaml</div><pre class="code-pre "><code langs="">apiVersion: v1
kind: Service
metadata:
  name: php
  labels:
    tier: backend
spec:
  selector:
    app: php
    tier: backend
  ports:
  - protocol: TCP
    port: 9000
</code></pre>
<p>Pressione <code>CTRL + O</code> para salvar o arquivo, e depois <code>CTRL + X</code> para sair do <code>nano</code>.</p>

<p>Agora que você criou a definição de objeto para o seu serviço, para executar o serviço, você usará o comando <code>kubectl apply</code> junto com a flag <code>-f</code> e especificará seu arquivo <code>php_service.yaml</code>.</p>

<p>Crie seu serviço:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f php_service.yaml
</li></ul></code></pre>
<p>Esta saída confirma a criação do serviço:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>service/php created
</code></pre>
<p>Verifique se o seu serviço está em execução:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get svc
</li></ul></code></pre>
<p>Você verá seu serviço PHP-FPM em execução:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE
kubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP    10m
php          ClusterIP   10.100.59.238   &lt;none&gt;        9000/TCP   5m
</code></pre>
<p>Existem vários <a href="https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types">tipos de serviço</a> que o Kubernetes suporta. Seu serviço <code>php</code> usa o tipo de serviço padrão, <code>ClusterIP</code>. Esse tipo de serviço atribui um IP interno e torna o serviço acessível apenas de dentro do cluster.</p>

<p>Agora que o serviço PHP-FPM está pronto, você criará o serviço Nginx. Crie e abra um novo arquivo chamado <code>nginx_service.yaml</code> com o editor:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano nginx_service.yaml
</li></ul></code></pre>
<p>Este serviço terá como alvo os pods do Nginx, então você o chamará de <code>nginx</code>. Você também adicionará uma label <code>tier: backend</code>, pois ele pertence à camada de backend:</p>
<div class="code-label " title="nginx_service.yaml">nginx_service.yaml</div><pre class="code-pre "><code langs="">apiVersion: v1
kind: Service
metadata:
  name: nginx
  labels:
    tier: backend
</code></pre>
<p>Semelhante ao serviço <code>php</code>, marque os pods com as labels <code>app: nginx</code> e <code>tier: backend</code>. Torne este serviço acessível na porta <code>80</code>, a porta HTTP padrão.</p>
<div class="code-label " title="nginx_service.yaml">nginx_service.yaml</div><pre class="code-pre "><code langs="">...
spec:
  selector:
    app: nginx
    tier: backend
  ports:
  - protocol: TCP
    port: 80
</code></pre>
<p>O serviço Nginx estará publicamente acessível na Internet a partir do endereço IP público do seu Droplet. <code><span class="highlight">seu_ip_público</span></code> pode ser encontrado em seu <a href="https://cloud.digitalocean.com">Painel de Controle da DigitalOcean</a>. Sob <code>spec.externalIPs</code>, adicione:</p>
<div class="code-label " title="nginx_service.yaml">nginx_service.yaml</div><pre class="code-pre "><code langs="">...
spec:
  externalIPs:
  - <span class="highlight">seu_ip_público</span>
</code></pre>
<p>Seu arquivo <code>nginx_service.yaml</code> será parecido com este:</p>
<div class="code-label " title="nginx_service.yaml">nginx_service.yaml</div><pre class="code-pre "><code langs="">apiVersion: v1
kind: Service
metadata:
  name: nginx
  labels:
    tier: backend
spec:
  selector:
    app: nginx
    tier: backend
  ports:
  - protocol: TCP
    port: 80
  externalIPs:
  - <span class="highlight">seu_ip_público</span>    
</code></pre>
<p>Salve e feche o arquivo. Crie o serviço Nginx:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f nginx_service.yaml
</li></ul></code></pre>
<p>Você verá a seguinte saída quando o serviço estiver sendo executado:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>service/nginx created
</code></pre>
<p>Você pode visualizar todos os serviços em execução executando:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get svc
</li></ul></code></pre>
<p>Você verá os serviços PHP-FPM e Nginx listados na saída:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE
kubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP    13m
nginx        ClusterIP   10.102.160.47   <span class="highlight">seu_ip_público</span> 80/TCP     50s
php          ClusterIP   10.100.59.238   &lt;none&gt;        9000/TCP   8m
</code></pre>
<p>Observe que, se você deseja excluir um serviço, você pode executar:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl delete svc/<span class="highlight">nome_do_serviço</span>
</li></ul></code></pre>
<p>Agora que você criou seus serviços PHP-FPM e Nginx, precisará especificar onde armazenar o código da aplicação e os arquivos de configuração.</p>

<h2 id="passo-2-—-instalando-o-plug-in-de-armazenamento-da-digitalocean">Passo 2 — Instalando o Plug-in de Armazenamento da DigitalOcean</h2>

<p>O Kubernetes fornece diferentes plug-ins de armazenamento que podem criar o espaço de armazenamento para o seu ambiente. Neste passo, você instalará o <a href="https://github.com/digitalocean/csi-digitalocean">plug-in de Armazenamento da DigitalOcean</a> para criar <a href="https://www.digitalocean.com/products/storage/">block storage</a> na DigitalOcean. Quando a instalação estiver concluída, ela adicionará uma classe de armazenamento denominada <code>do-block-storage</code> que você usará para criar seu armazenamento em blocos ou block storage.</p>

<p>Você primeiro configurará um objeto Kubernetes Secret para armazenar seu token da API da DigitalOcean. Objetos Secret são usados para compartilhar informações confidenciais, como chaves e senhas SSH, com outros objetos do Kubernetes no mesmo namespace. Os namespaces fornecem uma maneira de separar logicamente os objetos do Kubernetes.</p>

<p>Abra um arquivo chamado <code>secret.yaml</code> com o editor:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano secret.yaml
</li></ul></code></pre>
<p>Você nomeará seu objeto Secret como <code>digitalocean</code> e o adicionará ao namespace <code>kube-system</code>. O namespace <code>kube-system</code> é o namespace padrão para os serviços internos do Kubernetes e também é usado pelo plug-in de armazenamento da DigitalOcean para ativar vários componentes.</p>
<div class="code-label " title="secret.yaml">secret.yaml</div><pre class="code-pre "><code langs="">apiVersion: v1
kind: Secret
metadata:
  name: digitalocean
  namespace: kube-system
</code></pre>
<p>Em vez de uma chave <code>spec</code>, um Secret usa uma chave <code>data</code> ou <code>stringData</code> para armazenar as informações necessárias. O parâmetro <code>data</code> contém dados codificados em base64 que são decodificados automaticamente quando recuperados. O parâmetro <code>stringData</code> contém dados não codificados que são codificados automaticamente durante a criação ou atualizações e não mostra os dados ao recuperar Secrets. Você usará <code>stringData</code> neste tutorial por conveniência.</p>

<p>Adicione <code>access-token</code> como <code>stringData</code>:</p>
<div class="code-label " title="secret.yaml">secret.yaml</div><pre class="code-pre "><code langs="">...
stringData:
  access-token: <span class="highlight">seu_token_de_api</span>
</code></pre>
<p>Salve e saia do arquivo.</p>

<p>O seu arquivo <code>secret.yaml</code> ficará assim:</p>
<div class="code-label " title="secret.yaml">secret.yaml</div><pre class="code-pre "><code langs="">apiVersion: v1
kind: Secret
metadata:
  name: digitalocean
  namespace: kube-system
stringData:
  access-token: <span class="highlight">seu_token_de_api</span>
</code></pre>
<p>Crie o secret:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f secret.yaml
</li></ul></code></pre>
<p>Você verá esta saída na criação do Secret:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>secret/digitalocean created
</code></pre>
<p>Você pode ver o Secret com o seguinte comando:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl -n kube-system get secret digitalocean
</li></ul></code></pre>
<p>A saída será semelhante a esta:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME           TYPE      DATA      AGE
digitalocean   Opaque    1         41s
</code></pre>
<p>O tipo <code>Opaque</code> significa que esse Secret é somente leitura, o que é padrão para os Secrets <code>stringData</code>. Você pode ler mais sobre isso em <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/auth/secrets.md">Secret design spec</a>. O campo <code>DATA</code> mostra o número de itens armazenados neste Secret. Neste caso, mostra <code>1</code> porque você tem uma única chave armazenada.</p>

<p>Agora que seu Secret está no lugar, instale o <a href="https://github.com/digitalocean/csi-digitalocean">plug-in de armazenamento em bloco da DigitalOcean</a>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f https://raw.githubusercontent.com/digitalocean/csi-digitalocean/master/deploy/kubernetes/releases/csi-digitalocean-v1.1.0.yaml
</li></ul></code></pre>
<p>Você verá uma saída semelhante à seguinte:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>csidriver.storage.k8s.io/dobs.csi.digitalocean.com created
customresourcedefinition.apiextensions.k8s.io/volumesnapshotclasses.snapshot.storage.k8s.io created
customresourcedefinition.apiextensions.k8s.io/volumesnapshotcontents.snapshot.storage.k8s.io created
customresourcedefinition.apiextensions.k8s.io/volumesnapshots.snapshot.storage.k8s.io created
storageclass.storage.k8s.io/do-block-storage created
statefulset.apps/csi-do-controller created
serviceaccount/csi-do-controller-sa created
clusterrole.rbac.authorization.k8s.io/csi-do-provisioner-role created
clusterrolebinding.rbac.authorization.k8s.io/csi-do-provisioner-binding created
clusterrole.rbac.authorization.k8s.io/csi-do-attacher-role created
clusterrolebinding.rbac.authorization.k8s.io/csi-do-attacher-binding created
clusterrole.rbac.authorization.k8s.io/csi-do-snapshotter-role created
clusterrolebinding.rbac.authorization.k8s.io/csi-do-snapshotter-binding created
daemonset.apps/csi-do-node created
serviceaccount/csi-do-node-sa created
clusterrole.rbac.authorization.k8s.io/csi-do-node-driver-registrar-role created
clusterrolebinding.rbac.authorization.k8s.io/csi-do-node-driver-registrar-binding created
error: unable to recognize "https://raw.githubusercontent.com/digitalocean/csi-digitalocean/master/deploy/kubernetes/releases/csi-digitalocean-v1.1.0.yaml": no matches for kind "VolumeSnapshotClass" in version "snapshot.storage.k8s.io/v1alpha1"
</code></pre>
<p>Para este tutorial, é seguro ignorar os erros.</p>

<p>Agora que você instalou o plug-in de armazenamento da DigitalOcean, é possível criar armazenamento em bloco para armazenar o código da aplicação e os arquivos de configuração.</p>

<h2 id="passo-3-—-criando-um-volume-persistente">Passo 3 — Criando um Volume Persistente</h2>

<p>Com o seu Secret no lugar e o plug-in de armazenamento em bloco instalado, agora você está pronto para criar seu <em>Volume Persistente</em>. Um Volume Persistente, ou PV, é um armazenamento em bloco de um tamanho especificado que vive independentemente do ciclo de vida de um pod. O uso de um volume persistente lhe permitirá gerenciar ou atualizar seus pods sem se preocupar em perder o código da aplicação. Um Volume Persistente é acessado usando um <code>PersistentVolumeClaim</code> ou PVC, que monta o PV no caminho especificado.</p>

<p>Abra um arquivo chamado <code>code_volume.yaml</code> com seu editor: </p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano code_volume.yaml
</li></ul></code></pre>
<p>Nomeie o PVC como <code>code</code>  adicionando os seguintes parâmetros e valores ao seu arquivo:</p>
<div class="code-label " title="code_volume.yaml">code_volume.yaml</div><pre class="code-pre "><code langs="">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: code
</code></pre>
<p>A <code>spec</code> para um PVC contém os seguintes itens:</p>

<ul>
<li><code>accessModes</code> que variam de acordo com o caso de uso. Eles são:

<ul>
<li><code>ReadWriteOnce</code> – monta o volume como leitura e gravação para um único node</li>
<li><code>ReadOnlyMany</code> – monta o volume como somente leitura para muitos nodes</li>
<li><code>ReadWriteMany</code> – monta o volume como leitura e gravação par muitos nodes</li>
</ul></li>
<li><code>resources</code>  – o espaço de armazenamento que você precisa</li>
</ul>

<p>O armazenamento em bloco da DigitalOcean é montado apenas em um único node, portanto, você definirá o <code>accessModes</code> como <code>ReadWriteOnce</code>. Este tutorial o guiará na adição de uma pequena quantidade de código da aplicação, portanto, 1 GB será suficiente nesse caso de uso. Se você planeja armazenar uma quantidade maior de código ou dados no volume, pode modificar o parâmetro <code>storage</code> para atender aos seus requisitos. Você pode aumentar a quantidade de armazenamento após a criação do volume, mas a redução do disco não é suportada.</p>
<div class="code-label " title="code_volume.yaml">code_volume.yaml</div><pre class="code-pre "><code langs="">...
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: <span class="highlight">1Gi</span>
</code></pre>
<p>Em seguida, especifique a classe de armazenamento que o Kubernetes usará para provisionar os volumes. Você usará a classe <code>do-block-storage</code> criada pelo plug-in de armazenamento em bloco da DigitalOcean.</p>
<div class="code-label " title="code_volume.yaml">code_volume.yaml</div><pre class="code-pre "><code langs="">...
  storageClassName: do-block-storage
</code></pre>
<p>O seu arquivo <code>code_volume.yaml</code> ficará assim:</p>
<div class="code-label " title="code_volume.yaml">code_volume.yaml</div><pre class="code-pre "><code langs="">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: code
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: <span class="highlight">1Gi</span>
  storageClassName: do-block-storage
</code></pre>
<p>Salve e saia do arquivo.</p>

<p>Crie o PVC <code>code</code> usando <code>kubectl</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f code_volume.yaml
</li></ul></code></pre>
<p>A saída a seguir informa que o objeto foi criado com sucesso e você está pronto para montar seu PVC de 1 GB como um volume.</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>persistentvolumeclaim/code created
</code></pre>
<p>Para visualizar os Volumes Persistentes (PV) disponíveis:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get pv
</li></ul></code></pre>
<p>Você verá seu PV listado:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS    CLAIM          STORAGECLASS       REASON    AGE
pvc-ca4df10f-ab8c-11e8-b89d-12331aa95b13   1Gi        RWO            Delete           Bound     default/code   do-block-storage             2m
</code></pre>
<p>Os campos acima são uma visão geral do seu arquivo de configuração, exceto <code>Reclaim Policy</code> e <code>Status</code>. A <code>Reclaim Policy</code> ou política de recuperação define o que é feito com o PV depois que o PVC que o está acessando é excluído. <code>Delete</code> remove o PV do Kubernetes e da infraestrutura da DigitalOcean. Você pode aprender mais sobre <code>Reclaim Policy</code> e <code>Status</code> na <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/">documentação do Kubernetes PV</a>.</p>

<p>Você criou com sucesso um Volume Persistente usando o plug-in de armazenamento em bloco da DigitalOcean. Agora que seu volume persistente está pronto, você criará seus pods usando um Deployment.</p>

<h2 id="passo-4-—-criando-um-deployment-php-fpm">Passo 4 — Criando um Deployment PHP-FPM</h2>

<p>Nesta etapa, você aprenderá como usar um Deployment para criar seu pod PHP-FPM. Os Deployments fornecem uma maneira uniforme de criar, atualizar e gerenciar pods usando <a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/">ReplicaSets</a>.</p>

<p>A chave <code>spec.selector</code> do Deployment listará as labels dos pods que ela gerenciará. Ela também usará a chave <code>template</code> para criar os pods necessários.</p>

<p>Este passo também apresentará o uso de Init Containers. <em>Init Containers</em> executa um ou mais comandos antes dos containers regulares especificados na chave <code>template</code> do pod. Neste tutorial, seu Init Container buscará um arquivo de exemplo <code>index.php</code> no <a href="https://gist.github.com">GitHub Gist</a> usando o wget. Este é o conteúdo do arquivo de amostra:</p>
<div class="code-label " title="index.php">index.php</div><pre class="code-pre "><code langs="">&lt;?php
echo phpinfo(); 
</code></pre>
<p>Para criar seu Deployment, abra um novo arquivo chamado <code>php_deployment.yaml</code> com seu editor:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano php_deployment.yaml
</li></ul></code></pre>
<p>Este Deployment gerenciará seus pods do PHP-FPM, assim você nomeará o objeto do Deployment como <code>php</code>. Os pods pertencem à camada de back-end, portanto, você agrupará o Deployment nesse grupo usando a label <code>tier: backend</code>:</p>
<div class="code-label " title="php_deployment.yaml">php_deployment.yaml</div><pre class="code-pre "><code langs="">apiVersion: apps/v1
kind: Deployment
metadata:
  name: php
  labels:
    tier: backend
</code></pre>
<p>Para o Deployment <code>spec</code>, você especificará quantas cópias deste pod criar usando o parâmetro <code>replicas</code>. O número de <code>replicas</code> irá variar dependendo de suas necessidades e recursos disponíveis. Você criará uma réplica neste tutorial:</p>
<div class="code-label " title="php_deployment.yaml">php_deployment.yaml</div><pre class="code-pre "><code langs="">...
spec:
  replicas: 1
</code></pre>
<p>Este Deployment gerenciará os pods que correspondem às labels <code>app: php</code> e <code>tier: backend</code>. Sob a chave <code>seletor</code>, adicione:</p>
<div class="code-label " title="php_deployment.yaml">php_deployment.yaml</div><pre class="code-pre "><code langs="">...
  selector:
    matchLabels:
      app: php
      tier: backend
</code></pre>
<p>A seguir, o Deployment <code>spec</code> requer o <code>template</code> para a definição de objeto do seu pod. Este template ou modelo definirá especificações para a criação do pod. Primeiro, você adicionará as labels que foram especificadas para os seletores ou <code>selectors</code>  do serviço php e os <code>matchLabels</code> do Deployment. Adicione <code>app: php</code> e <code>tier: backend</code> sob <code>template.metadata.labels</code>:</p>
<div class="code-label " title="php_deployment.yaml">php_deployment.yaml</div><pre class="code-pre "><code langs="">...
  template:
    metadata:
      labels:
        app: php
        tier: backend
</code></pre>
<p>Um pod pode ter vários containers e volumes, mas cada um precisará de um nome. Você pode montar seletivamente volumes em um container, especificando um caminho de montagem para cada volume.</p>

<p>Primeiro, especifique os volumes que seus containers acessarão. Você criou um PVC chamado <code>code</code> para armazenar o código da aplicação, portanto, nomeie esse volume como <code>code</code>. Sob <code>spec.template.spec.volumes</code>, adicione o seguinte:</p>
<div class="code-label " title="php_deployment.yaml">php_deployment.yaml</div><pre class="code-pre "><code langs="">...
    spec:
      volumes:
      - name: code
        persistentVolumeClaim:
          claimName: code
</code></pre>
<p>Em seguida, especifique o container que você deseja executar neste pod. Você pode encontrar várias imagens na <a href="https://hub.docker.com/explore/">Docker store</a>, mas neste tutorial você usará a imagem <code>php:7-fpm</code>.</p>

<p>Sob <code>spec.template.spec.containers</code>, adicione o seguinte: </p>
<div class="code-label " title="php_deployment.yaml">php_deployment.yaml</div><pre class="code-pre "><code langs="">...
      containers:
      - name: php
        image: php:7-fpm
</code></pre>
<p>Em seguida, você montará os volumes aos quais o container requer acesso. Este container executará seu código PHP e, portanto, precisará acessar o volume <code>code</code>. Você também usará <code>mountPath</code> para especificar <code>/code</code> como o ponto de montagem.</p>

<p>Sob <code>spec.template.spec.containers.volumeMounts</code>, adicione:</p>
<div class="code-label " title="php_deployment.yaml">php_deployment.yaml</div><pre class="code-pre "><code langs="">...
        volumeMounts:
        - name: code
          mountPath: /code
</code></pre>
<p>Agora que você montou seu volume, é necessário inserir o código da sua aplicação no volume. Você pode ter usado anteriormente FTP/SFTP ou clonado o código em uma conexão SSH para fazer isso, mas este passo mostrará como copiar o código usando um Init Container.</p>

<p>Dependendo da complexidade do seu processo de instalação, você pode usar um único <code>initContainer</code> para executar um script que constrói sua aplicação, ou você pode usar um<code>initContainer</code> por comando. Certifique-se de que os volumes estejam montados no <code>initContainer</code>.</p>

<p>Neste tutorial, você usará um único Init Container com <code>busybox</code> para baixar o código. <code>busybox</code> é uma pequena imagem que contém o utilitário <code>wget</code> que você usará para fazer isso.</p>

<p>Sob <code>spec.template.spec</code>, adicione seu <code>initContainer</code> e especifique a imagem <code>busybox</code>:</p>
<div class="code-label " title="php_deployment.yaml">php_deployment.yaml</div><pre class="code-pre "><code langs="">...
      initContainers:
      - name: install
        image: busybox
</code></pre>
<p>Seu Init Container precisará acessar o volume do <code>code</code> para que possa fazer o download do código nesse local. Sob <code>spec.template.spec.initContainers</code>, monte o volume<code>code</code> no caminho <code>/code</code>:</p>
<div class="code-label " title="php_deployment.yaml">php_deployment.yaml</div><pre class="code-pre "><code langs="">...
        volumeMounts:
        - name: code
          mountPath: /code
</code></pre>
<p>Cada Init Container precisa executar um <code>comando</code>. Seu Init Container usará o <code>wget</code> para baixar <a href="https://raw.githubusercontent.com/do-community/php-kubernetes/master/index.php">o código</a> a partir do <a href="https://github.com/do-community/php-kubernetes">Github</a> dentro do diretório de trabalho <code>/code</code>. A flag <code>-O</code> atribui um nome ao arquivo baixado e você nomeará esse arquivo como <code>index.php</code>.</p>

<p><span class='note'><strong>Nota:</strong> Certifique-se de confiar no código que você está enviando. Antes de baixá-lo para o seu servidor, inspecione o código-fonte para garantir que você esteja confortável com o que o código faz.<br></span></p>

<p>Abaixo do container <code>install</code> em <code>spec.template.spec.initContainers</code>, adicione estas linhas:</p>
<div class="code-label " title="php_deployment.yaml">php_deployment.yaml</div><pre class="code-pre "><code langs="">...
        command:
        - wget
        - "-O"
        - "/code/index.php"
        - <span class="highlight">https://raw.githubusercontent.com/do-community/php-kubernetes/master/index.php</span>
</code></pre>
<p>Seu arquivo <code>php_deployment.yaml</code> completo será semelhante a este:</p>
<div class="code-label " title="php_deployment.yaml">php_deployment.yaml</div><pre class="code-pre "><code langs="">apiVersion: apps/v1
kind: Deployment
metadata:
  name: php
  labels:
    tier: backend
spec:
  replicas: 1
  selector:
    matchLabels:
      app: php
      tier: backend
  template:
    metadata:
      labels:
        app: php
        tier: backend
    spec:
      volumes:
      - name: code
        persistentVolumeClaim:
          claimName: code
      containers:
      - name: php
        image: php:7-fpm
        volumeMounts:
        - name: code
          mountPath: /code
      initContainers:
      - name: install
        image: busybox
        volumeMounts:
        - name: code
          mountPath: /code
        command:
        - wget
        - "-O"
        - "/code/index.php"
        - https://raw.githubusercontent.com/do-community/php-kubernetes/master/index.php
</code></pre>
<p>Salve o arquivo e saia do editor.</p>

<p>Crie o deployment PHP-FPM com o  <code>kubectl</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f php_deployment.yaml
</li></ul></code></pre>
<p>Você verá a seguinte saída na criação do Deployment:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>deployment.apps/php created
</code></pre>
<p>Para resumir, esse Deployment começará baixando as imagens especificadas. Ele então solicitará o <code>PersistentVolume</code> do seu <code>PersistentVolumeClaim</code> e executará em série o seu <code>initContainers</code>. Depois de concluídos, os containers irão executar e montar os <code>volumes</code> no ponto de montagem especificado. Quando todas essas etapas estiverem concluídas, seu pod estará em funcionamento.</p>

<p>Você pode visualizar seu Deployment executando:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get deployments
</li></ul></code></pre>
<p>Você verá a saída:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
php       1         1         1            0           19s
</code></pre>
<p>Esta saída pode ajudá-lo a entender o estado atual do Deployment. Um <code>Deployment</code> é <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">um dos controladores</a> que mantém um estado desejado. O <code>template</code> que você criou especifica que o estado desejado ou <code>DESIRED</code> terá 1 <code>replicas</code> do pod chamado <code>php</code>. O campo <code>CURRENT</code> indica quantas réplicas estão executando, portanto, isso deve corresponder ao estado <code>DESIRED</code>. Você pode ler sobre os campos restantes na <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">documentação do Kubernetes Deployments</a>.</p>

<p>Você pode visualizar os pods que esse Deployment iniciou com o seguinte comando:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get pods
</li></ul></code></pre>
<p>A saída deste comando varia dependendo de quanto tempo se passou desde a criação do Deployment. Se você executá-lo logo após a criação, a saída provavelmente será assim:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME                   READY     STATUS     RESTARTS   AGE
php-86d59fd666-bf8zd   0/1       Init:0/1   0          9s
</code></pre>
<p>As colunas representam as seguintes informações:</p>

<ul>
<li><code>Ready</code>: O número de <code>replicas</code> executando nesse pod.</li>
<li><code>Status</code>: O status do pod. <code>Init</code> indica que os Init Containers estão executando. Nesta saída, 0 de 1 Init Containers terminaram a execução.</li>
<li><code>Restarts</code>: Quantas vezes esse processo foi reiniciado para iniciar o pod. Esse número aumentará se algum dos seus Init Containers falhar. O Deployment irá reiniciá-lo até atingir o estado desejado.</li>
</ul>

<p>Dependendo da complexidade dos seus scripts de inicialização, pode levar alguns minutos para que o status mude para <code>podInitializing</code>:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME                   READY     STATUS            RESTARTS   AGE
php-86d59fd666-lkwgn   0/1       podInitializing   0          39s
</code></pre>
<p>Isso significa que os Init Containers foram finalizados e os containers estão inicializando. Se você executar o comando quando todos os containers estiverem em execução, o status do pod será alterado para <code>Running</code>.</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME                   READY     STATUS            RESTARTS   AGE
php-86d59fd666-lkwgn   1/1       Running   0          1m
</code></pre>
<p>Agora você vê que seu pod está sendo executado com êxito. Se o seu pod não iniciar, você poderá depurar com os seguintes comandos:</p>

<ul>
<li>Ver informações detalhadas de um pod: </li>
</ul>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl describe pods <span class="highlight">nome-do-pod</span>
</li></ul></code></pre>
<ul>
<li>Ver os logs gerados por um pod:</li>
</ul>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl logs <span class="highlight">nome-do-pod</span>
</li></ul></code></pre>
<ul>
<li>Visualizar os logs de um container específico em um pod:</li>
</ul>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl logs <span class="highlight">nome-do-pod</span> <span class="highlight">nome-do-container</span>
</li></ul></code></pre>
<p>O código da sua aplicação está montado e o serviço PHP-FPM está pronto para lidar com as conexões. Agora você pode criar seu Deployment do Nginx.</p>

<h2 id="passo-5-—-criando-o-deployment-do-nginx">Passo 5 — Criando o Deployment do Nginx</h2>

<p>Neste passo, você usará um <em>ConfigMap</em> para configurar o Nginx. Um ConfigMap mantém sua configuração em um formato de chave-valor que você pode referenciar em outras definições de objeto do Kubernetes. Essa abordagem concederá a flexibilidade de reutilizar ou trocar a imagem por uma versão diferente do Nginx, se necessário. A atualização do ConfigMap replicará automaticamente as alterações em qualquer pod que o monte.</p>

<p>Crie um arquivo <code>nginx_configMap.yaml</code> para seu ConfigMap com seu editor:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano nginx_configMap.yaml
</li></ul></code></pre>
<p>Nomeie o ConfigMap como <code>nginx-config</code> e agrupe-o no microsserviço <code>tier: backend</code>:</p>
<div class="code-label " title="nginx_configMap.yaml">nginx_configMap.yaml</div><pre class="code-pre "><code langs="">apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
  labels:
    tier: backend
</code></pre>
<p>Em seguida, você adicionará os dados, <code>data</code>, para o ConfigMap. Nomeie a chave como <code>config</code> e adicione o conteúdo do seu arquivo de configuração do Nginx como o valor. Você pode usar o exemplo de configuração do Nginx <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-nginx-server-blocks-virtual-hosts-on-ubuntu-16-04#step-three-create-server-block-files-for-each-domain">deste tutorial</a>.</p>

<p>Como o Kubernetes pode rotear solicitações para o host apropriado para um serviço, você pode inserir o nome do seu serviço PHP-FPM no parâmetro <code>fastcgi_pass</code> em vez de seu endereço IP. Adicione o seguinte ao seu arquivo <code>nginx_configMap.yaml</code>:</p>
<div class="code-label " title="nginx_configMap.yaml">nginx_configMap.yaml</div><pre class="code-pre "><code langs="">...
data:
  config : |
    server {
      index index.php index.html;
      error_log  /var/log/nginx/error.log;
      access_log /var/log/nginx/access.log;
      root <span class="highlight">/code</span>;

      location / {
          try_files $uri $uri/ /index.php?$query_string;
      }

      location ~ \.php$ {
          try_files $uri =404;
          fastcgi_split_path_info ^(.+\.php)(/.+)$;
          fastcgi_pass <span class="highlight">php:9000</span>;
          fastcgi_index index.php;
          include fastcgi_params;
          fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
          fastcgi_param PATH_INFO $fastcgi_path_info;
        }
    }
</code></pre>
<p>Seu arquivo <code>nginx_configMap.yaml</code> será parecido com este:</p>
<div class="code-label " title="nginx_configMap.yaml">nginx_configMap.yaml</div><pre class="code-pre "><code langs="">apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
  labels:
    tier: backend
data:
  config : |
    server {
      index index.php index.html;
      error_log  /var/log/nginx/error.log;
      access_log /var/log/nginx/access.log;
      root /code;

      location / {
          try_files $uri $uri/ /index.php?$query_string;
      }

      location ~ \.php$ {
          try_files $uri =404;
          fastcgi_split_path_info ^(.+\.php)(/.+)$;
          fastcgi_pass php:9000;
          fastcgi_index index.php;
          include fastcgi_params;
          fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
          fastcgi_param PATH_INFO $fastcgi_path_info;
        }
    }
</code></pre>
<p>Salve o arquivo e saia do editor.</p>

<p>Crie o ConfigMap:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f nginx_configMap.yaml
</li></ul></code></pre>
<p>Você verá a seguinte saída:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>configmap/nginx-config created
</code></pre>
<p>Você terminou de criar o seu ConfigMap e agora pode criar seu Deployment do Nginx.</p>

<p>Comece abrindo um novo arquivo <code>nginx_deployment.yaml</code> no editor:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano nginx_deployment.yaml
</li></ul></code></pre>
<p>Nomeie o Deployment como <code>nginx</code> e adicione a label <code>tier: backend</code>: </p>
<div class="code-label " title="nginx_deployment.yaml">nginx_deployment.yaml</div><pre class="code-pre "><code langs="">apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
  labels:
    tier: backend
</code></pre>
<p>Especifique que você quer uma <code>replicas</code> na <code>spec</code> do Deployment. Esse Deployment gerenciará os pods com labels <code>app: nginx</code> e <code>tier: backend</code>. Adicione os seguintes parâmetros e valores:</p>
<div class="code-label " title="nginx_deployment.yaml">nginx_deployment.yaml</div><pre class="code-pre "><code langs="">...
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
      tier: backend
</code></pre>
<p>Em seguida, adicione o <code>template</code> do pod. Você precisa usar as mesmas labels que você adicionou para o Deployment <code>selector.matchLabels</code>. Adicione o seguinte:</p>
<div class="code-label " title="nginx_deployment.yaml">nginx_deployment.yaml</div><pre class="code-pre "><code langs="">...
  template:
    metadata:
      labels:
        app: nginx
        tier: backend
</code></pre>
<p>Dê ao Nginx acesso ao PVC <code>code</code> que você criou anteriormente. Sob <code>spec.template.spec.volumes</code>, adicione:</p>
<div class="code-label " title="nginx_deployment.yaml">nginx_deployment.yaml</div><pre class="code-pre "><code langs="">...
    spec:
      volumes:
      - name: code
        persistentVolumeClaim:
          claimName: code
</code></pre>
<p>Os pods podem montar um ConfigMap como um volume. A especificação de um nome de arquivo e chave criará um arquivo com seu valor como conteúdo. Para usar o ConfigMap, defina <code>path</code> como o nome do arquivo que armazenará o conteúdo da <code>key</code>. Você deseja criar um arquivo <code>site.conf</code> a partir da chave <code>config</code>. Sob <code>spec.template.spec.volumes</code>, adicione o seguinte:</p>
<div class="code-label " title="nginx_deployment.yaml">nginx_deployment.yaml</div><pre class="code-pre "><code langs="">...
      - name: config
        configMap:
          name: nginx-config
          items:
          - key: config
            path: site.conf
</code></pre>
<p><span class='warning'><strong>Atenção</strong>: Se um arquivo não for especificado, o conteúdo de <code>key</code> substituirá o  <code>mountPath</code> ou o caminho de montagem do volume. Isso significa que, se um caminho não for especificado explicitamente, você perderá todo o conteúdo na pasta de destino.<br></span></p>

<p>A seguir, você especificará a imagem a partir da qual criar seu pod. Este tutorial usará a imagem <code>nginx:1.7.9</code> para estabilidade, mas você pode encontrar outras imagens Nginx na <a href="https://hub.docker.com/explore/">Docker store</a>. Além disso, torne o Nginx disponível na porta <code>80</code>. Sob <code>spec.template.spec</code>, adicione:</p>
<div class="code-label " title="nginx_deployment.yaml">nginx_deployment.yaml</div><pre class="code-pre "><code langs="">...
      containers:
      - name: nginx
        image: <span class="highlight">nginx:1.7.9</span>
        ports:
        - containerPort: 80
</code></pre>
<p>O Nginx e o PHP-FPM precisam acessar o arquivo no mesmo caminho, portanto, monte o volume <code>code</code> em <code>/code</code>:</p>
<div class="code-label " title="nginx_deployment.yaml">nginx_deployment.yaml</div><pre class="code-pre "><code langs="">...
        volumeMounts:
        - name: code
          mountPath: /code
</code></pre>
<p>A imagem <code>nginx:1.7.9</code> carregará automaticamente quaisquer arquivos de configuração no diretório <code>/etc/nginx/conf.d</code>. A montagem do volume <code>config</code> neste diretório criará o arquivo <code>/etc/nginx/conf.d/site.conf</code>. Sob <code>volumeMounts</code>, adicione o seguinte:</p>
<div class="code-label " title="nginx_deployment.yaml">nginx_deployment.yaml</div><pre class="code-pre "><code langs="">...
        - name: config
          mountPath: /etc/nginx/conf.d
</code></pre>
<p>Seu arquivo <code>nginx_deployment.yaml</code> será parecido com este:</p>
<div class="code-label " title="nginx_deployment.yaml">nginx_deployment.yaml</div><pre class="code-pre "><code langs="">apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
  labels:
    tier: backend
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
      tier: backend
  template:
    metadata:
      labels:
        app: nginx
        tier: backend
    spec:
      volumes:
      - name: code
        persistentVolumeClaim:
          claimName: code
      - name: config
        configMap:
          name: nginx-config
          items:
          - key: config
            path: site.conf
      containers:
      - name: nginx
        image: <span class="highlight">nginx:1.7.9</span>
        ports:
        - containerPort: 80
        volumeMounts:
        - name: code
          mountPath: /code
        - name: config
          mountPath: /etc/nginx/conf.d
</code></pre>
<p>Salve o arquivo e saia do editor.</p>

<p>Crie o Deployment do Nginx:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f nginx_deployment.yaml
</li></ul></code></pre>
<p>A seguinte saída indica que seu Deployment foi criado agora:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>deployment.apps/nginx created
</code></pre>
<p>Liste seus Deployments com este comando:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get deployments
</li></ul></code></pre>
<p>Você verá os Deployments Nginx e PHP-FPM:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx     1         1         1            0           16s
php       1         1         1            1           7m
</code></pre>
<p>Liste os pods gerenciados por ambos os deployments:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get pods
</li></ul></code></pre>
<p>Você verá os pods em execução:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME                     READY     STATUS    RESTARTS   AGE
nginx-7bf5476b6f-zppml   1/1       Running   0          32s
php-86d59fd666-lkwgn     1/1       Running   0          7m
</code></pre>
<p>Agora que todos os objetos do Kubernetes estão ativos, você pode visitar o serviço Nginx no seu navegador.</p>

<p>Liste os serviços em execução:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get services -o wide
</li></ul></code></pre>
<p>Obtenha o IP externo para o seu serviço Nginx:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE       SELECTOR
kubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP    39m       &lt;none&gt;
nginx        ClusterIP   10.102.160.47   <span class="highlight">seu_ip_público</span> 80/TCP     27m       app=nginx,tier=backend
php          ClusterIP   10.100.59.238   &lt;none&gt;        9000/TCP   34m       app=php,tier=backend
</code></pre>
<p>No seu navegador, visite seu servidor digitando <code>http://<span class="highlight">seu_ip_público</span></code>. Você verá a saída de <code>php_info()</code> e irá confirmar que seus serviços do Kubernetes estão funcionando.</p>

<h2 id="conclusão">Conclusão</h2>

<p>Neste guia, você <em>containerizou</em> os serviços PHP-FPM e Nginx para poder gerenciá-los independentemente. Essa abordagem não apenas melhorará a escalabilidade do seu projeto à medida que você cresce, mas também permitirá que você use os recursos com eficiência. Você também armazenou o código da sua aplicação em um volume para poder atualizar facilmente seus serviços no futuro.</p>
