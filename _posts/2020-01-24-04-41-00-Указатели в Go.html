---
layout: post
title: Указатели в Go
network: digitalocean
date: January 24, 2020 at 04:41AM
url: https://www.digitalocean.com/community/tutorials/understanding-pointers-in-go-ru
image: http://ifttt.com/images/no_image_card.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="Введение">Введение</h3>

<p>При написании программного обеспечения на Go вы создаете функции и методы. Данные передаются в эти функции в виде <em>аргументов</em>. Иногда функции требуется локальная копия данных, но при этом вы хотите, чтобы оригинал оставался без изменений. Например, если вы работаете в банке и у вас есть функция для вывода изменений баланса пользователя в зависимости от выбранного сберегательного плана, вам не нужно изменять баланс пользователя до выбора плана, а нужно просто использовать его в расчетах. Это называется <em>передачей по значению</em>, поскольку вы отправляете в функцию значение переменной, но не саму переменную.</p>

<p>В других случаях вы можете захотеть дать функции возможность изменения данных в исходной переменной. Например, если клиент банка вносит деньги на счет, функции депозита нужно дать доступ к фактическому балансу, а не к его копии. В этом случае вам не нужно отправлять в функцию сами данные, а нужно просто указать, где в памяти можно найти эти данные. Тип данных, называемый <em>указатель</em>, хранит адрес данных в памяти, но не сами данные. Адрес в памяти указывает функции, где можно найти данные, но не сообщает значение данных. Вы можете передать указатель в функцию вместо данных, и тогда функция изменит исходную переменную. Это называется <em>передачей по ссылке</em>, поскольку функции не передается значение переменной, а передается только ее расположение.</p>

<p>В этой статье мы расскажем о создании и использовании указателей для предоставления переменной доступа к пространству памяти.</p>

<h2 id="Определение-и-использование-указателей">Определение и использование указателей</h2>

<p>При использовании указателя на переменную нужно понять два разных элемента синтаксиса. Первый элемент называется амперсандом (<code>&amp;</code>). Если вы ставите амперсанд перед именем переменной, вы указываете, что хотите получить <em>адрес</em> или указатель для этой переменной. Второй элемент синтаксиса — звездочка (<code>*</code>) или оператор <em>разыменовывания</em>. При декларировании переменной указателя необходимо обеспечить соответствие имени переменной типу переменной, на которую указывает указатель, с префиксом <code>*</code>, примерно так:</p>
<pre class="code-pre "><code class="code-highlight language-go">var myPointer *int32 = &amp;someint
</code></pre>
<p>При этом создается указатель <code>myPointer</code> на переменную <code>int32</code>, который инициализирует указатель с адресом <code>someint</code>. Указатель не содержит переменную <code>int32</code>, а содержит только ее адрес.</p>

<p>Давайте рассмотрим указатель на <code>строку</code>. Следующий код декларирует значение строки и указатель на строку:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

func main() {
    var creature string = "shark"
    var pointer *string = &amp;creature

    fmt.Println("creature =", creature)
    fmt.Println("pointer =", pointer)
}

</code></pre>
<p>Запустите программу с помощью следующей команды:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go run main.go
</li></ul></code></pre>
<p>При запуске программы она выводит значение переменной, а также адрес, где хранится переменная (адрес указателя). Адрес в памяти представляет собой шестнадцатеричное число, которое не предназначено для чтения людьми. На практике адреса в памяти обычно не выводятся, и мы показываем его исключительно для иллюстрации. Поскольку каждая программа при запуске создается в собственном пространстве памяти, указатель будет разным при каждом запуске и будет отличаться от показанного здесь:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>creature = shark
pointer = 0xc0000721e0
</code></pre>
<p>Мы присвоим первой определяемой переменной имя <code>creature</code> и зададим ее равной <code>строке</code> со значением <code>shark</code>. Затем мы создадим другую переменную с именем <code>pointer</code>. Теперь мы зададим в качестве значения переменной <code>pointer</code> адрес переменной <code>creature</code>. Мы сохраним адрес значения в переменной, используя символ амперсанда (<code>&amp;</code>). Это означает, что переменная <code>pointer</code> хранит <strong>адрес</strong> переменной <code>creature</code>, а не ее реальное значение.</p>

<p>Поэтому, когда мы вывели значение <code>pointer</code>, мы получили значение <code>0xc0000721e0</code>, которое представляет собой адрес хранения переменной <code>creature</code> в компьютерной памяти.</p>

<p>Если вы хотите вывести значение переменной, на которую указывает переменная <code>pointer</code>, вам нужно <em>разыменовать</em>  эту переменную. В следующим коде используется оператор <code>*</code> для снятия ссылки на переменную <code>pointer</code> и получения его значения:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">
package main

import "fmt"

func main() {
    var creature string = "shark"
    var pointer *string = &amp;creature

    fmt.Println("creature =", creature)
    fmt.Println("pointer =", pointer)

    <span class="highlight">fmt.Println("*pointer =", *pointer)</span>
}
</code></pre>
<p>Если вы выполните этот код, вы увидите следующие результаты:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>creature = shark
pointer = 0xc000010200
*pointer = shark
</code></pre>
<p>Последняя добавленная нами строка убирает ссылку на переменную <code>pointer</code> и выводит значение, сохраненное по этому адресу.</p>

<p>Если вы хотите изменить значение, сохраненное в месте расположения переменной <code>pointer</code>, вы также можете использовать оператор снятия ссылки:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

func main() {
    var creature string = "shark"
    var pointer *string = &amp;creature

    fmt.Println("creature =", creature)
    fmt.Println("pointer =", pointer)

    fmt.Println("*pointer =", *pointer)

    <span class="highlight">*pointer = "jellyfish"</span>
    <span class="highlight">fmt.Println("*pointer =", *pointer)</span>
}

</code></pre>
<p>Запустите этот код, чтобы увидеть результаты:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>creature = shark
pointer = 0xc000094040
*pointer = shark
*pointer = jellyfish
</code></pre>
<p>Мы зададим значение, на которое ссылается переменная <code>pointer</code>, добавив звездочку (<code>*</code>) перед именем переменной, а затем зададим новое значение <code>jellyfish</code>. Как видите, при выводе значения разыменованной ссылки, сейчас она задана как <code>jellyfish</code>.</p>

<p>Возможно вы не поняли этого, но мы фактически изменили значение переменной <code>creature</code>. Это связано с тем, что переменная <code>pointer</code> фактически указывает на адрес переменной <code>creature</code>. Это означает, что если мы изменим значение, на которое указывает переменная <code>pointer</code>, мы также изменим значение переменной <code>creature</code>.</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

func main() {
    var creature string = "shark"
    var pointer *string = &amp;creature

    fmt.Println("creature =", creature)
    fmt.Println("pointer =", pointer)

    fmt.Println("*pointer =", *pointer)

    *pointer = "jellyfish"
    fmt.Println("*pointer =", *pointer)

    <span class="highlight">fmt.Println("creature =", creature)</span>
}
</code></pre>
<p>Результат выглядит следующим образом:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>creature = shark
pointer = 0xc000010200
*pointer = shark
*pointer = jellyfish
creature = jellyfish
</code></pre>
<p>Хотя этот код иллюстрирует работу указателя, это необычный способ использования указателей в Go. Их полезнее использовать при определении аргументов функций и возврата значений или при определении методов с использованием пользовательских типов. Давайте посмотрим, как использовать указатели с функциями для общего доступа к переменной.</p>

<p>Помите, что мы выводим значение <code>pointer</code>, чтобы проиллюстрировать, что это указатель. На практике значение указателя используется только для получения или обновления этого значения.</p>

<h2 id="Приемники-указателя-функции">Приемники указателя функции</h2>

<p>При записи функции можно определить передаваемые аргументы по <em>значению</em> или посредством <em>ссылки</em>. Передача <em>значения</em> означает, что копия значения отправляется в функцию и любые изменения аргумента в этой функции влияют <em>только</em> на эту функцию, но не на источник. Однако передача посредством <em>ссылки</em> означает, что при передаче указателя на этот аргумент вы сможете изменить значение изнутри функции и изменить значение исходной переменной, которая была передана. Дополнительную информацию об определении функций можно найти в документе <a href="">Определение и вызов функций в Go</a>.</p>

<p>Решение о передаче указателя или отправке значения зависит от того, требуется ли изменить это значение. Если вы не хотите, чтобы значение изменялось, отправьте его как значение. Если вы хотите, чтобы функция, куда вы передаете переменную, могла изменять эту переменную, вы должны передавать ее как указатель.</p>

<p>Чтобы увидеть разницу, вначале рассмотрим функцию, передающую аргумент по <code>значению</code>:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

type Creature struct {
    Species string
}

func main() {
    var creature Creature = Creature{Species: "shark"}

    fmt.Printf("1) %+v\n", creature)
    changeCreature(creature)
    fmt.Printf("3) %+v\n", creature)
}

func changeCreature(creature Creature) {
    creature.Species = "jellyfish"
    fmt.Printf("2) %+v\n", creature)
}

</code></pre>
<p>Результат выглядит следующим образом:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>1) {Species:shark}
2) {Species:jellyfish}
3) {Species:shark}
</code></pre>
<p>Вначале мы создали пользовательский тип с именем <code>Creature</code>. Он содержит одно поле с именем <code>Species</code>, которое представляет собой строку. В функции <code>main</code> мы создали экземпляр нового типа с именем <code>creature</code> и задали для поля <code>Species</code> значение <code>shark</code>. Затем мы вывели переменную для отображения текущего значения, сохраненного в переменной <code>creature</code>.</p>

<p>Далее мы вызвали <code>changeCreature</code> и передали копию переменной <code>creature</code>.</p>

<p>Функция <code>changeCreature</code> принимает один аргумент с именем <code>creature</code>, который относится к ранее определенному типу <code>Creature</code>. Затем мы изменяем значение поля <code>Species</code> на <code>jellyfish</code> и выводим его. Обратите внимание, что в функции <code>changeCreature</code> значение <code>Species</code> теперь <code>jellyfish</code>, и функция выводит <code>2) {Species:jellyfish}</code>. Это связано с тем, что нам разрешено изменять значение в составе функции.</p>

<p>Однако когда последняя строка функции <code>main</code> распечатывает значение <code>creature</code>, значение <code>Species</code> сохраняется как <code>shark</code>. Значение осталось без изменений, потому что мы передали переменную по_ значению_. Это означает, что копия данного значения была создана в памяти и передана в функцию <code>changeCreature</code>. Это позволяет нам иметь функцию, которая сможет изменять любые передаваемые в нее аргументы, но не сможет влиять на переменные за пределами функции.</p>

<p>Затем измените функцию <code>changeCreature</code> так, чтобы она принимала аргумент по <em>ссылке</em>. Для этого мы можем изменить тип <code>creature</code> на указатель, используя оператор звездочка (<code>*</code>). Вместо передачи <code>creature</code> мы передаем указатель на <code>creature</code> или <code>*creature</code>. В предыдущем примере <code>creature</code> представляет собой <code>структуру</code>, где <code>Species</code> имеет значение <code>shark</code>. <code>*creature</code> является указателем, а не структурой, и его значение является адресом в памяти, и именно это мы передаем в функцию <code>changeCreature()</code>.</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

type Creature struct {
    Species string
}

func main() {
    var creature Creature = Creature{Species: "shark"}

    fmt.Printf("1) %+v\n", creature)
    changeCreature(<span class="highlight">&amp;</span>creature)
    fmt.Printf("3) %+v\n", creature)
}

func changeCreature(creature <span class="highlight">*</span>Creature) {
    creature.Species = "jellyfish"
    fmt.Printf("2) %+v\n", creature)
}
</code></pre>
<p>Запустите этот код, чтобы увидеть результат:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>1) {Species:shark}
2) &amp;{Species:jellyfish}
3) {Species:jellyfish}
</code></pre>
<p>Обратите внимание, что когда мы теперь изменяем значение <code>Species</code> на <code>jellyfish</code> в функции <code>changeCreature</code>, она  также изменяет первоначальное значение, которое было определено в функции <code>main</code>. Это связано с тем, что мы передали переменную <code>creature</code> посредством <em>ссылки</em>, дающей доступ к исходному значению и возможность его изменения.</p>

<p>Если вы хотите, чтобы функция могла изменять значение, его нужно передать посредством ссылки. При передаче посредством ссылки передается не переменная, а указатель на эту переменную.</p>

<p>Иногда для указателя может не быть определенного фактического значения. В таких случаях в программе может возникнуть <a href="https://www.digitalocean.com/community/tutorials/handling-panics-in-go">паника</a>. Посмотрим, как это происходит, и как подготовиться к этой потенциальной проблеме.</p>

<h2 id="Нулевые-указатели">Нулевые указатели</h2>

<p>Все переменные в Go имеют <a href="https://www.digitalocean.com/community/tutorials/how-to-use-variables-and-constants-in-go#zero-values">нулевое значение</a>. Это относится и к указателям. Если вы декларировали указатель на тип, но не назначили ему значения, ему будет присвоено нулевое значение <code>nil</code>. <code>nil</code> — это способ сказать, что <code>ничего не было инициализировано.</code></p>

<p>В следующей программе мы определяем указатель на тип <code>Creature</code>, но не создаем экземпляр <code>Creature</code> и не назначаем его адрес переменной указателя <code>creature</code>. Он будет иметь значение <code>nil</code>, и мы не сможем ссылаться ни на какие поля или методы, определенные для типа <code>Creature</code>:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

type Creature struct {
    Species string
}

func main() {
    var creature *Creature

    fmt.Printf("1) %+v\n", creature)
    changeCreature(creature)
    fmt.Printf("3) %+v\n", creature)
}

func changeCreature(creature *Creature) {
    creature.Species = "jellyfish"
    fmt.Printf("2) %+v\n", creature)
}
</code></pre>
<p>Результат выглядит следующим образом:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>1) &lt;nil&gt;
panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0x8 pc=0x109ac86]

goroutine 1 [running]:
main.changeCreature(0x0)
        /Users/corylanou/projects/learn/src/github.com/gopherguides/learn/_training/digital-ocean/pointers/src/nil.go:18 +0x26
    main.main()
            /Users/corylanou/projects/learn/src/github.com/gopherguides/learn/_training/digital-ocean/pointers/src/nil.go:13 +0x98
        exit status 2
</code></pre>
<p>При запуске программы она выводит значение переменной <code>creature</code>, и это значение <code>&lt;nil&gt;</code>. Затем мы можем вызвать функцию <code>changeCreature</code>, и когда эта функция пытается задать значение поля <code>Species</code>, происходит <em>паника</em>. Это связано с тем, что ни один экземпляр переменной фактически не был создан. Поэтому программе негде хранить значение, и происходит паника.</p>

<p>Чтобы предотвратить генерацию паники в программе, при получении аргумента в качестве указателя в Go обычно следует проверить, имеет ли он значение nil, прежде чем выполнять с ним какие-либо операции.</p>

<p>Этот подход обычно применяется для проверки <code>nil</code>:</p>
<pre class="code-pre "><code class="code-highlight language-go">if someVariable == nil {
    // print an error or return from the method or fuction
}
</code></pre>
<p>Фактически вам нужно убедиться, что в вашу функцию или метод не передавался указатель <code>nil</code>. При обнаружении такого указателя обычно нужно, чтобы программа возвращалась к предыдущему шагу или выводила сообщение об ошибке передачи неверного аргумента в функцию или метод. В следующем коде демонстрируется проверка на <code>nil</code>:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

type Creature struct {
    Species string
}

func main() {
    var creature *Creature

    fmt.Printf("1) %+v\n", creature)
    changeCreature(creature)
    fmt.Printf("3) %+v\n", creature)
}

func changeCreature(creature *Creature) {
    <span class="highlight">if creature == nil {</span>
        <span class="highlight">fmt.Println("creature is nil")</span>
        <span class="highlight">return</span>
    <span class="highlight">}</span>

    creature.Species = "jellyfish"
    fmt.Printf("2) %+v\n", creature)
}
</code></pre>
<p>Мы добавили проверку в <code>changeCreature</code>, чтобы посмотреть, имеет ли аргумент <code>creature</code> значение <code>nil</code>. Если это так, программа выводит сообщение <code>creature is nil</code> и выходит из функции. Если это не так, программа изменяет значение поля <code>Species</code>. Если мы запустим программу, результат будет выглядеть следующим образом:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>1) &lt;nil&gt;
creature is nil
3) &lt;nil&gt;
</code></pre>
<p>Обратите внимание, что хотя значение <code>nil</code> для переменной <code>creature</code> может присутствовать, паники больше нет, поскольку мы проверяем наличие такого сценария.</p>

<p>Наконец, если мы создадим экземпляр типа <code>Creature</code> и назначим его переменной <code>creature</code>, программа изменит значение ожидаемым образом:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

type Creature struct {
    Species string
}

func main() {
    var creature *Creature
    <span class="highlight">creature = &amp;Creature{Species: "shark"}</span>

    fmt.Printf("1) %+v\n", creature)
    changeCreature(creature)
    fmt.Printf("3) %+v\n", creature)
}

func changeCreature(creature *Creature) {
    if creature == nil {
        fmt.Println("creature is nil")
        return
    }

    creature.Species = "jellyfish"
    fmt.Printf("2) %+v\n", creature)
}
</code></pre>
<p>Теперь у нас имеется экземпляр типа <code>Creature</code>, программа будет выполняться надлежащим образом, и мы получим ожидаемый результат:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>1) &amp;{Species:shark}
2) &amp;{Species:jellyfish}
3) &amp;{Species:jellyfish}
</code></pre>
<p>При работе с указателями существует вероятность паники в программе. Чтобы избежать паники, следует посмотреть, имеет ли указатель значение <code>nil</code>, прежде чем пытаться получить доступ к любым полям или методам, которые он определяет.</p>

<p>Далее мы посмотрим, как использование указателей и значений влияет на определение методов типа.</p>

<h2 id="Получатели-указателей-методов">Получатели указателей методов</h2>

<p><code>Приемник</code> в go — это аргумент, определенный в декларации метода. Посмотрите на следующий код:</p>
<pre class="code-pre "><code class="code-highlight language-go">type Creature struct {
    Species string
}

func (<span class="highlight">c Creature</span>) String() string {
    return c.Species
}
</code></pre>
<p>Приемником в этом методе является <code>c Creature</code>. Это показывает, что экземпляр <code>c</code> имеет тип <code>Creature</code>, и что вы будете ссылаться на этот тип через эту переменную экземпляра.</p>

<p>Поведение функций отличается в зависимости от того, отправляете вы аргумент в качестве указателя или в качестве значения. Поведение методов также отличается. Основное отличие заключается в том, что если вы определите метод с приемником значения, вы не сможете вносить изменения в экземпляр этого типа, где был определен метод.</p>

<p>Иногда вам может понадобиться, чтобы ваш метод мог обновлять экземпляры используемой вами переменной. Для этого нужно сделать приемник указателем.</p>

<p>Добавим метод <code>Reset</code> в наш тип <code>Creature</code>. Этот метод будет задавать для поля <code>Species</code> пустую строку:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

type Creature struct {
    Species string
}

func (c Creature) Reset() {
    c.Species = ""
}

func main() {
    var creature Creature = Creature{Species: "shark"}

    fmt.Printf("1) %+v\n", creature)
    creature.Reset()
    fmt.Printf("2) %+v\n", creature)
}
</code></pre>
<p>Если мы запустим программу, результат будет выглядеть так:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>1) {Species:shark}
2) {Species:shark}
</code></pre>
<p>Обратите внимание, что хотя в методе <code>Reset</code> мы задали для <code>Species</code> пустую строку, при выводе значения переменной <code>creature</code> в функции <code>main</code> это поле по-прежнему имеет значение <code>shark</code>. Это связано с тем, что мы определили метод <code>Reset</code> как имеющий приемник <code>значения</code>. Это означает, что у метода будет доступ только к <em>копии</em> переменной <code>creature</code>.</p>

<p>Если мы захотим изменить экземпляр переменной <code>creature</code> в методах, нам нужно будет определить их как имеющие приемник <code>указателя</code>:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

type Creature struct {
    Species string
}

func (c <span class="highlight">*</span>Creature) Reset() {
    c.Species = ""
}

func main() {
    var creature Creature = Creature{Species: "shark"}

    fmt.Printf("1) %+v\n", creature)
    creature.Reset()
    fmt.Printf("2) %+v\n", creature)
}
</code></pre>
<p>Обратите внимание, что мы добавили звездочку (<code>*</code>) перед названием типа <code>Creature</code> при определении метода <code>Reset</code>. Это означает, что экземпляр <code>Creature</code>, который передается в метод <code>Reset</code>, теперь является указателем, и когда мы изменим его, это повлияет на оригинальный экземпляр соответствующей переменной.</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>1) {Species:shark}
2) {Species:}
</code></pre>
<p>Теперь <code>Reset</code> изменил значение поля <code>Species</code>.</p>

<h2 id="Заключение">Заключение</h2>

<p>Определение функции или метода как принимающего <code>значения</code> или <code>ссылки</code> определяет, какие компоненты вашей программы могут изменять другие компоненты. Контроль над временем и возможностью изменения переменных позволяет создавать более надежное и прогнозируемое программное обеспечение. Вы узнали многое об указателях и теперь можете видеть, как они используются в интерфейсах.</p>
