---
layout: post
title: Функция init в Go
network: digitalocean
date: January 24, 2020 at 04:41AM
url: https://www.digitalocean.com/community/tutorials/understanding-init-in-go-ru
image: http://ifttt.com/images/no_image_card.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="Введение">Введение</h3>

<p>В Go заданнная функция <code>init()</code> выделяет элемент кода, который запускатся до любой другой части вашего пакета. Этот код запускается сразу же после <a href="https://www.digitalocean.com/community/tutorials/importing-packages-in-go">импорта пакета</a>, и его можно использовать при необходимости инициализации приложения в определенном состоянии, например, если для запуска  приложения требуется определенная конфигурация или набор ресурсов. Также используется при <em>импорте побочных эффектов</em>, то есть при применении методики установки состояния программы посредством импорта определенного пакета. Часто используется для <code>регистрации</code> одного пакета в другом, чтобы программа рассматривала правильный код для этой задачи.</p>

<p>Хотя <code>init()</code> представляет собой полезный инструмент, иногда он делает код менее удобочитаемым, поскольку трудный в поиске экземпляр <code>init()</code> серьезно влияет на порядок выполнения кода. В связи с этим, начинающим разработчикам Go важно понимать все аспекты этой функции, чтобы они использовали <code>init()</code> в читаемой форме при написании кода.</p>

<p>В этом обучающем руководстве вы узнаете, как <code>init()</code> используется для настройки и инициализации переменных определенных пакетов, разовых вычислений и регистрации пакетов для использования внутри других пакетов.</p>

<h2 id="Предварительные-требования">Предварительные требования</h2>

<p>Для некоторых из приведенных в этой статье примеров вам потребуется следующее:</p>

<ul>
<li>Рабочее пространство Go, настроенное согласно <a href="https://www.digitalocean.com/community/tutorial_series/how-to-install-and-set-up-a-local-programming-environment-for-go">руководству по установке Go и настройке локальной среды для разработки</a>. В настоящем обучающем модуле будет использоваться следующая структура файлов:</li>
</ul>
<pre class="code-pre "><code langs="">.
├── bin
│
└── src
    └── github.com
        └── gopherguides
</code></pre>
<h2 id="Декларирование-init">Декларирование <code>init()</code></h2>

<p>Каждый раз, когда вы декларируете функцию <code>init()</code>, Go загружает и запускает ее прежде всех остальных элементов этого пакета. Чтобы продемонстрировать это, в данном разделе мы подробно покажем определение функции <code>init()</code> и ее влияние на выполнение пакета.</p>

<p>Вначале рассмотрим следующий пример кода без функции <code>init()</code>:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

var weekday string

func main() {
    fmt.Printf("Today is %s", weekday)
}
</code></pre>
<p>В этой программе мы декларировали глобальную <a href="https://www.digitalocean.com/community/tutorials/how-to-use-variables-and-constants-in-go">переменную</a> с именем <code>weekday</code>. По умолчанию значение <code>weekday</code> представляет собой пустую строку.</p>

<p>Запустим этот код:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go run main.go
</li></ul></code></pre>
<p>Поскольку значение <code>weekday</code> пустое, при запуске программы мы увидим следующее:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Today is
</code></pre>
<p>Мы можем заполнить пустую переменную, используя функцию <code>init()</code> для инициализации значения <code>weekday</code> как текущего дня. Добавьте следующие выделенные строки в файл <code>main.go</code>:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code langs="">package main

import <span class="highlight">(</span>
    "fmt"
    <span class="highlight">"time"</span>
<span class="highlight">)</span>

var weekday string

<span class="highlight">func init() {</span>
    <span class="highlight">weekday = time.Now().Weekday().String()</span>
<span class="highlight">}</span>

func main() {
    fmt.Printf("Today is %s", weekday)
}
</code></pre>
<p>В этом коде мы импортировали и использовали пакет <code>time</code> для получения текущего дня недели (<code>Now(). Weekday(). String()</code>), а затем использовали <code>init()</code> для инициализации <code>weekday</code> с этим значением.</p>

<p>Теперь при запуске программы она выводит текущий день недели:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Today is Monday
</code></pre>
<p>Хотя это показывает принцип работы функции <code>init()</code>, гораздо чаще <code>init()</code> используется при импорте пакета. Это может быть полезно, если вам требуется выполнить в пакете определенные задачи по настройке, прежде чем использовать этот пакет. Чтобы продемонстрировать это, создадим программу, которая потребует определенной инициализации для обеспечения требуемой работы пакета.</p>

<h2 id="Инициализация-пакетов-при-импорте">Инициализация пакетов при импорте</h2>

<p>Вначале мы напишем код, который выбирает случайное существо из <a href="https://www.digitalocean.com/community/tutorials/understanding-arrays-and-slices-in-go">среза</a> и выводит его. Однако мы не будем использовать <code>init()</code>в начальной программе. Это лучше покажет стоящую перед нами проблему и возможность ее решения с помощью функции <code>init()</code>.</p>

<p>Создайте в каталоге <code>src/github.com/gopherguides/</code> папку с именем <code>creature</code> с помощью следующей команды:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir creature
</li></ul></code></pre>
<p>Создайте в папке <code>creature</code> файл с именем <code>creature.go</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano creature/creature.go
</li></ul></code></pre>
<p>Добавьте в этот файл следующее содержание:</p>
<div class="code-label " title="creature.go">creature.go</div><pre class="code-pre "><code class="code-highlight language-go">package creature

import (
    "math/rand"
)

var creatures = []string{"shark", "jellyfish", "squid", "octopus", "dolphin"}

func Random() string {
    i := rand.Intn(len(creatures))
    return creatures[i]
}
</code></pre>
<p>Этот файл определяет переменную с именем <code>creatures</code>, для которой в качестве значений инициализирован набор морских существ. Также она имеет <a href="https://www.digitalocean.com/community/tutorials/understanding-package-visibility-in-go#exported-and-unexported-items">экспортируемую</a> функцию <code>Random</code>, которая выводит случайное значение переменной <code>creatures</code>.</p>

<p>Сохраните и закройте этот файл.</p>

<p>Теперь создайте пакет <code>cmd</code>, который мы используем для записи функции <code>main()</code> и вызова пакета <code>creature</code>.</p>

<p>На том же уровне файла, где мы создали папку <code>creature</code>, создайте папку <code>cmd</code> с помощью следующей команды:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir cmd
</li></ul></code></pre>
<p>Создайте в папке <code>cmd</code> файл с именем <code>main.go</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano cmd/main.go
</li></ul></code></pre>
<p>Добавьте в файл следующие строчки:</p>
<div class="code-label " title="cmd/main.go">cmd/main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import (
    "fmt"

    "github.com/gopherguides/creature"
)

func main() {
    fmt.Println(creature.Random())
    fmt.Println(creature.Random())
    fmt.Println(creature.Random())
    fmt.Println(creature.Random())
}
</code></pre>
<p>Здесь мы импортировали пакет <code>creature</code> и использовали в функции <code>main()</code> функцию <code>creature.Random()</code>, чтобы получить случайное существо и вывести его четыре раза.</p>

<p>Сохранение и выход из <code>main.go</code>.</p>

<p>Теперь у нас написана вся программа. Однако перед запуском этой программы нам также потребуется создать несколько файлов конфигурации, чтобы обеспечить правильную работу нашего кода. Go использует <a href="https://blog.golang.org/using-go-modules">Go Modules</a> для настройки зависимостей пакетов при импорте ресурсов. Эти модули представляют собой файлы конфигурации в каталоге вашего пакета, которые указывают компилятору, откуда импортировать пакеты. Хотя изучение модулей не входит в состав настоящей статьи, мы можем написать несколько строк конфигурации, чтобы этот пример работал локально.</p>

<p>Создайте в каталоге <code>cmd</code> файл с именем <code>go.mod</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano cmd/go.mod
</li></ul></code></pre>
<p>После открытия файла добавьте в него следующий код:</p>
<div class="code-label " title="cmd/go.mod">cmd/go.mod</div><pre class="code-pre "><code langs="">module github.com/gopherguides/cmd
 replace github.com/gopherguides/creature =&gt; ../creature
</code></pre>
<p>Первая строка файла указывает компилятору, что созданный нами пакет <code>cmd</code> на самом деле представляет собой пакет <code>github.com/gopherguides/cmd</code>. Вторая строка указывает компилятору, что каталог <code>github.com/gopherguides/creature</code> можно найти на локальном диске в каталоге <code>../creature</code>.</p>

<p>Сохраните и закройте файл. Затем создайте файл <code>go.mod</code> в каталоге <code>creature</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano creature/go.mod
</li></ul></code></pre>
<p>Добавьте в файл следующую строчку кода:</p>
<div class="code-label " title="creature/go.mod">creature/go.mod</div><pre class="code-pre "><code langs=""> module github.com/gopherguides/creature
</code></pre>
<p>Это говорит компилятору, что созданный нами пакет <code>creature</code> на самом деле является пакетом <code>github.com/gopherguides/creature</code>. Без этого пакет <code>cmd</code> не будет знать, откуда импортировать этот пакет.</p>

<p>Сохраните и закройте файл.</p>

<p>Теперь у вас должны быть следующая структура каталогов и расположение файлов:</p>
<pre class="code-pre "><code langs="">├── cmd
│   ├── go.mod
│   └── main.go
└── creature
    ├── go.mod
    └── creature.go
</code></pre>
<p>Мы завершили настройку и теперь можем запустить программу <code>main</code> с помощью следующей команды:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go run cmd/main.go
</li></ul></code></pre>
<p>Это даст нам следующее:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>jellyfish
squid
squid
dolphin
</code></pre>
<p>При запуске этой программы мы получили четыре значения и вывели их. Если мы запустим программу несколько раз, результаты <strong>всегда</strong> будут одинаковыми, хотя ожидается случайный результат. Это связано с тем, что пакет <code>rand</code> создает псевдослучайные числа, постоянно дающие один и тот же результат для одного и того же начального состояния. Чтобы получить действительно случайное число, мы можем задать <em>начальное случайное число</em> для пакета или задать изменяющийся источник, чтобы при каждом запуске программы состояние было разным. В Go обычно используется текущее время в качестве <code>начального случайного числа</code> для пакета rand.</p>

<p>Поскольку нам нужно, чтобы пакет <code>creature</code> работал с функцией случайных чисел, откроем этот файл:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano creature/creature.go
</li></ul></code></pre>
<p>Добавьте в файл <code>creature.go</code> следующие выделенные строки:</p>
<div class="code-label " title="creature/creature.go">creature/creature.go</div><pre class="code-pre "><code langs="">package creature

import (
    "math/rand"
    <span class="highlight">"time"</span>
)

var creatures = []string{"shark", "jellyfish", "squid", "octopus", "dolphin"}

func Random() string {
    <span class="highlight">rand.Seed(time.Now().UnixNano())</span>
    i := rand.Intn(len(creatures))
    return creatures[i]
}
</code></pre>
<p>В этом коде мы импортировали пакет <code>time</code> и использовали <code>Seed()</code> для использования текущего времени в качестве начального случайного числа. Сохраните и закройте файл.</p>

<p>Теперь при запуске программы мы будем получать действительно случайный результат:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go run cmd/main.go
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div><span class="highlight">jellyfish</span>
<span class="highlight">octopus</span>
<span class="highlight">shark</span>
<span class="highlight">jellyfish</span>
</code></pre>
<p>При каждом запуске программы результаты будут оставаться случайными. Однако эта реализация кода также не идеальна, поскольку при каждом вызове <code>creature.Random()</code> повторно задается начальное случайное число для пакета <code>rand</code> посредством вызова функции <code>rand.Seed(time.Now(). UnixNano())</code> еще раз. Повторное начальное случайное число может совпадать с предыдущим, если время на внутренних часах не изменилось. Это может вызвать повторы шаблонов случайных чисел или увеличение времени обработки в связи с ожиданием смены времени на часах.</p>

<p>Для решения этой проблемы мы можем использовать функцию <code>init()</code>. Обновим файл <code>creature.go</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano creature/creature.go
</li></ul></code></pre>
<p>Добавьте следующие строчки кода:</p>
<div class="code-label " title="creature/creature.go">creature/creature.go</div><pre class="code-pre "><code langs="">package creature

import (
    "math/rand"
    "time"
)

var creatures = []string{"shark", "jellyfish", "squid", "octopus", "dolphin"}

<span class="highlight">func init() {</span>
    <span class="highlight">rand.Seed(time.Now().UnixNano())</span>
<span class="highlight">}</span>

func Random() string {
    i := rand.Intn(len(creatures))
    return creatures[i]
}
</code></pre>
<p>Добавление функции <code>init()</code> указывает компилятору, что при импорте пакета <code>creature</code> необходимо запустить функцию <code>init()</code> один раз и задать начальное случайное число для генерирования случайных чисел. Так нам не придется лишний раз выполнять код. Если мы запустим программу, мы по-прежнему будем получать случайные результаты:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go run cmd/main.go
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div><span class="highlight">dolphin</span>
<span class="highlight">squid</span>
<span class="highlight">dolphin</span>
<span class="highlight">octopus</span>
</code></pre>
<p>В этом разделе мы показали, как использование функции <code>init()</code> может обеспечить проведение правильных расчетов или операций инициализации перед использованием пакета. Далее мы рассморим использование нескольких выражений <code>init()</code> в пакете.</p>

<h2 id="Использование-нескольких-экземпляров-init">Использование нескольких экземпляров <code>init()</code></h2>

<p>В отличие от функции <code>main()</code>, которую можно декларировать только один раз, функцию <code>init()</code> можно декларировать в пакете много раз. Однако при использовании нескольких экземпляров функции <code>init()</code> может быть сложно понять, какой из них имеет приоритет перед другими. В этом разделе мы покажем, как контролировать несколько выражений <code>init()</code>.</p>

<p>В большинстве случаев функции <code>init()</code> выполняются в том порядке, в каком они содержатся в программе. Рассмотрим в качестве примера следующий код:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

func init() {
    fmt.Println("First init")
}

func init() {
    fmt.Println("Second init")
}

func init() {
    fmt.Println("Third init")
}

func init() {
    fmt.Println("Fourth init")
}

func main() {}
</code></pre>
<p>Если мы запустим программу с помощью следующей команды:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go run main.go
</li></ul></code></pre>
<p>Мы получим следующий результат:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>First init
Second init
Third init
Fourth init
</code></pre>
<p>Обратите внимание, что каждое выражение <code>init()</code> выполняется в том порядке, в каком оно поступает в компилятор. Однако порядок вызова функций <code>init()</code> может быть не так легко определить.</p>

<p>Рассмотрим более сложную структуру пакета, где у нас имеется несколько файлов, для каждого из которых декларирована собственная функция <code>init()</code>. Для иллюстрации мы создадим программу, передающую переменную с именем <code>message</code> и выводящую ее.</p>

<p>Удалите каталоги <code>creature</code> и <code>cmd</code> и их содержимое из предыдущего раздела и замените их следующими каталогами и структурой файлов:</p>
<pre class="code-pre "><code langs="">├── cmd
│   ├── a.go
│   ├── b.go
│   └── main.go
└── message
    └── message.go
</code></pre>
<p>Теперь добавим содержимое каждого файла. В файле <code>a.go</code> добавьте следующие строчки:</p>
<div class="code-label " title="cmd/a.go">cmd/a.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import (
    "fmt"

    "github.com/gopherguides/message"
)

func init() {
    fmt.Println("a -&gt;", message.Message)
}
</code></pre>
<p>Этот файл содержит одну функцию <code>init()</code>, которая выводит значение <code>message.Message</code> из пакета <code>message</code>.</p>

<p>Добавьте следующие строки в файл <code>b.go</code>:</p>
<div class="code-label " title="cmd/b.go">cmd/b.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import (
    "fmt"

    "github.com/gopherguides/message"
)

func init() {
    message.Message = "Hello"
    fmt.Println("b -&gt;", message.Message)
}
</code></pre>
<p>В файле <code>b.go</code> имеется одна функция <code>init()</code>, которая задает для <code>message.Message</code> значение <code>Hello</code> и выводит его.</p>

<p>Создадим файл <code>main.go</code>, который будет выглядеть следующим образом:</p>
<div class="code-label " title="cmd/main.go">cmd/main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

func main() {}
</code></pre>
<p>Этот файл ничего не делает, но предоставляет начальную точку для запуска программы.</p>

<p>В заключение создайте файл <code>message.go</code> как показано здесь:</p>
<div class="code-label " title="message/message.go">message/message.go</div><pre class="code-pre "><code class="code-highlight language-go">package message

var Message string
</code></pre>
<p>Наш пакет <code>message</code> декларирует экспортированную переменную <code>Message</code>.</p>

<p>Для запуска программы выполните следующую команду в каталоге <code>cmd</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go run *.go
</li></ul></code></pre>
<p>Поскольку в папке <code>cmd</code> имеется несколько файлов Go, составляющих пакет <code>main</code>, нам нужно указать компилятору, что все файлы <code>.go</code> в папке <code>cmd</code> должны быть скомпилированы. Использование <code>*.go</code> указывает компилятору на необходимость загрузить все файлы из папки <code>cmd</code>, которые заканчиваются на <code>.go</code>. Если мы отправим команду <code>go run main.go</code>, программа не будет компилироваться, поскольку она не увидит код в файлах <code>a.go</code> и <code>b.go</code>.</p>

<p>Результат будет выглядеть следующим образом:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>a -&gt;
b -&gt; Hello
</code></pre>
<p>Согласно спецификации <a href="https://golang.org/ref/spec#Package_initialization">инициализации пакетов</a> в языке Go, при наличии в пакете нескольких файлов они обрабатываются в алфавитном порядке. В связи с этим, когда мы первый раз распечатали <code>message.Message</code> из <code>a.go</code>, значение было пустым. Значение не было инициализировано до запуска функции <code>init()</code> из <code>b.go</code>.</p>

<p>Если бы мы изменили имя файла с <code>a.go</code> на <code>c.go</code>, результат был бы другим:</p>
<pre class="code-pre "><code class="code-highlight language-go"><div class="secondary-code-label " title="Output">Output</div>b -&gt; Hello
a -&gt; Hello
</code></pre>
<p>Теперь компилятор вначале получает <code>b.go</code> и значение <code>message.Message</code> уже инициализировано как <code>Hello</code> при появлении функции <code>init()</code> в <code>c.go</code>.</p>

<p>Такое поведение может вызвать проблемы при выполнении кода. При разработке программного обеспечения имена файлов часто меняются, и, в связи с особенностями функции <code>init()</code>, изменение имен файлов может изменить последовательность обработки функций <code>init()</code>. Это может привести к нежелательному изменению выводимых программой результатов. Чтобы обеспечить стабильное поведение при инициализации, рекомендуется при сборке указывать компилятору несколько файлов из одного пакета в алфавитном порядке. Чтобы обеспечить загрузку всех функций <code>init()</code> по порядку, можно декларировать все эти функции в одном файле. Это предотвратит изменение порядка даже в случае изменения имен файлов.</p>

<p>Помимо обеспечения порядка выполнения функций <code>init()</code>, вам также следует избегать управления состояниями в пакете с помощью <em>глобальных переменных</em>, т. е. переменных, которые доступны во всем пакете. В предыдущей программе переменная <code>message.Message</code> была доступна всему пакету и поддерживала состояние программы. В связи с таким доступом, выражения <code>init()</code> могли изменять переменную и снижать прогнозируемость работы программы. Чтобы избежать этого, попробуйте работать с переменными в контролируемых пространствах с минимальным доступом, обеспечивающим возможность работы программы.</p>

<p>Итак, в одном пакете может быть несколько деклараций <code>init()</code>. Однако это может создать нежелательные эффекты и сделать программу более сложной для чтения или осложнить прогнозирование ее работы. Если не использовать несколько выражений <code>init()</code> или объединять их в одном файле, поведение программы не изменится в случае перемещения файлов или смены имен файлов.</p>

<p>Теперь посмотрим, как функция <code>init()</code> используется для импорта с побочными эффектами.</p>

<h2 id="Использование-init-для-побочных-эффектов">Использование <code>init()</code> для побочных эффектов</h2>

<p>Иногда в Go требуется импортировать пакет не ради его содержимого, но ради побочных эффектов, возникающих при импорте пакета. Часто это означает, что в импортируемом коде содержится выражение <code>init()</code>, выполняемое перед любым другим кодом, что позволяет разработчику изменять состояние программы при запуске. Такая методика называется <em>импортированием для побочного эффекта</em>.</p>

<p>Импортирование для побочного эффекта обычно используется для функции <em>регистрации</em> в коде, чтобы пакет знал, какую часть кода нужно использовать вашей программе. Например, в <a href="https://golang.org/pkg/image/">пакете <code>image</code></a>функция <code>image.Decode</code> должна знать, какой формат она пытается декодировать (<code>jpg</code>, <code>png</code>, <code>gif</code> и т. д.), прежде чем ее можно будет выполнить. Для этого можно предварительно импортировать определенную программу с побочным эффектом выражения <code>init()</code>.</p>

<p>Допустим, вы пытаетесь использовать <code>image.Decode</code> в файле <code>.png</code> со следующим фрагментом кода:</p>
<div class="code-label " title="Sample Decoding Snippet">Sample Decoding Snippet</div><pre class="code-pre "><code class="code-highlight language-go">. . .
func decode(reader io.Reader) image.Rectangle {
    m, _, err := image.Decode(reader)
    if err != nil {
        log.Fatal(err)
    }
    return m.Bounds()
}
. . .
</code></pre>
<p>Программа с этим кодом будет скомпилирована, однако при попытке декодирования изображения <code>png</code> мы получим сообщение об ошибке.</p>

<p>Для устранения этой проблемы нужно предварительно зарегистрировать формат изображения для <code>image.Decode</code>. К счастью, пакет <code>image/png</code> содержит следующее выражение <code>init()</code>:</p>
<div class="code-label " title="image/png/reader.go">image/png/reader.go</div><pre class="code-pre "><code class="code-highlight language-go">func init() {
    image.RegisterFormat("png", pngHeader, Decode, DecodeConfig)
}
</code></pre>
<p>Поэтому, если мы импортируем <code>image/png</code> в сниппет для декодировки, функция <code>image.RegisterFormat()</code> пакета <code>image/png</code> будет запущена до любого нашего кода:</p>
<div class="code-label " title="Sample Decoding Snippet">Sample Decoding Snippet</div><pre class="code-pre "><code langs="">. . .
<span class="highlight">import _ "image/png"</span>
. . .

func decode(reader io.Reader) image.Rectangle {
    m, _, err := image.Decode(reader)
    if err != nil {
        log.Fatal(err)
    }
    return m.Bounds()
}
</code></pre>
<p>Эта функция задаст состояние и зарегистрирует необходимость использования версии <code>png</code> функции <code>image.Decode()</code>. Эта регистрация происходит в качестве побочного эффекта импорта <code>image/png</code>.</p>

<p>Возможно вы заметили <a href="https://golang.org/ref/spec#Blank_identifier">пустой идентификатор</a> (<code>_</code>) перед <code>"image/png"</code>. Он необходим, потому что Go не позволяет импортировать пакеты, которые не используются в программе. При указании пустого идентификатора значение импорта отбрасывается так, что действует только побочный эффект импорта. Это означает, что хотя мы не вызываем пакет <code>image/png</code> в нашем коде, мы можем импортировать его ради побочного эффекта.</p>

<p>Важно понимать, когда нужно импортировать пакет ради его побочного эффекта. Без надлежащей регистрации существует вероятность, что программа скомпилируется, но не будет правильно работать при запуске. В документации к пакетам стандартной библиотеки декларируется потребность в этом типе импорта. Если вы напишете пакет, который требуется импортировать ради побочного эффекта, вам также следует убедиться, что используемое выражение <code>init()</code> задокументировано, и импортирующие ваш пакет пользователи смогут правильно его использовать.</p>

<h2 id="Заключение">Заключение</h2>

<p>В этом обучающем руководстве мы узнали, что функция <code>init()</code> загружается до остальной части кода приложения и может выполнять определенные задачи для пакета, в частности, инициализировать желаемое состояние. Также мы узнали, что порядок выполнения компилятором нескольких выражений <code>init()</code> зависит от того, в каком порядке компилятор загружает исходные файлы. Если вы хотите узнать больше о функции <code>init()</code>, ознакомьтесь с официальной <a href="https://golang.org/doc/effective_go.html#init">документацией Golang</a> или прочитайте <a href="https://github.com/golang/go/issues/25885">дискуссию в сообществе Go об этой функции</a>.</p>

<p>Дополнительную информацию о функциях можно найти в статье <a href="https://www.digitalocean.com/community/tutorials/how-to-define-and-call-functions-in-go">Определение и вызов функций</a> и в других статьях из <a href="https://www.digitalocean.com/community/tutorial_series/how-to-code-in-go">серии статей по программированию на Go</a>.</p>
