---
layout: post
title: Cómo enviar notificaciones push web desde aplicaciones de Django
network: digitalocean
date: January 09, 2020 at 05:46PM
url: https://www.digitalocean.com/community/tutorials/how-to-send-web-push-notifications-from-django-applications-es
image: https://assets.digitalocean.com/articles/django_push_18_04/web_push_final.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<p><em>El autor seleccionó a <a href="https://www.brightfunds.org/funds/open-internet-free-speech">Open Internet/Free Speech Fund</a> para recibir una donación como parte del programa W<a href="https://do.co/w4do-cta">rite for DOnations</a>.</em></p>

<h3 id="introducción">Introducción</h3>

<p>La web evoluciona de manera constante y ahora puede lograr las funcionalidades que antes solo estaban disponibles en dispositivos móviles nativos. La introducción de los <a href="https://developers.google.com/web/fundamentals/primers/service-workers/">trabajos de servicio</a> de JavaScript incorporó a la Web habilidades recién descubiertas para actividades como la sincronización en segundo plano, el almacenamiento en caché fuera de línea y el envío de <a href="https://developer.mozilla.org/en/docs/Web/API/Push_API">notificaciones push</a>.</p>

<p>Las notificaciones push permiten a los usuarios recibir actualizaciones para aplicaciones móviles y web. También permiten que estos vuelvan a usar aplicaciones existentes mediante contenido personalizado y pertinente.</p>

<p>A través de este tutorial, configurará una en Ubuntu 18.04 aplicación de Django que envíe notificaciones push cuando haya alguna actividad en la cual se requiera que el usuario ingrese a la aplicación. Para crear estas notificaciones, utilizará el paquete <a href="https://github.com/safwanrahman/django-webpush">Django-Webpush</a>, y configurará y registrará un trabajo de servicio para mostrar las notificaciones al cliente. La aplicación, en condiciones de funcionamiento y con las notificaciones, tendrá este aspecto:</p>

<p><img src="https://assets.digitalocean.com/articles/django_push_18_04/web_push_final.png" alt="Push web final"></p>

<h2 id="requisitos-previos">Requisitos previos</h2>

<p>Para completar esta guía, necesitará lo siguiente:</p>

<ul>
<li>Un servidor de Ubuntu 18.04 con un usuario no root y un firewall activo. Puede seguir las directrices de esta <a href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04">guía de configuración inicial para servidores</a> para obtener más información sobre cómo crear un servidor de Ubuntu 18.04.</li>
<li><code>pip</code> y <code>venv</code> instalados conforme a estas <a href="https://www.digitalocean.com/community/tutorials/how-to-install-the-django-web-framework-on-ubuntu-18-04#install-with-pip-in-a-virtual-environment">directrices</a>.</li>
<li>Un proyecto de Django llamado <code><span class="highlight">djangopush</span></code> creado en su directorio de inicio, configurado conforme a estas directrices para <a href="https://www.digitalocean.com/community/tutorials/how-to-install-the-django-web-framework-on-ubuntu-18-04#creating-a-sample-project">crear un proyecto de ejemplo de Django en Ubuntu 18.04</a>. Asegúrese de <a href="https://www.digitalocean.com/community/tutorials/how-to-install-the-django-web-framework-on-ubuntu-18-04#modifying-allowed_hosts-in-the-django-settings">añadir la dirección IP de su servidor a la directiva <code>ALLOWED_HOSTS</code></a> en su archivo <code>settings.py</code>.</li>
</ul>

<h2 id="paso-1-instalar-django-webpush-y-generar-claves-de-vapid">Paso 1: Instalar Django-Webpush y generar claves de Vapid</h2>

<p>Django-Webpush es un paquete que permite a los desarrolladores integrar y enviar notificaciones push web en aplicaciones de Django. Usaremos este paquete para activar y enviar las notificaciones desde nuestra aplicación. En este paso, instalará Django-Webpush y obtendrá las claves de <em>Identificación voluntaria del servidor de aplicaciones (VAPID)</em> necesarias para identificar su servidor y garantizar la singularidad de cada solicitud.</p>

<p>Asegúrese de posicionarse en el directorio del proyecto <code>~/<span class="highlight">djangopush</span></code> que creó en los requisitos previos:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd ~/<span class="highlight">djangopush</span>
</li></ul></code></pre>
<p>Active su entorno virtual:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">source <span class="highlight">my_env</span>/bin/activate
</li></ul></code></pre>
<p>Actualice su versión de <code>pip</code> para garantizar que esté vigente:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">pip install --upgrade pip
</li></ul></code></pre>
<p>Instale Django-Webpush:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">pip install django-webpush
</li></ul></code></pre>
<p>Después de instalar el paquete, agréguelo a la lista de aplicaciones de su archivo <code>settings.py</code>. Primero abra <code>settings.py</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/djangopush/settings.py
</li></ul></code></pre>
<p>Añada <code>webpush</code> a la lista de <code>INSTALLED_APPS</code>:</p>
<div class="code-label " title="~/djangopush/djangopush/settings.py">~/djangopush/djangopush/settings.py</div><pre class="code-pre "><code langs="">...

INSTALLED_APPS = [
    ...<span class="highlight">,</span>
   <span class="highlight"> 'webpush',</span>
]
...
</code></pre>
<p>Guarde el archivo y cierre el editor.</p>

<p>Ejecute <a href="https://docs.djangoproject.com/en/2.0/topics/migrations/">migraciones</a> en la aplicación para implementar los cambios que realizó en el esquema de su base de datos:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">python manage.py migrate
</li></ul></code></pre>
<p>El resultado tendrá el siguiente aspecto, lo cual indicará que la migración se realizó con éxito:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Operations to perform:
  Apply all migrations: admin, auth, contenttypes, sessions, webpush
Running migrations:
  Applying webpush.0001_initial... OK
</code></pre>
<p>El siguiente paso para configurar las notificaciones push web consiste en obtener claves de VAPID. Estas claves identifican el servidor de la aplicación y pueden utilizarse para reducir la confidencialidad de las URL de suscripciones push, ya que limitan las suscripciones a un servidor específico.</p>

<p>Para obtener claves de VAPID, diríjase a la aplicación web de <a href="https://web-push-codelab.glitch.me/">wep-push-codelab</a>. Aquí, recibirá claves generadas de forma automática. Copie las claves privadas y públicas.</p>

<p>A continuación, cree una nueva entrada en <code>settings.py</code> para su información de VAPID. Primero, abra el archivo:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/djangopush/settings.py
</li></ul></code></pre>
<p>A continuación, agregue una nueva directiva llamada <code>WEBPUSH_SETTINGS</code> con sus claves públicas y privadas de VAPID y su correo electrónico por debajo de <code>AUTH_PASSWORD_VALIDATORS</code>:</p>
<div class="code-label " title="~/djangopush/djangopush/settings.py">~/djangopush/djangopush/settings.py</div><pre class="code-pre "><code class="code-highlight language-python">...

AUTH_PASSWORD_VALIDATORS = [
    ...
]

<span class="highlight">WEBPUSH_SETTINGS = {</span>
   <span class="highlight">"VAPID_PUBLIC_KEY": "your_vapid_public_key",</span>
   <span class="highlight">"VAPID_PRIVATE_KEY": "your_vapid_private_key",</span>
   <span class="highlight">"VAPID_ADMIN_EMAIL": "admin@example.com"</span>
<span class="highlight">}</span>

# Internationalization
# https://docs.djangoproject.com/en/2.0/topics/i18n/

...
</code></pre>
<p>No olvide sustituir los valores del marcador de posición <code><span class="highlight">your_vapid_p</span></code>ublic<em>key, `<span class="highlight">your</span></em>vapid<em>public</em>key<code>y</code><span class="highlight"><a href="mailto:admin@example.com">admin@example.com</a></span>` por su propia información. A través de su dirección de correo electrónico, se le notificará si el servidor push experimenta problemas.</p>

<p>A continuación, configuraremos las vistas que mostrarán la página de inicio de la aplicación y activarán notificaciones push para los usuarios suscritos.</p>

<h2 id="paso-2-configurar-vistas">Paso 2: Configurar vistas</h2>

<p>En este paso, configuraremos una <a href="https://docs.djangoproject.com/en/2.1/topics/http/views/"><em>vista</em></a> <code>home</code> básica con el <a href="https://docs.djangoproject.com/en/2.1/ref/request-response/#django.http.HttpRequest">objeto response <code>HttpResponse</code></a> para nuestra página de inicio, junto con una vista de <code>send_push.</code> Las vistas son funciones que muestran objetos response de solicitudes web. La vista de <code>send_push</code> usará la biblioteca de Django-Webpush para enviar notificaciones push que contienen los datos ingresados por un usuario en la página de inicio.</p>

<p>Diríjase a la carpeta <code>~/djangopush/djangopush</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">cd ~/djangopush/djangopush
</li></ul></code></pre>
<p>Ejecutar <code>ls</code> dentro de la carpeta le mostrará los archivos principales del proyecto:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>/__init__.py
/settings.py
/urls.py
/wsgi.py
</code></pre>
<p>Los archivos de esta carpeta se generan de forma automática a través de la utilidad <code>django-admin</code> que utilizó para crear su proyecto en los requisitos previos. El archivo <code>settings.py</code> contiene configuraciones de todo el proyecto, como las aplicaciones instaladas y la carpeta root estática. El archivo <code>urls.py</code> contiene las configuraciones de URL para el proyecto. Aquí es donde establecerá las rutas para que coincidan con las vistas que creó.</p>

<p>Cree un nuevo archivo dentro del directorio <code>~/djangopush/djangopush</code> llamado <code>views.py</code>, que contendrá las vistas para su proyecto:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/djangopush/views.py
</li></ul></code></pre>
<p>La primera vista que haremos es <code>home</code>, que mostrará la página de inicio en la cual los usuarios pueden enviar notificaciones push. Añada el siguiente código al archivo:</p>
<div class="code-label " title="~/djangopush/djangopush/views.py">~/djangopush/djangopush/views.py</div><pre class="code-pre "><code class="code-highlight language-python">from django.http.response import HttpResponse
from django.views.decorators.http import require_GET

@require_GET
def home(request):
    return HttpResponse('&lt;h1&gt;Home Page&lt;h1&gt;')
</code></pre>
<p>La vista <code>home</code> está representada por el decorador <code>require_GET</code>, que la limita a exclusivamente a solicitudes GET. Una vista suele mostrar una respuesta a cada solicitud que se le hace. Esta vista muestra una etiqueta HTML simple como respuesta.</p>

<p>La siguiente vista que crearemos es <code>send_push</code>, que se encargará de las notificaciones push enviadas usando el paquete <code>django-webpush</code>. Se limitará únicamente a solicitudes POST y quedará exento de la protección contra la<a href="https://docs.djangoproject.com/en/2.0/ref/csrf/">* falsificación de solicitud entre sitios cruzados* (CSRF)</a>. Realizar esto le permitirá probar la vista usando <a href="https://www.getpostman.com/postman">Postman</a> o cualquier otro servicio de RESTful. Sin embargo, para la producción debe quitar este decorador a fin de evitar que sus vistas sean vulnerables a CSRF.</p>

<p>Para crear la vista <code>send_push</code>, primero agregue las siguientes importaciones a fin de habilitar las respuestas de JSON y acceder a la función <code>send_user_notification</code> en la biblioteca <code>webpush</code>:</p>
<div class="code-label " title="~/djangopush/djangopush/views.py">~/djangopush/djangopush/views.py</div><pre class="code-pre "><code class="code-highlight language-python">from django.http.response import <span class="highlight">JsonResponse</span>, HttpResponse
from django.views.decorators.http import require_GET, <span class="highlight">require_POST</span>
<span class="highlight">from django.shortcuts import get_object_or_404</span>
<span class="highlight">from django.contrib.auth.models import User</span>
<span class="highlight">from django.views.decorators.csrf import csrf_exempt</span>
<span class="highlight">from webpush import send_user_notification</span>
<span class="highlight">import json</span>
</code></pre>
<p>A continuación, agregue el decorador <code>require_POST</code>, que usará el cuerpo de la solicitud enviada por el usuario para crear y activar una notificación push.</p>
<div class="code-label " title="~/djangopush/djangopush/views.py">~/djangopush/djangopush/views.py</div><pre class="code-pre "><code class="code-highlight language-python">@require_GET
def home(request):
    ...


@require_POST
@csrf_exempt
def send_push(request):
    try:
        body = request.body
        data = json.loads(body)

        if 'head' not in data or 'body' not in data or 'id' not in data:
            return JsonResponse(status=400, data={"message": "Invalid data format"})

        user_id = data['id']
        user = get_object_or_404(User, pk=user_id)
        payload = {'head': data['head'], 'body': data['body']}
        send_user_notification(user=user, payload=payload, ttl=1000)

        return JsonResponse(status=200, data={"message": "Web push successful"})
    except TypeError:
        return JsonResponse(status=500, data={"message": "An error occurred"})
</code></pre>
<p>Usaremos dos decoradores para la vista <code>send_push</code>: el decorador <code>require_POST</code>, que limita la vista únicamente a las solicitudes de POST, y el decorador de <code>csrf_exempt</code>, que exenta a la vista de la protección CSRF.</p>

<p>Esta vista espera datos de POST y realiza lo siguiente: obtiene el <code>body</code> de la solicitud y, usando el paquete de <a href="https://docs.python.org/3/library/json.html">json</a>, deserializa el documento JSON a un objeto de Python con <a href="https://docs.python.org/3.6/library/json.html"><code>json.loads</code></a>. <code>json.loads</code> obtiene un documento JSON estructurado y lo convierte en un objeto de Python.</p>

<p>La vista espera que el objeto body de la solicitud tenga tres propiedades:</p>

<ul>
<li><code>head</code>: el título de la notificación push.</li>
<li><code>body</code>: el cuerpo de la notificación.</li>
<li><code>id</code>: el <code>id</code> del usuario de la solicitud.</li>
</ul>

<p>Si falta alguna de las propiedades necesarias, en la vista se mostrará una respuesta <code>JSONResponse</code> con un estado 404 “Not Found”. Si el usuario con la clave primaria dada existe, la vista mostrará el <code>user</code> con la clave primaria correspondiente usando la función <a href="https://docs.djangoproject.com/en/2.1/topics/http/shortcuts/#get-object-or-404"><code>get_objet_or_404</code></a> de la <code>biblioteca django.shortcuts</code>. Si el usuario no existe, la función mostrará un error 404.</p>

<p>La vista también utiliza la función <code>send_user_notification</code> de la biblioteca <code>webpush</code>. Esta función toma tres parámetros:</p>

<ul>
<li><code>User</code>: el destinatario de la notificación push.</li>
<li><code>payload</code>: la información de la notificación, que incluye el <code>head</code> y el <code>body</code> de esta.</li>
<li><code>ttl</code>: el tiempo máximo en segundos durante el cual la notificación debe almacenarse si el usuario se encuentra fuera de línea.</li>
</ul>

<p>Si no se producen errores, la vista muestra una respuesta <code>JSONResponse</code> con un estado 200 “Success” y un objeto de datos. Si se produce un <code>KeyError</code>, la vista mostrará un estado 500 de “Internal Server Error”. Un <code>KeyError</code> se produce cuando no existe la clave solicitada de un objeto.</p>

<p>En el siguiente paso, crearemos las rutas URL correspondientes para que coincidan con las vistas que creamos.</p>

<h2 id="paso-3-asignar-url-a-vistas">Paso 3: Asignar URL a vistas</h2>

<p>Django permite crear <a href="https://docs.djangoproject.com/en/2.0/topics/http/urls/">URL</a> que establezcan conexión con vistas mediante un módulo de Python llamado <code>URLconf</code>. Este módulo asigna expresiones de rutas de URL a funciones de Python (sus vistas). Normalmente, se genera de forma automática un archivo de configuración de URL cuando se crea un proyecto. Al completar este paso, actualizará este archivo a fin de incluir nuevas rutas para las vistas que creó en el paso anterior, junto con las URL para la aplicación <code>django-webpush</code>; esta proporcionará extremos para suscribir usuarios a notificaciones push.</p>

<p>Para obtener más información sobre vistas, consulte <a href="https://www.digitalocean.com/community/tutorials/how-to-create-django-views">Cómo crear vistas de Django</a>.</p>

<p>Abra <code>urls.py</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/djangopush/urls.py
</li></ul></code></pre>
<p>El archivo tendrá este aspecto:</p>
<div class="code-label " title="~/djangopush/djangopush/urls.py">~/djangopush/djangopush/urls.py</div><pre class="code-pre "><code class="code-highlight language-python">
"""untitled URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/2.1/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path

urlpatterns = [
    path('admin/', admin.site.urls),
]
</code></pre>
<p>El siguiente paso es asignar a URL las vistas que creó. Primero, agregue la importación <code>include</code> a fin de garantizar que todas las rutas para la biblioteca de Django-Webpush se añadan a su proyecto:</p>
<div class="code-label " title="~/djangopush/djangopush/urls.py">~/djangopush/djangopush/urls.py</div><pre class="code-pre "><code class="code-highlight language-python">
"""webpushdjango URL Configuration
...
"""
from django.contrib import admin
from django.urls import path, <span class="highlight">include</span>
</code></pre>
<p>A continuación, importe las vistas que creó en el último paso y actualice la lista de <code>urlpatterns</code> para asignar sus vistas:</p>
<div class="code-label " title="~/djangopush/djangopush/urls.py">~/djangopush/djangopush/urls.py</div><pre class="code-pre "><code class="code-highlight language-python">
"""webpushdjango URL Configuration
...
"""
from django.contrib import admin
from django.urls import path, <span class="highlight">include</span>

<span class="highlight">from .views import home, send_push</span>

urlpatterns = [
                  path('admin/', admin.site.urls),
                  <span class="highlight">path('', home),</span>
                  <span class="highlight">path('send_push', send_push),</span>
                  <span class="highlight">path('webpush/', include('webpush.urls')),</span>
              ]
</code></pre>
<p>Aquí, la lista de <code>urlpatterns</code> registra las URL para el paquete <code>django-webpush</code> y asigna sus vistas a las URL <code>/send_push</code> y <code>/home</code>.</p>

<p>Realicemos una prueba de la vista de <code>/home</code> para asegurarnos de que funcione como se pretende. Asegúrese de estar posicionado en el directorio root del proyecto:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">cd ~/djangopush
</li></ul></code></pre>
<p>Inicie su servidor ejecutando el siguiente comando:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">python manage.py runserver <span class="highlight">your_server_ip</span>:8000
</li></ul></code></pre>
<p>Diríjase a <code>http://<span class="highlight">your_server_ip</span>:8000</code>. Debería ver la siguiente página de inicio:</p>

<p><img src="https://assets.digitalocean.com/articles/django_push_18_04/django_push_home.png" alt="Vista inicial de la página principal"></p>

<p>En este punto, puede detener el servidor con <code>CTRL+C</code>. A continuación, procederemos a crear plantillas y a suministrarlas en nuestras vistas usando la función <code>render</code>.</p>

<h2 id="paso-4-crear-plantillas">Paso 4: Crear plantillas</h2>

<p>El motor de plantillas de Django le permite definir las capas de su aplicación orientadas al usuario con plantillas similares a archivos HTML. En este paso, creará y representará una plantilla para la vista <code>home</code>.</p>

<p>Cree una carpeta llamada <code>templates</code> en el directorio root de su proyecto:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">mkdir ~/djangopush/templates
</li></ul></code></pre>
<p>Si ejecuta <code>ls</code> en la carpeta root de su proyecto en este punto, el resultado tendrá este aspecto:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>/djangopush
/templates
db.sqlite3
manage.py
/my_env
</code></pre>
<p>Cree un archivo llamado <code>home.html</code> en la carpeta <code>templates</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/templates/home.html
</li></ul></code></pre>
<p>Añada el siguiente código al archivo para crear un formulario en el que los usuarios puedan introducir información y crear notificaciones push:</p>
<pre class="code-pre "><code class="code-highlight language-html">{% load static %}
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
    &lt;meta name="vapid-key" content="{{ vapid_key }}"&gt;
    {% if user.id %}
        &lt;meta name="user_id" content="{{ user.id }}"&gt;
    {% endif %}
    &lt;title&gt;Web Push&lt;/title&gt;
    &lt;link href="https://fonts.googleapis.com/css?family=PT+Sans:400,700" rel="stylesheet"&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;div&gt;
    &lt;form id="send-push__form"&gt;
        &lt;h3 class="header"&gt;Send a push notification&lt;/h3&gt;
        &lt;p class="error"&gt;&lt;/p&gt;
        &lt;input type="text" name="head" placeholder="Header: Your favorite airline 😍"&gt;
        &lt;textarea name="body" id="" cols="30" rows="10" placeholder="Body: Your flight has been cancelled 😱😱😱"&gt;&lt;/textarea&gt;
        &lt;button&gt;Send Me&lt;/button&gt;
    &lt;/form&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>El <code>body</code> del archivo incluye un formulario con dos campos: un elemento <code>input</code> contendrá el encabezado o título de la notificación y un elemento <code>textarea</code> contendrá el cuerpo de la notificación.</p>

<p>En la sección <code>head</code> del archivo, existen dos etiquetas <code>meta</code> que almacenarán la clave pública de VAPID y la identificación del usuario. Estas dos variables son necesarias para registrar un usuario y enviarle notificaciones push. Se requiere aquí la identificación del usuario, ya que enviará solicitudes AJAX al servidor y el <code>id</code> se usará para identificar el usuario. Si el usuario actual es un usuario registrado, la plantilla creará una etiqueta <code>meta</code> con su <code>id</code> como contenido.</p>

<p>El siguiente paso es indicar a Django dónde encontrar sus plantillas. Para realizar esto, editará <code>settings.py</code> y actualizará la lista <code>TEMPLATES</code>.</p>

<p>Abra el archivo <code>settings.py</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/djangopush/settings.py
</li></ul></code></pre>
<p>Añada lo siguiente a la lista <code>DIRS</code> para especificar la ruta al directorio de plantillas:</p>
<div class="code-label " title="~/djangopush/djangopush/settings.py">~/djangopush/djangopush/settings.py</div><pre class="code-pre "><code class="code-highlight language-python">...
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [<span class="highlight">os.path.join(BASE_DIR, 'templates')</span>],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                ...
            ],
        },
    },
]
...
</code></pre>
<p>A continuación, en su archivo <code>views.py</code>, actualice la vista de <code>home</code> para representar la plantilla de <code>home.html</code>. Abra el archivo:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangpush/djangopush/views.py
</li></ul></code></pre>
<p>Primero agregue algunas importaciones, incluida la configuración de <code>settings</code>, que contiene todas las configuraciones del proyecto del archivo <code>settings.py</code>, y la función <code>render</code> de <code>django.shortcuts</code>:</p>
<div class="code-label " title="~/djangopush/djangopush/views.py">~/djangopush/djangopush/views.py</div><pre class="code-pre "><code class="code-highlight language-python">...
from django.shortcuts import <span class="highlight">render</span>, get_object_or_404
...
import json
<span class="highlight">from django.conf import settings</span>

...
</code></pre>
<p>A continuación, elimine el código inicial que agregó a la vista de <code>home</code> y agregue lo siguiente, lo cual especifica cómo se representará la plantilla que acaba de crear:</p>
<div class="code-label " title="~/djangopush/djangopush/views.py">~/djangopush/djangopush/views.py</div><pre class="code-pre "><code class="code-highlight language-python">...

<a href="https://www.digitalocean.com/community/users/require_get" class="username-tag">@require_GET</a>
def home(request):
   <span class="highlight">webpush_settings = getattr(settings, 'WEBPUSH_SETTINGS', {})</span>
   <span class="highlight">vapid_key = webpush_settings.get('VAPID_PUBLIC_KEY')</span>
   <span class="highlight">user = request.user</span>
   <span class="highlight">return render(request, 'home.html', {user: user, 'vapid_key': vapid_key})</span>
</code></pre>
<p>El código asigna las siguientes variables:</p>

<ul>
<li><code>webpush_settings</code>: se asigna el valor del atributo de <code>WEBPUSH_SETTINGS</code> desde la configuración de <code>settings</code>.</li>
<li><code>vapid_key</code>: obtiene el valor de <code>VAPID_PUBLIC_KEY</code> del objeto <code>webpush_settings</code> para enviarlo al cliente. Esta clave pública se verifica con la clave privada a fin de de garantizar que el cliente que dispone de la clave pública tenga permiso para recibir mensajes push del servidor.</li>
<li><code>user</code>: esta variable proviene de la solicitud entrante. Cuando un usuario realiza una solicitud al servidor, los detalles para ese usuario se almacenan en el campo <code>user</code>.</li>
</ul>

<p>La función <a href="https://docs.djangoproject.com/en/2.1/topics/http/shortcuts/#render"><code>render</code></a> proporcionará un archivo HTML y un <a href="https://docs.djangoproject.com/en/2.1/ref/templates/api/#django.template.Context">objeto de contexto</a> que contiene el usuario actual y la clave pública de vapid del servidor. Aquí se utilizan tres parámetros: la <code>request</code>, la <code>template</code> que se representará y el objeto que contiene las variables que se utilizarán en la plantilla.</p>

<p>Una vez que creemos nuestra plantilla y actualicemos la vista de <code>home</code>, podremos configurar Django para proporcionar nuestros archivos estáticos.</p>

<h2 id="paso-5-proporcionar-archivos-estáticos">Paso 5: Proporcionar archivos estáticos</h2>

<p>Las aplicaciones web incluyen CSS, JavaScript y otros archivos de imagen que en Django se denominan “archivos estáticos”. Django le permite recopilar todos los archivos estáticos de cada aplicación en su proyecto en una sola ubicación desde la que se proporcionan. Esta solución se llama <code>django.contrib.staticfiles</code>. En este paso, actualizaremos nuestra configuración para indicar a Django dónde almacenar nuestros archivos estáticos.</p>

<p>Abra <code>settings.py</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/djangopush/settings.py
</li></ul></code></pre>
<p>En <code>settings.py</code>, primero asegúrese de que se haya definido <code>STATIC_URL</code>:</p>
<div class="code-label " title="~/djangopush/djangopush/settings.py">~/djangopush/djangopush/settings.py</div><pre class="code-pre "><code class="code-highlight language-python">...
STATIC_URL = '/static/'
</code></pre>
<p>A continuación, agregue una lista de directorios llamada <code>STATICFILES_DIRS</code> donde Django buscará archivos estáticos:</p>
<div class="code-label " title="~/djangopush/djangopush/settings.py">~/djangopush/djangopush/settings.py</div><pre class="code-pre "><code class="code-highlight language-python">...
STATIC_URL = '/static/'
<span class="highlight">STATICFILES_DIRS = [</span>
    <span class="highlight">os.path.join(BASE_DIR, "static"),</span>
<span class="highlight">]</span>
</code></pre>
<p>Ahora podrá añadir <code>STATIC_URL</code> a la lista de las rutas definidas en su archivo <code>urls.py</code>.</p>

<p>Abra el archivo:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/djangopush/urls.py
</li></ul></code></pre>
<p>Añada el siguiente código, que importará la configuración de la url <code>static</code> y actualizará la lista de <code>urlpatterns</code>. La función auxiliar aquí utiliza las propiedades de <code>STATIC_URL</code> y <code>STATIC_ROOT</code> que aportamos en el archivo <code>settings.py</code> para proporcionar los archivos estáticos del proyecto:</p>
<div class="code-label " title="~/djangopush/djangopush/urls.py">~/djangopush/djangopush/urls.py</div><pre class="code-pre "><code class="code-highlight language-python">
...
<span class="highlight">from django.conf import settings</span>
<span class="highlight">from django.conf.urls.static import static</span>

urlpatterns = [
    ...
] <span class="highlight"> + static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)</span>
</code></pre>
<p>Una vez configurados los ajustes de nuestros archivos estáticos, podremos aplicar retoques de estilo a la página de inicio de la aplicación.</p>

<h2 id="paso-6-aplicar-retoques-de-estilo-a-la-página-de-inicio">Paso 6: Aplicar retoques de estilo a la página de inicio</h2>

<p>Después de configurar su aplicación para presentar los archivos estáticos, puede crear una hoja de estilo externa y enlazarla al archivo <code>home.html</code> para aplicar ajustes de estilo a la página de inicio. Todos sus archivos estáticos se almacenarán en un directorio static <code>de</code> la carpeta root de su proyecto.</p>

<p>Cree una carpeta <code>static</code> y una carpeta <code>css</code> dentro de la carpeta <code>static</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">mkdir -p ~/djangopush/static/css
</li></ul></code></pre>
<p>Abra un archivo css llamado <code>styles.css</code> dentro de la carpeta <code>css</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/static/css/styles.css
</li></ul></code></pre>
<p>Añada los siguientes estilos para la página de inicio:</p>
<div class="code-label " title="~/djangopush/static/css/styles.css">~/djangopush/static/css/styles.css</div><pre class="code-pre "><code class="code-highlight language-css">
body {
    height: 100%;
    background: rgba(0, 0, 0, 0.87);
    font-family: 'PT Sans', sans-serif;
}

div {
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
}

form {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 35%;
    margin: 10% auto;
}

form &gt; h3 {
    font-size: 17px;
    font-weight: bold;
    margin: 15px 0;
    color: orangered;
    text-transform: uppercase;
}

form &gt; .error {
    margin: 0;
    font-size: 15px;
    font-weight: normal;
    color: orange;
    opacity: 0.7;
}

form &gt; input, form &gt; textarea {
    border: 3px solid orangered;
    box-shadow: unset;
    padding: 13px 12px;
    margin: 12px auto;
    width: 80%;
    font-size: 13px;
    font-weight: 500;
}

form &gt; input:focus, form &gt; textarea:focus {
    border: 3px solid orangered;
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.2);
    outline: unset;
}

form &gt; button {
    justify-self: center;
    padding: 12px 25px;
    border-radius: 0;
    text-transform: uppercase;
    font-weight: 600;
    background: orangered;
    color: white;
    border: none;
    font-size: 14px;
    letter-spacing: -0.1px;
    cursor: pointer;
}

form &gt; button:disabled {
    background: dimgrey;
    cursor: not-allowed;
}
</code></pre>
<p>Una vez creada la hoja de estilo, podrá enlazarla al archivo <code>home.html</code> usando <a href="https://docs.djangoproject.com/en/2.1/ref/templates/builtins/#std:templatetag-static">etiquetas de plantillas estáticas</a>. Abra el archivo <code>home.html</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/templates/home.html
</li></ul></code></pre>
<p>Actualice la sección <code>head</code> para incluir un enlace a la hoja de estilo externa:</p>
<div class="code-label " title="~/djangopush/templates/home.html">~/djangopush/templates/home.html</div><pre class="code-pre "><code class="code-highlight language-html">
{% load static %}
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    ...
    <span class="highlight">&lt;link href="{% static '/css/styles.css' %}" rel="stylesheet"&gt;</span>
&lt;/head&gt;
&lt;body&gt;
    ...
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Asegúrese de posicionarse en el directorio principal de su proyecto y vuelva a iniciar su servidor para inspeccionar su trabajo:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">cd ~/djangopush
</li><li class="line" prefix="(my_env) $">python manage.py runserver <span class="highlight">your_server_ip</span>:8000
</li></ul></code></pre>
<p>Cuando visite <code>http://<span class="highlight">your_server_ip</span>:8000</code>, deberá tener el siguiente aspecto:</p>

<p><img src="https://assets.digitalocean.com/articles/django_push_18_04/push_styled_home.png" alt="Vista de la página de inicio"> Una vez más, podrá detener el servidor con C<code>TRL+C</code>.</p>

<p>Ahora que creó la página <code>home.html</code> y le aplicó ajustes de estilo con éxito, puede suscribir usuarios para recibir notificaciones push cuando visiten la página de inicio.</p>

<h2 id="paso-7-registrar-un-trabajo-de-servicio-y-suscribir-usuarios-para-recibir-notificaciones-push">Paso 7: Registrar un trabajo de servicio y suscribir usuarios para recibir notificaciones push</h2>

<p>Las notificaciones push web pueden dar aviso a los usuarios cuando existen actualizaciones de las aplicaciones a las que están suscritos o solicitarles que se vuelvan a conectar con las aplicaciones que han utilizaron en el pasado. Se basan en dos tecnologías: la API <a href="https://developer.mozilla.org/en-US/docs/Web/API/Push_API">push</a> y la API de <a href="https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API">notificaciones</a>. Ambas tecnologías dependen de la presencia de un trabajo de servicio.</p>

<p>Una notificación push se invoca cuando el servidor proporciona información al trabajo de servicio y este último utiliza la API de notificaciones para mostrar esta información.</p>

<p>Suscribiremos a nuestros usuarios a las notificaciones push y luego enviaremos la información de la suscripción al servidor para registrarlos.</p>

<p>En el directorio <code>static</code>, cree una carpeta llamada <code>js</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">mkdir ~/djangopush/static/js
</li></ul></code></pre>
<p>Cree un archivo llamado <code>registerSw.js</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/static/js/registerSw.js
</li></ul></code></pre>
<p>Añada el siguiente código, que comprueba si los trabajados de servicio son compatibles con el navegador del usuario antes de intentar registrar un trabajo de servicio:</p>
<div class="code-label " title="~/djangopush/static/js/registerSw.js">~/djangopush/static/js/registerSw.js</div><pre class="code-pre "><code class="code-highlight language-javascript">
const registerSw = async () =&gt; {
    if ('serviceWorker' in navigator) {
        const reg = await navigator.serviceWorker.register('sw.js');
        initialiseState(reg)

    } else {
        showNotAllowed("You can't send push notifications ☹️😢")
    }
};
</code></pre>
<p>Primero, la función <code>registerSw</code> comprueba si el navegador es compatible con los trabajados de servicio antes de registrarlos. Después del registro, llama a la función <code>initializeState</code> con los datos de registro. Si los trabajados de servicio no son compatibles con el navegador, llama a la función <code>showNotAllowed</code>.</p>

<p>A continuación, agregue el siguiente código debajo de la función <code>registerSw</code> a fin de comprobar si un usuario reúne las condiciones para recibir notificaciones push antes de intentar suscribirlos:</p>
<div class="code-label " title="~/djangopush/static/js/registerSw.js">~/djangopush/static/js/registerSw.js</div><pre class="code-pre "><code class="code-highlight language-javascript">
...

const initialiseState = (reg) =&gt; {
    if (!reg.showNotification) {
        showNotAllowed('Showing notifications isn\'t supported ☹️😢');
        return
    }
    if (Notification.permission === 'denied') {
        showNotAllowed('You prevented us from showing notifications ☹️🤔');
        return
    }
    if (!'PushManager' in window) {
        showNotAllowed("Push isn't allowed in your browser 🤔");
        return
    }
    subscribe(reg);
}

const showNotAllowed = (message) =&gt; {
    const button = document.querySelector('form&gt;button');
    button.innerHTML = `${message}`;
    button.setAttribute('disabled', 'true');
};
</code></pre>
<p>La función <code>initializeState</code> comprueba lo siguiente:</p>

<ul>
<li>Si el usuario habilitó o no las notificaciones, usando el valor de <code>reg.showNotification</code>.</li>
<li>Si el usuario concedió permiso o no a la aplicación para mostrar notificaciones.</li>
<li>Si el navegador es compatible o no con la API <code>PushManager</code>. Si alguna de estas comprobaciones falla, se llama a la función <code>showNotAllowed</code> y se cancela la suscripción.</li>
</ul>

<p>La función <code>showNotAllowed</code> muestra un mensaje en el botón y lo deshabilita si un usuario no reúne las condiciones para recibir notificaciones. También muestra mensajes correspondientes si un usuario restringió la aplicación para no mostrar notificaciones o si el navegador no admite notificaciones push.</p>

<p>Una vez que nos aseguremos de que el usuario reúna las condiciones para recibir notificaciones push, el siguiente paso es suscribirlo usando <code>pushManager</code>. Añada el siguiente código debajo de la función <code>showNotAllowed</code>:</p>
<div class="code-label " title="~/djangopush/static/js/registerSw.js">~/djangopush/static/js/registerSw.js</div><pre class="code-pre "><code class="code-highlight language-javascript">
...

function urlB64ToUint8Array(base64String) {
    const padding = '='.repeat((4 - base64String.length % 4) % 4);
    const base64 = (base64String + padding)
        .replace(/\-/g, '+')
        .replace(/_/g, '/');

    const rawData = window.atob(base64);
    const outputArray = new Uint8Array(rawData.length);
    const outputData = outputArray.map((output, index) =&gt; rawData.charCodeAt(index));

    return outputData;
}

const subscribe = async (reg) =&gt; {
    const subscription = await reg.pushManager.getSubscription();
    if (subscription) {
        sendSubData(subscription);
        return;
    }

    const vapidMeta = document.querySelector('meta[name="vapid-key"]');
    const key = vapidMeta.content;
    const options = {
        userVisibleOnly: true,
        // if key exists, create applicationServerKey property
        ...(key &amp;&amp; {applicationServerKey: urlB64ToUint8Array(key)})
    };

    const sub = await reg.pushManager.subscribe(options);
    sendSubData(sub)
};
</code></pre>
<p>Al llamar a la función <code>pushManager.getSubscription</code>, se muestran los datos de una suscripción activa. Cuando existe una suscripción activa, se llama a la función <code>sendSubData</code> con la información de suscripción transmitida como un parámetro.</p>

<p>Cuando no existe una suscripción activa, la clave pública de VAPID, la cual cuenta con codificación segura de URL Base64, se convierte a un Uint8Array mediante la función <code>urlB64ToUint8Array</code>. Luego se a llama <code>pushManager.subscribe</code> con la clave pública de VAPID y el valor de <code>userVisible</code> como opciones. Puede obtener más información sobre las opciones disponibles <a href="https://developers.google.com/web/fundamentals/push-notifications/subscribing-a-user#uservisibleonly_options">aquí</a>.</p>

<p>Después de suscribir con éxito a un usuario, el siguiente paso es enviar los datos de la suscripción al servidor. Los datos se enviarán al extremo <code>webpush/save_information</code> proporcionado por el paquete de <code>django-webpush</code>. Añada el siguiente código debajo de la función <code>subscribe</code>:</p>
<div class="code-label " title="~/djangopush/static/js/registerSw.js">~/djangopush/static/js/registerSw.js</div><pre class="code-pre "><code class="code-highlight language-javascript">
...

const sendSubData = async (subscription) =&gt; {
    const browser = navigator.userAgent.match(/(firefox|msie|chrome|safari|trident)/ig)[0].toLowerCase();
    const data = {
        status_type: 'subscribe',
        subscription: subscription.toJSON(),
        browser: browser,
    };

    const res = await fetch('/webpush/save_information', {
        method: 'POST',
        body: JSON.stringify(data),
        headers: {
            'content-type': 'application/json'
        },
        credentials: "include"
    });

    handleResponse(res);
};

const handleResponse = (res) =&gt; {
    console.log(res.status);
};

registerSw();
</code></pre>
<p>El extremo <code>save_information</code> requiere información sobre el estado de la suscripción (<code>subscribe</code> y <code>unsubscribe</code>), los datos de suscripción y el navegador. Por último, llamaremos a la función <code>registerSw()</code> para iniciar el proceso de suscripción del usuario.</p>

<p>El archivo completo tiene el siguiente aspecto:</p>
<div class="code-label " title="~/djangopush/static/js/registerSw.js">~/djangopush/static/js/registerSw.js</div><pre class="code-pre "><code class="code-highlight language-javascript">
const registerSw = async () =&gt; {
    if ('serviceWorker' in navigator) {
        const reg = await navigator.serviceWorker.register('sw.js');
        initialiseState(reg)

    } else {
        showNotAllowed("You can't send push notifications ☹️😢")
    }
};

const initialiseState = (reg) =&gt; {
    if (!reg.showNotification) {
        showNotAllowed('Showing notifications isn\'t supported ☹️😢');
        return
    }
    if (Notification.permission === 'denied') {
        showNotAllowed('You prevented us from showing notifications ☹️🤔');
        return
    }
    if (!'PushManager' in window) {
        showNotAllowed("Push isn't allowed in your browser 🤔");
        return
    }
    subscribe(reg);
}

const showNotAllowed = (message) =&gt; {
    const button = document.querySelector('form&gt;button');
    button.innerHTML = `${message}`;
    button.setAttribute('disabled', 'true');
};

function urlB64ToUint8Array(base64String) {
    const padding = '='.repeat((4 - base64String.length % 4) % 4);
    const base64 = (base64String + padding)
        .replace(/\-/g, '+')
        .replace(/_/g, '/');

    const rawData = window.atob(base64);
    const outputArray = new Uint8Array(rawData.length);
    const outputData = outputArray.map((output, index) =&gt; rawData.charCodeAt(index));

    return outputData;
}

const subscribe = async (reg) =&gt; {
    const subscription = await reg.pushManager.getSubscription();
    if (subscription) {
        sendSubData(subscription);
        return;
    }

    const vapidMeta = document.querySelector('meta[name="vapid-key"]');
    const key = vapidMeta.content;
    const options = {
        userVisibleOnly: true,
        // if key exists, create applicationServerKey property
        ...(key &amp;&amp; {applicationServerKey: urlB64ToUint8Array(key)})
    };

    const sub = await reg.pushManager.subscribe(options);
    sendSubData(sub)
};

const sendSubData = async (subscription) =&gt; {
    const browser = navigator.userAgent.match(/(firefox|msie|chrome|safari|trident)/ig)[0].toLowerCase();
    const data = {
        status_type: 'subscribe',
        subscription: subscription.toJSON(),
        browser: browser,
    };

    const res = await fetch('/webpush/save_information', {
        method: 'POST',
        body: JSON.stringify(data),
        headers: {
            'content-type': 'application/json'
        },
        credentials: "include"
    });

    handleResponse(res);
};

const handleResponse = (res) =&gt; {
    console.log(res.status);
};

registerSw();
</code></pre>
<p>A continuación, agregue una etiqueta <code>script</code> para el archivo <code>registerSw.js</code> en <code>home.html</code>. Abra el archivo:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/templates/home.html
</li></ul></code></pre>
<p>Añada la etiqueta <code>script</code> antes de la etiqueta de cierre del elemento <code>body</code>:</p>
<div class="code-label " title="~/djangopush/templates/home.html">~/djangopush/templates/home.html</div><pre class="code-pre "><code class="code-highlight language-html">
{% load static %}
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
   ...
&lt;/head&gt;
&lt;body&gt;
   ...
   <span class="highlight">&lt;script src="{% static '/js/registerSw.js' %}"&gt;&lt;/script&gt;</span>
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Debido a que aún no existe un trabajo de servicio, si dejó su aplicación en ejecución o intentó iniciarla obtendrá un mensaje de error. Corregiremos esto creando un trabajo de servicio.</p>

<h2 id="paso-8-crear-un-trabajo-de-servicio">Paso 8: Crear un trabajo de servicio</h2>

<p>Para mostrar una notificación push, necesitará un trabajo de servicio activo instalado en la página de inicio de su aplicación. Crearemos un trabajo de servicio que escuche eventos <code>push</code> y muestre los mensajes cuando esté listo.</p>

<p>Debido a que queremos que el alcance del trabajador de servicio comprenda el dominio completo, debemos instalarlo en el directorio root de la aplicación. Puede obtener más información más sobre el proceso en este artículo acerca de <a href="https://developers.google.com/web/fundamentals/primers/service-workers/#register_a_service_worker">cómo registrar un trabajo de servicio</a>. Nuestro enfoque consistirá en crear un archivo <code>sw.js</code> en la carpeta <code>templates</code>, que luego registraremos como una vista.</p>

<p>Cree el archivo:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/templates/sw.js
</li></ul></code></pre>
<p>Añada el siguiente código, que indica al trabajador de servicio que debe escuchar eventos push:</p>
<div class="code-label " title="~/djangopush/templates/sw.js">~/djangopush/templates/sw.js</div><pre class="code-pre "><code class="code-highlight language-javascript">
// Register event listener for the 'push' event.
self.addEventListener('push', function (event) {
    // Retrieve the textual payload from event.data (a PushMessageData object).
    // Other formats are supported (ArrayBuffer, Blob, JSON), check out the documentation
    // on https://developer.mozilla.org/en-US/docs/Web/API/PushMessageData.
    const eventInfo = event.data.text();
    const data = JSON.parse(eventInfo);
    const head = data.head || 'New Notification 🕺🕺';
    const body = data.body || 'This is default content. Your notification didn\'t have one 🙄🙄';

    // Keep the service worker alive until the notification is created.
    event.waitUntil(
        self.registration.showNotification(head, {
            body: body,
            icon: 'https://i.imgur.com/MZM3K5w.png'
        })
    );
});
</code></pre>
<p>El trabajo de servicio aguarda un evento push. En la función de devolución de llamada, los datos de <code>event</code> se convierten a texto. Utilizamos las cadenas <code>title</code> y <code>body</code> predeterminadas si no se encuentran en los datos de event. La función <code>showNotification</code> toma el título de la notificación, el encabezado de la notificación que se mostrará y un objeto <a href="https://developers.google.com/web/fundamentals/push-notifications/display-a-notification#visual_options">options</a> como parámetros. El objeto de options contiene varias propiedades para configurar las opciones visuales de una notificación.</p>

<p>Para que su trabajo de servicio funcione en la totalidad de su dominio, deberá instalarlo en el directorio root de la aplicación. Usaremos <a href="https://docs.djangoproject.com/en/2.1/topics/class-based-views/"><code>TemplateView</code></a> para permitir que el trabajo de servicio tenga acceso a todo el dominio.</p>

<p>Abra el archivo <code>urls.py</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/djangopush/urls.py
</li></ul></code></pre>
<p>Añada una nueva instrucción de import y una ruta en la lista de <code>urlpatterns</code> para crear una vista basada en clases:</p>
<div class="code-label " title="~/djangopush/djangopush/urls.py">~/djangopush/djangopush/urls.py</div><pre class="code-pre "><code class="code-highlight language-python">...
<span class="highlight">from django.views.generic import TemplateView</span>

urlpatterns = [
                  ...<span class="highlight">,</span>
                  <span class="highlight">path('sw.js', TemplateView.as_view(template_name='sw.js', content_type='application/x-javascript'))</span>
              ] + static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)
</code></pre>
<p>Las vistas basadas en clases como <code>TemplateView</code> permiten crear vistas flexibles y reutilizables. En este caso, el método <code>TemplateView.as_view</code> crea una ruta para el trabajo de servicio al pasar el trabajo de servicio recién creado como una plantilla y <code>application/x-javascript</code> como el <code>content_type</code> de la plantilla.</p>

<p>Con esto, habrá creado un trabajo de servicio y lo habrá registrado como una ruta. A continuación, configurará el formulario de la página de inicio para enviar notificaciones push.</p>

<h2 id="paso-9-instalar-notificaciones-push">Paso 9: Instalar notificaciones push</h2>

<p>Con el formulario de la página de inicio, los usuarios deben poder enviar notificaciones push mientras su servidor está en ejecución. También puede enviar notificaciones push usando cualquier servicio de RESTful como Postman. Cuando el usuario envíe las notificaciones push desde el formulario en la página de inicio, los datos incluirán un <code>head</code> y un <code>body</code>, así como el <code>id</code> del usuario receptor. Los datos deben estructurarse de la siguiente manera:</p>
<pre class="code-pre "><code class="code-highlight language-javascript">{
    head: "Title of the notification",
    body: "Notification body",
    id: "User's id"
}
</code></pre>
<p>Para escuchar el evento <code>submit</code> del formulario y enviar los datos ingresados por el usuario al servidor, crearemos un archivo llamado <code>site.js</code> en el directorio <code>~/djangopush/static/js</code>.</p>

<p>Abra el archivo:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/static/js/site.js
</li></ul></code></pre>
<p>Primero, agregue una escucha de eventos <code>submit</code> al formulario que le permitirá obtener los valores de las entradas del formulario y el id del usuario almacenado en la etiqueta <code>meta</code> de su plantilla:</p>
<div class="code-label " title="~/djangopush/static/js/site.js">~/djangopush/static/js/site.js</div><pre class="code-pre "><code class="code-highlight language-javascript">
const pushForm = document.getElementById('send-push__form');
const errorMsg = document.querySelector('.error');

pushForm.addEventListener('submit', async function (e) {
    e.preventDefault();
    const input = this[0];
    const textarea = this[1];
    const button = this[2];
    errorMsg.innerText = '';

    const head = input.value;
    const body = textarea.value;
    const meta = document.querySelector('meta[name="user_id"]');
    const id = meta ? meta.content : null;
    ...
    // TODO: make an AJAX request to send notification
});
</code></pre>
<p>La función <code>pushForm</code> obtiene <code>input</code>, <code>textarea</code> y <code>button</code> dentro del formulario. También obtiene la información de la etiqueta <code>meta</code>, incluido el atributo de nombre <code>user_id</code> y el id de usuario almacenado en el atributo <code>content</code> de la etiqueta. Con esta información, puede enviar una solicitud POST al extremo de <code>/send_push</code> en el servidor.</p>

<p>Para enviar las solicitudes al servidor, usaremos la API nativa <a href="https://developer.mozilla.org/en/docs/Web/API/Fetch_API">Fetch</a>. Usaremos Fetch aquí, ya que es compatible con la mayoría de los navegadores y no necesita bibliotecas externas para funcionar. Debajo del código que agregó, actualice la función <code>pushForm</code> para incluir el código que sirve para enviar solicitudes de AJAX:</p>
<div class="code-label " title="~/djangopush/static/js/site.js">~/djangopush/static/js/site.js</div><pre class="code-pre "><code class="code-highlight language-javascript">const pushForm = document.getElementById('send-push__form');
const errorMsg = document.querySelector('.error');

pushForm.addEventListener('submit', async function (e) {
     ...
    const id = meta ? meta.content : null;

     if (head &amp;&amp; body &amp;&amp; id) {
        button.innerText = 'Sending...';
        button.disabled = true;

        const res = await fetch('/send_push', {
            method: 'POST',
            body: JSON.stringify({head, body, id}),
            headers: {
                'content-type': 'application/json'
            }
        });
        if (res.status === 200) {
            button.innerText = 'Send another 😃!';
            button.disabled = false;
            input.value = '';
            textarea.value = '';
        } else {
            errorMsg.innerText = res.message;
            button.innerText = 'Something broke 😢..  Try again?';
            button.disabled = false;
        }
    }
    else {
        let error;
        if (!head || !body){
            error = 'Please ensure you complete the form 🙏🏾'
        }
        else if (!id){
            error = "Are you sure you're logged in? 🤔. Make sure! 👍🏼"
        }
        errorMsg.innerText = error;
    }
});
</code></pre>
<p>Si están presentes los tres parámetros necesarios <code>head</code>, <code>body</code> e <code>id</code>, se envía la solicitud y se deshabilita temporalmente el botón de enviar.</p>

<p>El archivo completo tiene el siguiente aspecto:</p>
<div class="code-label " title="~/djangopush/static/js/site.js">~/djangopush/static/js/site.js</div><pre class="code-pre "><code class="code-highlight language-javascript">const pushForm = document.getElementById('send-push__form');
const errorMsg = document.querySelector('.error');

pushForm.addEventListener('submit', async function (e) {
    e.preventDefault();
    const input = this[0];
    const textarea = this[1];
    const button = this[2];
    errorMsg.innerText = '';

    const head = input.value;
    const body = textarea.value;
    const meta = document.querySelector('meta[name="user_id"]');
    const id = meta ? meta.content : null;

    if (head &amp;&amp; body &amp;&amp; id) {
        button.innerText = 'Sending...';
        button.disabled = true;

        const res = await fetch('/send_push', {
            method: 'POST',
            body: JSON.stringify({head, body, id}),
            headers: {
                'content-type': 'application/json'
            }
        });
        if (res.status === 200) {
            button.innerText = 'Send another 😃!';
            button.disabled = false;
            input.value = '';
            textarea.value = '';
        } else {
            errorMsg.innerText = res.message;
            button.innerText = 'Something broke 😢..  Try again?';
            button.disabled = false;
        }
    }
    else {
        let error;
        if (!head || !body){
            error = 'Please ensure you complete the form 🙏🏾'
        }
        else if (!id){
            error = "Are you sure you're logged in? 🤔. Make sure! 👍🏼"
        }
        errorMsg.innerText = error;
    }    
});
</code></pre>
<p>Por último, agregue el archivo <code>site.js</code> a <code>home.html</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/templates/home.html
</li></ul></code></pre>
<p>Añada la etiqueta <code>script</code>:</p>
<div class="code-label " title="~/djangopush/templates/home.html">~/djangopush/templates/home.html</div><pre class="code-pre "><code class="code-highlight language-html">
{% load static %}
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
   ...
&lt;/head&gt;
&lt;body&gt;
   ...
   <span class="highlight">&lt;script src="{% static '/js/site.js' %}"&gt;&lt;/script&gt;</span>
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>En este punto, si dejó su aplicación en ejecución o intentó iniciarla, verá un error, ya que los trabajos de servicio solo pueden funcionar en dominios seguros o en <code>localhost</code>. En el siguiente paso, usaremos <a href="https://ngrok.com/">ngrok</a> para crear un túnel seguro hacia nuestro servidor web.</p>

<h2 id="paso-10-crear-un-túnel-seguro-para-probar-la-aplicación">Paso 10: Crear un túnel seguro para probar la aplicación</h2>

<p>Los trabajadores de servicio requieren conexiones seguras para funcionar en cualquier sitio, a excepción <code>de localhost,</code> ya que pueden permitir la infiltración maliciosa en las conexiones y la filtración y generación de respuestas. Por este motivo, crearemos un túnel seguro para nuestro servidor con <a href="https://ngrok.com">ngrok</a>.</p>

<p>Abra una segunda ventana de terminal y asegúrese de estar en su directorio de inicio:</p>
<pre class="code-pre command second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd ~
</li></ul></code></pre>
<p>Si comenzó con un servidor 18.04 limpio en los requisitos previos, entonces tendrá que instalar <code>unzip</code>:</p>
<pre class="code-pre command second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt update &amp;&amp; sudo apt install unzip
</li></ul></code></pre>
<p>Descargue ngrok:</p>
<pre class="code-pre command second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="$">wget https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-amd64.zip
</li><li class="line" prefix="$">unzip ngrok-stable-linux-amd64.zip
</li></ul></code></pre>
<p>Mueva <code>ngrok</code> a <code>/usr/local/bin</code>, para tener acceso al comando <code>ngrok</code> desde el terminal:</p>
<pre class="code-pre command second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo mv ngrok /usr/local/bin
</li></ul></code></pre>
<p>En la primera ventana de su terminal, asegúrese de estar posicionado en el directorio de su proyecto e inicie su servidor:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">cd ~/djangopush
</li><li class="line" prefix="(my_env) $">python manage.py runserver <span class="highlight">your_server_ip</span>:8000
</li></ul></code></pre>
<p>Deberá hacerlo antes de crear un túnel seguro para su aplicación.</p>

<p>En la segunda ventana de su terminal, diríjase a la carpeta de su proyecto y active su entorno virtual:</p>
<pre class="code-pre command second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd ~/djangopush
</li><li class="line" prefix="$">source my_env/bin/activate
</li></ul></code></pre>
<p>Cree el túnel seguro a su aplicación:</p>
<pre class="code-pre custom_prefix second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">ngrok http <span class="highlight">your_server_ip</span>:8000
</li></ul></code></pre>
<p>Visualizará el siguiente resultado, que incluye información sobre su URL de ngrok segura:</p>
<pre class="code-pre  second-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>ngrok by <a href="https://www.digitalocean.com/community/users/inconshreveable" class="username-tag">@inconshreveable</a>                                                                                                                       (Ctrl+C to quit)

Session Status                online
Session Expires               7 hours, 59 minutes
Version                       2.2.8
Region                        United States (us)
Web Interface                 http://127.0.0.1:4040
Forwarding                    http://<span class="highlight">ngrok_secure_url</span> -&gt; 203.0.113.0:8000
Forwarding                    https://<span class="highlight">ngrok_secure_url</span> -&gt; 203.0.113.0:8000

Connections                   ttl     opn     rt1     rt5     p50     p90
                              0       0       0.00    0.00    0.00    0.00
</code></pre>
<p>Copie <code><span class="highlight">ngrok_secure_url</span></code> del resultado de la consola. Necesitará añadirlo a la lista de <code>ALLOWED_HOSTS</code> en su archivo <code>settings.py</code>.</p>

<p>Abra otra ventana de terminal, diríjase a la carpeta de su proyecto y active su entorno virtual:</p>
<pre class="code-pre command third-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd ~/djangopush
</li><li class="line" prefix="$">source my_env/bin/activate
</li></ul></code></pre>
<p>Abra el archivo <code>settings.py</code>:</p>
<pre class="code-pre custom_prefix third-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/djangopush/settings.py
</li></ul></code></pre>
<p>Actualice la lista de <code>ALLOWED_HOSTS</code> con el túnel seguro de ngrok:</p>
<div class="code-label " title="~/djangopush/djangopush/settings.py">~/djangopush/djangopush/settings.py</div><pre class="code-pre "><code class="code-highlight language-python">...

ALLOWED_HOSTS = ['your_server_ip', '<span class="highlight">ngrok_secure_url</span>']
...

</code></pre>
<p>Diríjase a la página de administración segura para iniciar sesión: <code>https://<span class="highlight">ngrok_secure_url</span>/admin/</code>. Verá una pantalla similar a esta:</p>

<p><img src="https://assets.digitalocean.com/articles/django_push_18_04/ngrok_login.png" alt="Inicio de sesión de administrador de ngrok"></p>

<p>Introduzca la información de su usuario administrador de Django en esta pantalla. Esta deberá ser la misma información que ingresó cuando inició sesión en la interfaz de administrador en los pasos de los <a href="https://www.digitalocean.com/community/tutorials/how-to-install-the-django-web-framework-on-ubuntu-18-04#testing-the-development-server">requisitos previos</a>. Con esto, estará listo para enviar notificaciones push.</p>

<p>Visite <code>https://<span class="highlight">ngrok_secure_url</span></code> en su navegador. Visualizará un mensaje en el que se solicitará permiso para mostrar notificaciones. Haga clic en el botón <strong>Allow</strong> para permitir que su navegador muestre notificaciones push:</p>

<p><img src="https://assets.digitalocean.com/articles/django_push_18_04/allow_push_two.png" alt="Solicitud de notificaciones push"></p>

<p>Con el envío de un formulario completo se mostrará una notificación similar a la siguiente:</p>

<p><img src="https://assets.digitalocean.com/articles/django_push_18_04/web_push_final.png" alt="Captura de pantalla de la notificación"></p>

<p><span class='note '><strong>Nota:</strong> Asegúrese de que su servidor esté activo antes de intentar enviar notificaciones. </span></p>

<p>Si recibió notificaciones, significa que su aplicación funciona según lo previsto.</p>

<p>Pudo crear una aplicación web que activa notificaciones push en el servidor y, con la ayuda de los trabajados de servicio, recibe y muestra notificaciones. También completó los pasos para obtener las claves de VAPID que se necesitan para enviar notificaciones push desde un servidor de aplicaciones.</p>

<h2 id="conclusión">Conclusión</h2>

<p>A través de este tutorial, aprendió a suscribir usuarios a notificaciones push,instalar trabajados de servicio y mostrar notificaciones push mediante la API de notificaciones.</p>

<p>Puede dar un paso más configurando las notificaciones para que abran áreas específicas de su aplicación cuando se haga clic en ellas. Puede encontrar el código fuente para este tutorial <a href="https://github.com/HackAfro/django-push">aquí</a>.</p>
