---
layout: post
title: Cómo instalar WordPress con Docker Compose
network: digitalocean
date: January 09, 2020 at 05:40PM
url: https://www.digitalocean.com/community/tutorials/how-to-install-wordpress-with-docker-compose-es
image: https://assets.digitalocean.com/articles/docker-wordpress/wp_language_select.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="introducción">Introducción</h3>

<p><a href="https://wordpress.org/">WordPress</a> es un <a href="https://www.digitalocean.com/community/tutorials/digitalocean-community-glossary#content-management-system">sistema de administración de contenido (CMS)</a> gratuito y de código abierto que se desarrolla sobre una base de datos de <a href="https://www.mysql.com/">MySQL</a> con procesamiento <a href="https://www.php.net/">PHP</a>. Gracias a su arquitectura de complemento extensible, a su sistema de plantillas y al hecho de que la mayor parte de su administración pueda realizarse a través de la interfaz web, WordPress es una opción popular al crear diferentes tipos de sitios web, desde blogs hasta páginas de productos y sitios de comercio electrónico.</p>

<p>Ejecutar WordPress normalmente implica instalar una pila <a href="https://www.digitalocean.com/community/tutorials/digitalocean-community-glossary#lamp">LAMP</a> (Linux, Apache, MySQL y PHP) o <a href="https://www.digitalocean.com/community/tutorials/digitalocean-community-glossary#lemp">LEMP</a> (Linux, Nginx, MySQL y PHP), lo cual puede llevar mucho tiempo. Sin embargo, utilizando herramientas como <a href="https://www.docker.com/">Docker</a> y <a href="https://docs.docker.com/compose/">Docker Compose</a>, puede simplificar el proceso de configuración de su pila preferida e instalar WordPress. En lugar de instalar de forma manual componentes individuales, puede utilizar <em>imágenes</em>, que estandarizan aspectos como bibliotecas, archivos de configuración y variables de entorno y ejecutan estas imágenes en <em>contenedores</em>, que son los procesos aislados que se ejecutan en un sistema operativo compartido. Además, al utilizar Compose, puede coordinar varios contenedores, como una aplicación y una base de datos, para comunicarse entre sí.</p>

<p>A través de este tutorial, creará una instalación de WordPress con varios contenedores. Sus contenedores incluirán una base de datos de MySQL, un servidor web de Nginx y el propio WordPress. También protegerá su instalación obteniendo certificados TLS y SSL con <a href="https://letsencrypt.org/">Let´s Encrypt</a> para el dominio que desee asociar a su sitio. Por último, configurará una tarea <a href="https://www.digitalocean.com/community/tutorials/how-to-schedule-routine-tasks-with-cron-and-anacron-on-a-vps"><code>cron</code></a> para renovar sus certificados de modo que su dominio permanezca seguro.</p>

<h2 id="requisitos-previos">Requisitos previos</h2>

<p>Para este tutorial, necesitará lo siguiente:</p>

<ul>
<li>Un servidor con Ubuntu 18.04, un usuario no root con privilegios <code>sudo</code> y un firewall activo. Para obtener información sobre cómo configurarlos, consulte esta <a href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04">guía de configuración inicial para servidores</a>.</li>
<li>Docker instalado en su servidor conforme a los pasos 1 y 2 de <a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-18-04">Cómo instalar y usar Docker en Ubuntu 18.04</a>.</li>
<li>Docker Compose instalado en su servidor conforme el paso 1 de <a href="https://www.digitalocean.com/community/tutorials/how-to-install-docker-compose-on-ubuntu-18-04">Cómo instalar Docker Compose en Ubuntu 18.04</a>.</li>
<li>Un nombre de dominio registrado. En este tutorial, se utilizará <strong>example.com</strong> en todo momento. Puede obtener un ejemplar gratis en <a href="http://www.freenom.com/en/index.html">Freenom</a> o utilizar el registrador de dominios que desee.</li>
<li><p>Los dos registros DNS que se indican a continuación se configuraron para su servidor. Puede seguir <a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-digitalocean-dns">esta introducción al DNS de DigitalOcean</a> para obtener información sobre cómo agregarlos a una cuenta de DigitalOcean, si usa una:</p>

<ul>
<li>Un registro A con <code><span class="highlight">example.com</span>​​​</code> orientado a la dirección IP pública de su servidor.</li>
<li>Un registro A con <code><span class="highlight">example.com</span>​​​</code> ​​orientado a la dirección IP pública de su servidor.</li>
</ul></li>
</ul>

<h2 id="paso-1-definir-la-configuración-del-servidor-web">Paso 1: Definir la configuración del servidor web</h2>

<p>Antes de ejecutar cualquier contenedor, nuestro primer paso será definir la configuración de nuestro servidor web de Nginx. En nuestro archivo de configuración se incluirán algunos bloques de ubicación específicos de WordPress, junto con un bloque de ubicación para dirigir las solicitudes de verificación de Let´s Encrypt al cliente Certbot a fin de renovar los certificados de manera automática.</p>

<p>Primero, cree un directorio de proyecto para su configuración de WordPress llamado <code><span class="highlight">wordpress</span></code> y diríjase a este:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir <span class="highlight">wordpress</span> &amp;&amp; cd <span class="highlight">wordpress</span>
</li></ul></code></pre>
<p>A continuación, cree un directorio para el archivo de configuración:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir nginx-conf
</li></ul></code></pre>
<p>Abra el archivo con <code>nano</code> o su editor favorito:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano nginx-conf/nginx.conf
</li></ul></code></pre>
<p>En este archivo, añadiremos un bloque de servidor con directivas para el nombre del servidor y el root de documento, bloques de ubicación para dirigir la solicitud de certificados del cliente de Certbot, procesamiento de PHP, y solicitudes de recursos estáticos.</p>

<p>Pegue el siguiente código en el archivo. Asegúrese de sustituir <code><span class="highlight">example.com</span></code> por su propio nombre de dominio:</p>
<div class="code-label " title="~/wordpress/nginx-conf/nginx.conf">~/wordpress/nginx-conf/nginx.conf</div><pre class="code-pre "><code langs="">server {
        listen 80;
        listen [::]:80;

        server_name <span class="highlight">example.com</span> www.<span class="highlight">example.com</span>;

        index <span class="highlight">index.php</span> index.html index.htm;

        root /var/www/html;

        location ~ /.well-known/acme-challenge {
                allow all;
                root /var/www/html;
        }

        location / {
                try_files $uri $uri/ /index.php$is_args$args;
        }

        location ~ \.php$ {
                try_files $uri =404;
                fastcgi_split_path_info ^(.+\.php)(/.+)$;
                fastcgi_pass <span class="highlight">wordpress</span>:9000;
                fastcgi_index index.php;
                include fastcgi_params;
                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
                fastcgi_param PATH_INFO $fastcgi_path_info;
        }

        location ~ /\.ht {
                deny all;
        }

        location = /favicon.ico {
                log_not_found off; access_log off;
        }
        location = /robots.txt {
                log_not_found off; access_log off; allow all;
        }
        location ~* \.(css|gif|ico|jpeg|jpg|js|png)$ {
                expires max;
                log_not_found off;
        }
}
</code></pre>
<p>Nuestro bloque de servidor incluye la siguiente información:</p>

<p><strong>Directivas:</strong></p>

<ul>
<li><code>listen</code>: indica a Nginx que escuche en el puerto <code>80</code>, lo que nos permitirá usar el <a href="https://certbot.eff.org/docs/using.html#webroot">complemento webroot</a> de Certbot para nuestras solicitudes de certificados. Tenga en cuenta que aún <em>no</em> incluiremos el puerto <code>443</code>; actualizaremos nuestra configuración para incluir SSL una vez que hayamos obtenido nuestros certificados de manera exitosa.</li>
<li><code>server_name</code>: define el nombre de su servidor y el bloque de servidor que debería utilizarse para las solicitudes a este último. Asegúrese de sustituir <code><span class="highlight">example.com</span></code> en esta línea por su propio nombre de dominio.</li>
<li><code>index</code>: la directiva <code>index</code> define los archivos que se utilizarán como índices al procesar las solicitudes a su servidor. En este caso, modificamos el orden de prioridad predeterminado moviendo <code>index.php</code> en frente de <code>index.html</code> para que Nginx priorice los archivos llamados <code>index.php</code> cuando sea posible.</li>
<li><code>root</code>: nuestra directiva <code>root</code> nombra el directorio root para las solicitudes a nuestro servidor. Este directorio, <code>/var/www/html</code>, se <a href="https://github.com/docker-library/wordpress/blob/07958d19ed465fb7fe50626be740d88a2c2260a7/php7.2/fpm-alpine/Dockerfile#L53">crea como punto de montaje</a> en el momento de la compilación siguiendo instrucciones de nuestro <a href="https://github.com/docker-library/wordpress/blob/07958d19ed465fb7fe50626be740d88a2c2260a7/php7.2/fpm-alpine/Dockerfile">WordPress Dockerfile</a>. Estas instrucciones de Dockerfile también garantizan que los archivos de la versión de WordPress se monten en este volumen.</li>
</ul>

<p><strong>Bloques de ubicación:</strong></p>

<ul>
<li><code>location ~ /.well-known/acme-challenge</code>: este bloque de ubicación manejará las solicitudes al directorio <code>.well-known</code>, donde Certbot creará un archivo temporal para validar la resolución del DNS de nuestro dominio en nuestro servidor. Una vez implementada esta configuración, podremos utilizar el complemento webroot de Certbot a fin de obtener certificados para nuestro dominio.</li>
<li><code>location /</code>: en este bloque de ubicación, utilizaremos una directiva try<code>_files pa</code>ra buscar archivos que coincidan con solicitudes de URI individuales. Sin embargo, en lugar de devolver un estado 404 <code>Not Found</code> por defecto, pasaremos el control al archivo <code>index.php</code> de WordPress con los argumentos de solicitud.</li>
<li><code>location ~ \.php$</code>: este bloque de ubicación se encargará del procesamiento de PHP y servirá como proxy de estas solicitudes a nuestro contenedor de <code>wordpress</code>. Debido a que nuestra imagen de Docker de WordPress se basará en la <a href="https://github.com/docker-library/php/blob/e63194a0006848edb13b7eff5a7f9d790d679428/7.2/alpine3.9/fpm/Dockerfile">imagen <code>php:fpm</code></a>, también incluiremos opciones de configuración que sean específicas para el protocolo <a href="https://en.wikipedia.org/wiki/FastCGI">FastCGI</a> en este bloque. Nginx requiere un procesador de PHP independiente para solicitudes de PHP: en nuestro caso, estas solicitudes estarán a cargo del procesador <code>php-fpm</code> que está incluido con la imagen <code>php:fpm</code>. Además, este bloque de ubicación incluye directivas, variables y opciones específicas de FastCGI que actuarán como proxy para las solicitudes a la aplicación de WordPress que se ejecuten en nuestro contenedor <code>wordpress</code>, establecerán el índice preferido para la URI de la solicitud analizada y analizarán las solicitudes de URI.</li>
<li><code>location ~ /\.ht</code>: este bloque se encargará de archivos <code>.htaccess</code>, ya que Nginx no los proporcionará. La directiva <code>deny_all</code> garantiza que los archivos de <code>.htaccess</code> nunca se proporcionarán a los usuarios.</li>
<li><code>location = /favicon.ico</code>, <code>location = /robots.txt</code>: estos bloques garantizan que las solicitudes a <code>/favicon.ico</code> y <code>/robots.txt</code> no se registren.</li>
<li><code>location ~* \. (css|gifBlog|tox0101jpeg|jpgs|png)$</code>: este bloque desactiva el registro para solicitudes de activos estáticos y garantiza que estos activos tengan altas condiciones de almacenamiento en caché, ya que normalmente su mantenimiento es costoso.</li>
</ul>

<p>Para obtener más información sobre proxy de FastCGI, consulte el artículo <a href="https://www.digitalocean.com/community/tutorials/understanding-and-implementing-fastcgi-proxying-in-nginx">Información e implementación de proxy de FastCGI en Nginx</a>. Para obtener información sobre los bloques de servidor y ubicación, consulte el artículo <a href="https://www.digitalocean.com/community/tutorials/understanding-nginx-server-and-location-block-selection-algorithms">Información sobre algoritmos de selección de bloques de servidores y ubicación de Nginx</a>.</p>

<p>Guarde y cierre el archivo cuando concluya la edición. Si utiliza <code>nano</code>, podrá hacerlo presionando <code>CTRL+X</code>, <code>Y</code> y luego <code>ENTER</code>.</p>

<p>Una vez implementada su configuración de Nginx, puede crear variables de entorno para pasarlas a su aplicación y contenedores de bases de datos en tiempo de ejecución.</p>

<h2 id="paso-2-definir-variables-de-entorno">Paso 2: Definir variables de entorno</h2>

<p>Sus contenedores de bases de datos y aplicaciones de WordPress necesitarán acceso a determinadas variables de entorno en tiempo de ejecución a fin de que los datos de su aplicación persistan y esta pueda acceder a ellos. Estas variables incluyen información confidencial y no confidencial: valores confidenciales para su contraseña <strong>root</strong> de MySQL, y usuario y contraseña de base de datos de aplicación, e información no confidencial para el nombre y host de la base de datos de su aplicación.</p>

<p>En lugar de establecer todos estos valores en nuestro archivo de Docker Compose, el archivo principal que contiene información sobre cómo se ejecutarán nuestros contenedores, podemos establecer los valores confidenciales en un archivo <code>.env</code> y restringir su circulación. Esto impedirá que estos valores se copien en los repositorios de nuestro proyecto y se expongan al público.</p>

<p>En el directorio principal de su proyecto, <code>~/<span class="highlight">wordpress</span></code>, abra un archivo llamado <code>.env</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano .env
</li></ul></code></pre>
<p>Entre los valores confidenciales que configuraremos en este archivo se incluyen una contraseña para nuestro usuario root de <strong>MySQL</strong> y un nombre de usuario y contraseña que WordPress usará para acceder a la base de datos.</p>

<p>Añada los siguientes nombres y valores de variables al archivo. Recuerde proporcionar aquí <strong>sus propios valores</strong> para cada variable:</p>
<div class="code-label " title="~/wordpress/.env">~/wordpress/.env</div><pre class="code-pre "><code langs="">MYSQL_ROOT_PASSWORD=<span class="highlight">your_root_password</span>
MYSQL_USER=<span class="highlight">your_wordpress_database_user</span>
MYSQL_PASSWORD=<span class="highlight">your_wordpress_database_password</span>
</code></pre>
<p>Hemos incluido una contraseña para la cuenta administrativa <strong>root</strong>, además de nuestro nombre de usuario y contraseña preferidos para la base de datos de nuestra aplicación.</p>

<p>Guarde y cierre el archivo cuando concluya la edición.</p>

<p>Debido a que su archivo <code>.env</code> contiene información confidencial, le convendrá asegurarse de que esté incluido en los archivos <code>.gitignore</code> y <code>.dockerignore</code> de su proyecto, los cuales indican a <a href="https://www.digitalocean.com/community/tutorials/how-to-use-git-a-reference-guide">Git</a> y <strong>Docker</strong> qué archivos no deben copiarse a sus repositorios Git e imágenes Docker, respectivamente.</p>

<p>Si planea trabajar con Git para el control de versiones, <a href="https://www.digitalocean.com/community/tutorials/how-to-use-git-a-reference-guide#set-up-and-initialization">inicialice su directorio de trabajo actual como un repositorio</a> con <code>git init</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">git init
</li></ul></code></pre>
<p>A continuación abra un archivo <code>.gitignore</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano .gitignore
</li></ul></code></pre>
<p>Añada <code>.env</code> al archivo:</p>
<div class="code-label " title="~/wordpress/.gitignore">~/wordpress/.gitignore</div><pre class="code-pre "><code langs="">.env
</code></pre>
<p>Guarde y cierre el archivo cuando concluya la edición.</p>

<p>Asimismo, es una buena medida de precaución añadir <code>.env</code> a un archivo <code>.dockerignore</code>, para que no termine en sus contenedores cuando esté usando este directorio como su contexto de compilación.</p>

<p>Abra el archivo:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano .dockerignore
</li></ul></code></pre>
<p>Añada <code>.env</code>  al archivo:</p>
<div class="code-label " title="~/wordpress/.dockerignore">~/wordpress/.dockerignore</div><pre class="code-pre "><code langs="">.env
</code></pre>
<p>Debajo de esto, puede añadir de manera opcional archivos y directorios asociados con el desarrollo de su aplicación:</p>
<div class="code-label " title="~/wordpress/.dockerignore">~/wordpress/.dockerignore</div><pre class="code-pre "><code langs="">.env
.git
docker-compose.yml
.dockerignore
</code></pre>
<p>Guarde y cierre el archivo cuando termine.</p>

<p>Ahora que estableció su información confidencial, podrá definir sus servicios en un archivo <code>docker-compose.yml</code>.</p>

<h2 id="paso-3-definir-servicios-con-docker-compose">Paso 3: Definir servicios con Docker Compose</h2>

<p>Su archivo <code>docker-compose.yml</code> contendrá las definiciones de servicios para su configuración. Un <em>servicio</em> en Compose es un contenedor en ejecución y las definiciones de servicios especifican información sobre cómo se ejecutará cada contenedor.</p>

<p>Mediante Compose, puede definir diferentes servicios para ejecutar aplicaciones en varios contenedores, ya que Compose le permite establecer un enlace entre estos servicios y redes y volúmenes compartidos. Esto será útil para nuestra configuración actual, ya que crearemos diferentes contenedores para nuestra base de datos, nuestras aplicaciones de WordPress y nuestro servidor web. También crearemos un contenedor para ejecutar el <a href="https://certbot.eff.org/">cliente de Certbot</a>, a fin de obtener certificados para nuestro servidor web.</p>

<p>Para comenzar, abra el archivo <code>docker-compose.yml</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano docker-compose.yml
</li></ul></code></pre>
<p>Añada el siguiente código para definir su versión del archivo de Compose y el servicio de base de datos <code>db</code>:</p>
<div class="code-label " title="~/wordpress/docker-compose.yml">~/wordpress/docker-compose.yml</div><pre class="code-pre "><code langs="">version: '3'

services:
  db:
    image: mysql:<span class="highlight">8.0</span>
    container_name: db
    restart: unless-stopped
    env_file: .env
    environment:
      - MYSQL_DATABASE=<span class="highlight">wordpress</span>
    volumes:
      - dbdata:/var/lib/mysql
    command: '--default-authentication-plugin=mysql_native_password'
    networks:
      - app-network
</code></pre>
<p>La definición del servicio <code>db</code> contiene las siguientes opciones:</p>

<ul>
<li><code>image</code>: indica a Compose la imagen que debe obtener para crear el contenedor. En este caso, fijaremos la <a href="https://github.com/docker-library/mysql/blob/130bd8e46a3da1adfc1732a08c70673e20aa5977/8.0/Dockerfile">imagen de <code>mysql:<span class="highlight">8.0</span></code></a> para evitar futuros conflictos, ya que la imagen <code>mysql:latest</code> continúa en proceso de actualización. Para obtener más información sobre la fijación de versiones y evitar conflictos de dependencias, consulte la documentación de Docker sobre <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">prácticas recomendadas de Dockerfile</a>.</li>
<li><code>container_name</code>: especifica un nombre para el contenedor.</li>
<li><code>restart:</code> define la política de reinicio del contenedor. El valor predeterminado es <code>no</code>, pero configuramos el contenedor para reiniciarse a menos que se detenga de manera manual.</li>
<li><code>env_file</code>: esta opción indica a Compose que deseamos añadir variables de entorno de un archivo llamado <code>.env</code>, ubicado en nuestro contexto de compilación. En este caso, el contexto de compilación es nuestro directorio actual.</li>
<li><code>environment</code>: esta opción le permite añadir variables de entorno, más allá de las definidas en su <code>archivo .env</code>. Estableceremos la variable <code>MYSQL_DATABASE</code> de modo que sea igual a <code><span class="highlight">wordpress</span>,</code> a fin de proporcionar un nombre para la base de datos de nuestra aplicación. Debido a que se trata de información no confidencial, podemos incluirla de forma directa en el archivo <code>docker-compose.yml</code>.</li>
<li><code>volumes</code>: aquí montaremos un <a href="https://docs.docker.com/storage/volumes/">volumen</a> con nombre llamado <code>dbdata</code> en el directorio <code>/var/lib/mysql</code> del contenedor. Este es el directorio de datos estándar para MySQL en la mayoría de las distribuciones.</li>
<li><code>command</code>: esta opción especifica un comando para anular la <a href="https://docs.docker.com/engine/reference/builder/#cmd">instrucción CMD</a> predeterminada para la imagen. En nuestro caso, añadiremos una opción al <a href="https://dev.mysql.com/doc/refman/8.0/en/mysqld.html">comando estándar de <code>mysqld</code></a> de Docker, que inicia el servidor de MySQL en el contenedor. Esta opción, <code>--default-authentication-plugin=mysql_native_password</code>, fija la variable de sistema <code>--default-authentication-plugin</code> en <code>mysql_native_password y especifica</code> el mecanismo de autenticación que debe regir las nuevas solicitudes de autenticación al servidor. Debido a que PHP y, por lo tanto, nuestra imagen de WordPress <a href="https://github.com/docker-library/wordpress/issues/313">no son compatibles</a> con la <a href="https://mysqlserverteam.com/upgrading-to-mysql-8-0-default-authentication-plugin-considerations/">nueva autenticación predeterminada de MySQL</a>, debemos realizar este ajuste para autenticar el usuario de base de datos de nuestra aplicación.</li>
<li><code>networks</code>: especifica que nuestro servicio de aplicación se unirá a la red <code>app-network</code>, que definiremos al final del archivo.</li>
</ul>

<p>A continuación, debajo de su definición de servicio <code>db</code>, agregue la definición para el servicio de su aplicación <code>wordpress</code>:</p>
<div class="code-label " title="~/wordpress/docker-compose.yml">~/wordpress/docker-compose.yml</div><pre class="code-pre "><code langs="">...
  wordpress:
    depends_on:
      - db
    image: wordpress:<span class="highlight">5.1.1</span>-fpm-alpine
    container_name: wordpress
    restart: unless-stopped
    env_file: .env
    environment:
      - WORDPRESS_DB_HOST=db:3306
      - WORDPRESS_DB_USER=$MYSQL_USER
      - WORDPRESS_DB_PASSWORD=$MYSQL_PASSWORD
      - WORDPRESS_DB_NAME=<span class="highlight">wordpress</span>
    volumes:
      - wordpress:/var/www/html
    networks:
      - app-network
</code></pre>
<p>En esta definición de servicio, nombraremos nuestro contenedor y definiremos una política de reinicio, como hicimos con el servicio <code>db</code>. También añadiremos algunas opciones específicas de este contenedor:</p>

<ul>
<li><code>depends_on</code>: esta opción garantiza que nuestros contenedores se inicien por orden de dependencia; el contenedor de <code>wordpress</code> comenzará después del contenedor de <code>db</code>. Nuestra aplicación de WordPress depende de la existencia de nuestra base de datos y usuario, por lo que expresar este orden de dependencia permitirá que nuestra aplicación se inicie de forma adecuada.</li>
<li><code>image</code>: para esta configuración, usaremos la <a href="https://github.com/docker-library/wordpress/blob/07958d19ed465fb7fe50626be740d88a2c2260a7/php7.2/fpm-alpine/Dockerfile">imagen de WordPress <code><span class="highlight">5.1.1</span>-fpm-alpine</code>.</a> Como se mencionó en el <a href="https://www.digitalocean.com/community/tutorials/how-to-install-wordpress-with-docker-compose#step-1-%E2%80%94-defining-the-web-server-configuration">paso 1</a>, usar esta imagen garantiza que nuestra aplicación tenga el procesador <code>php-fpm</code> que Nginx requiere para manejar el procesamiento de PHP. Esta imagen también es <code>alpine</code>, derivada del proyecto <a href="https://alpinelinux.org/">Alpine Linux, y per</a>mitirá que el tamaño de nuestra imagen sea en general reducido. Para obtener más información sobre las ventajas y desventajas del uso de imágenes <code>alpine</code> y si esto tiene o no sentido para su aplicación, consulte el análisis completo en la sección <strong>Variantes de imágenes</strong> de la <a href="https://hub.docker.com/_/wordpress">página de imagenes de WordPress de Docker Hub</a>.</li>
<li><code>env_file</code>: nuevamente, especificaremos que queremos introducir valores de nuestro archivo <code>.env</code>, ya que es aquí donde definimos el usuario y la contraseña de la base de datos de nuestra aplicación.</li>
<li><code>environment</code>: aquí, usaremos los valores que definimos en nuestro archivo <code>.env</code>, pero los asignaremos a los nombres de las variables previstas por la imagen de <code>WordPress: WORDPRESS_DB_USER</code> y <code>WORDPRESS_DB_PASSWORD</code>. También definiremos un <code>WORDPRESS_DB_HOST</code>, que será el servidor de MySQL que se ejecutará en el contenedor <code>db</code> al que se puede acceder en el puerto predeterminado <code>3306</code> de MySQL. Nuestro <code>WORDPRESS_DB_NAME</code> será el mismo valor que especificamos en la definición del servicio de MySQL para nuestra <code>MYSQL_DATABASE</code>: <code><span class="highlight">wordpress</span></code>.</li>
<li><code>volumes:</code> montaremos un volumen llamado <code>wordpress</code> en el punto de montaje <code>/var/www/html</code> creado por la imagen de <a href="https://github.com/docker-library/wordpress/blob/07958d19ed465fb7fe50626be740d88a2c2260a7/php7.2/fpm-alpine/Dockerfile#L53">WordPress</a>. Usar un volumen con nombre de esta manera nos permitirá compartir el código de nuestra aplicación con otros contenedores.</li>
<li><code>networks</code>: también añadiremos el contenedor <code>wordpress</code> a la red <code>app-network</code>.</li>
</ul>

<p>A continuación, debajo de la definición del servicio de la aplicación <code>wordpress</code>, agregue la siguiente definición para su servicio de Nginx <code>webserver</code>:</p>
<div class="code-label " title="~/wordpress/docker-compose.yml">~/wordpress/docker-compose.yml</div><pre class="code-pre "><code langs="">...
  webserver:
    depends_on:
      - wordpress
    image: nginx:<span class="highlight">1.15.12</span>-alpine
    container_name: webserver
    restart: unless-stopped
    ports:
      - "80:80"
    volumes:
      - wordpress:/var/www/html
      - ./nginx-conf:/etc/nginx/conf.d
      - certbot-etc:/etc/letsencrypt
    networks:
      - app-network
</code></pre>
<p>De nuevo, nombraremos nuestro contenedor y haremos que dependa del contenedor de <code>wordpress</code> por orden de inicio. También usaremos una imagen <code>alpine</code>, la <a href="https://github.com/nginxinc/docker-nginx/blob/e5123eea0d29c8d13df17d782f15679458ff899e/mainline/stretch/Dockerfile">imagen <code><span class="highlight">1.15.12</span>-alpine</code> de Nginx</a>.</p>

<p>Esta definición de servicio también incluye las siguientes opciones:</p>

<ul>
<li><code>ports</code>: expone el puerto <code>80</code> para habilitar las opciones de configuración que definimos en nuestro archivo <code>nginx.conf</code> en el <a href="">paso 1</a>.</li>
<li><code>volumes</code>: aquí definiremos una combinación de volúmenes nombrados y <a href="https://docs.docker.com/storage/bind-mounts/">montajes “bind”</a>:

<ul>
<li><code>wordpress:/var/www/html</code>: montará el código de nuestra aplicación de WordPress en el directorio <code>/var/www/html</code>, el que configuramos como <code>root</code> en nuestro bloque de servidor de Nginx.</li>
<li><code>./nginx-conf:/etc/nginx/conf.d</code>: vinculará mediante montaje “bind” el directorio de configuración de Nginx en el host con el directorio pertinente del contenedor, lo cual garantizará que cualquier cambio que realicemos en los archivos del host se refleje en el contenedor.</li>
<li><code>certbot-etc:/etc/letsencrypt:</code> montará los certificados y las claves pertinentes de Let&rsquo;s Encrypt para nuestro dominio en el directorio correspondiente del contenedor.</li>
</ul></li>
</ul>

<p>Una vez más, agregamos este contenedor a la red <code>app-network</code>.</p>

<p>Por último, debajo de su definición de <code>webserver</code>, agregue su última definición de servicio para el servicio <code>certbot</code>. Asegúrese de sustituir la dirección de correo electrónico y los nombres de dominio que aparecen aquí por su propia información:</p>
<div class="code-label " title="~/wordpress/docker-compose.yml">~/wordpress/docker-compose.yml</div><pre class="code-pre "><code langs="">  certbot:
    depends_on:
      - webserver
    image: certbot/certbot
    container_name: certbot
    volumes:
      - certbot-etc:/etc/letsencrypt
      - wordpress:/var/www/html
    command: certonly --webroot --webroot-path=/var/www/html --email <span class="highlight">sammy@example.com</span> --agree-tos --no-eff-email --staging -d <span class="highlight">example.com</span> -d www.<span class="highlight">example.com</span>
</code></pre>
<p>Esta definición indica a Compose que introduzca la <a href="https://hub.docker.com/r/certbot/certbot/">imagen <code>certbot/certbot</code></a> de Docker Hub. También utiliza volúmenes nombrados para compartir recursos con el contenedor de Nginx, incluidos los certificados de dominio y la clave de <code>certbot-etc</code>, y el código de la aplicación en <code>wordpress</code>.</p>

<p>Una vez más, usamos <code>depends_on</code> para especificar que el contenedor <code>certbot</code> debe iniciarse una vez que el servicio <code>webserver</code> esté en ejecución.</p>

<p>También incluimos una opción de <code>command</code> que especifica un subcomando que debe ejecutarse con el comando de <code>certbot</code> predeterminado del contenedor. El <a href="https://certbot.eff.org/docs/using.html#certbot-command-line-options">subcomando <code>certonly</code></a> obtendrá un certificado con las siguientes opciones:</p>

<ul>
<li><code>--webroot:</code> indica a Cerbot que utilice el complemento webroot a fin de colocar archivos en la carpeta webroot para la autenticación. Este complemento depende del <a href="https://tools.ietf.org/html/draft-ietf-acme-acme-03#section-7.2">método de validación HTTP-01</a>, que utiliza una solicitud HTTP para probar que Certbot puede acceder a los recursos de un servidor que responda a un nombre de dominio determinado.</li>
<li><code>--webroot-path</code>: esto especifica la ruta del directorio webroot.</li>
<li><code>--email</code>: su correo electrónico preferido para el registro y la recuperación.</li>
<li><code>--agree-tos</code>: especifica que acepta el <a href="https://letsencrypt.org/documents/LE-SA-v1.2-November-15-2017.pdf">Acuerdo de suscripción de ACME</a>.</li>
<li><code>--no-eff-email</code>: indica a Certbot que usted no desea compartir su correo electrónico con la <a href="https://www.eff.org/">Electronic Frontier Foundation</a> (EFF). Puede omitirlo si lo prefiere.</li>
<li><code>--staging</code>: indica a Certbot que desea utilizar el entorno de configuración de Let&rsquo;s Encrypt para obtener certificados de prueba. Utilizar esta opción le permite probar sus opciones de configuración y evitar posibles límites vinculados a solicitudes de dominio. Para obtener más información sobre estos límites, consulte la <a href="https://letsencrypt.org/docs/rate-limits/">documentación sobre los límites de tasas</a> de Let&rsquo;s Encrypt.</li>
<li><code>-d:</code> le permite especificar los nombres de dominio que desee aplicar a su solicitud. En este caso, incluimos <code><span class="highlight">example.com</span></code> y <code>www.<span class="highlight">example.com</span></code>. Asegúrese de sustituirlos por su propio dominio.</li>
</ul>

<p>Debajo de la definición de servicio <code>certbot</code>, agregue sus definiciones de red y volumen:</p>
<div class="code-label " title="~/wordpress/docker-compose.yml">~/wordpress/docker-compose.yml</div><pre class="code-pre "><code langs="">...
volumes:
  certbot-etc:
  wordpress:
  dbdata:

networks:
  app-network:
    driver: bridge  
</code></pre>
<p>Nuestra clave de alto nivel <code>volumes</code> define los volúmenes <code>certbot-etc</code>, <code>wordpress</code> y <code>dbdata</code>. Cuando Docker crea volúmenes, el contenido del volumen se almacena en un directorio del sistema de archivos host, <code>/var/ib/docker/volume/</code>, que Docker administra. El contenido de cada volumen luego se monta desde este directorio en cualquier contenedor que utilice el volumen en cuestión. De esta manera, es posible compartir códigos y datos entre contenedores.</p>

<p>La red de puente definida por el usuario <code>app-network</code> permite la comunicación entre nuestros contenedores, ya que están en el mismo host de demonio de Docker. Esto agiliza el tráfico y la comunicación dentro de la aplicación, ya que abre todos los puertos entre contenedores en la misma red de puente sin exponer ningún puerto al mundo exterior. Por lo tanto, nuestros contenedores <code>db</code>, <code>wordpress</code> y <code>webserver</code> pueden comunicarse entre sí y solo debemos exponer el puerto <code>80</code> para el acceso de front-end a la aplicación.</p>

<p>El archivo <code>docker-compose.yml</code> terminado tendrá este aspecto:</p>
<div class="code-label " title="~/wordpress/docker-compose.yml">~/wordpress/docker-compose.yml</div><pre class="code-pre "><code langs="">version: '3'

services:
  db:
    image: mysql:<span class="highlight">8.0</span>
    container_name: db
    restart: unless-stopped
    env_file: .env
    environment:
      - MYSQL_DATABASE=<span class="highlight">wordpress</span>
    volumes:
      - dbdata:/var/lib/mysql
    command: '--default-authentication-plugin=mysql_native_password'
    networks:
      - app-network

  wordpress:
    depends_on:
      - db
    image: wordpress:<span class="highlight">5.1.1</span>-fpm-alpine
    container_name: wordpress
    restart: unless-stopped
    env_file: .env
    environment:
      - WORDPRESS_DB_HOST=db:3306
      - WORDPRESS_DB_USER=$MYSQL_USER
      - WORDPRESS_DB_PASSWORD=$MYSQL_PASSWORD
      - WORDPRESS_DB_NAME=<span class="highlight">wordpress</span>
    volumes:
      - wordpress:/var/www/html
    networks:
      - app-network

  webserver:
    depends_on:
      - wordpress
    image: nginx:<span class="highlight">1.15.12</span>-alpine
    container_name: webserver
    restart: unless-stopped
    ports:
      - "80:80"
    volumes:
      - wordpress:/var/www/html
      - ./nginx-conf:/etc/nginx/conf.d
      - certbot-etc:/etc/letsencrypt
    networks:
      - app-network

  certbot:
    depends_on:
      - webserver
    image: certbot/certbot
    container_name: certbot
    volumes:
      - certbot-etc:/etc/letsencrypt
      - wordpress:/var/www/html
    command: certonly --webroot --webroot-path=/var/www/html --email <span class="highlight">sammy@example.com</span> --agree-tos --no-eff-email --staging -d <span class="highlight">example.com</span> -d www.<span class="highlight">example.com</span>

volumes:
  certbot-etc:
  wordpress:
  dbdata:

networks:
  app-network:
    driver: bridge  
</code></pre>
<p>Guarde y cierre el archivo cuando concluya la edición.</p>

<p>Una vez configuradas las definiciones de servicio, estará listo para iniciar los contenedores y probar las solicitudes de su certificado.</p>

<h2 id="paso-4-obtener-certificados-y-credenciales-ssl">Paso 4: Obtener certificados y credenciales SSL</h2>

<p>Podemos iniciar nuestros contenedores con el comando <a href="https://docs.docker.com/compose/reference/up/"><code>docker-compose up</code></a>, que creará y ejecutará nuestros contenedores en el orden que especificamos. Si las solicitudes de nuestros dominios tienen éxito, veremos el estado de salida correcto en nuestro resultado y los certificados correctos montados en la carpeta <code>/etc/letsencrypt/live</code> del contenedor <code>webserver</code>.</p>

<p>Cree los contenedores con <a href="https://docs.docker.com/compose/reference/up/"><code>docker-compose up</code></a> y el indicador <code>-d</code>, que ejecutarán los contenedores  <code>db</code>, <code>wordpress</code> y <code>webserver</code> en segundo plano:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose up -d
</li></ul></code></pre>
<p>Verá un resultado que confirmará la creación de sus servicios:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Creating db ... done
Creating wordpress ... done
Creating webserver ... done
Creating certbot   ... done
</code></pre>
<p>Mediante <a href="https://docs.docker.com/compose/reference/ps/"><code>docker-compose ps</code></a>, compruebe el estado de sus servicios:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose ps
</li></ul></code></pre>
<p>Si todo se realizó correctamente, el estado de sus servicios de <code>db</code>, <code>wordpress</code> y <code>webserver</code> será <code>Up</code> y el contenedor <code>certbot</code> se habrá cerrado con el mensaje de estado <code>0</code>:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>  Name                 Command               State           Ports       
-------------------------------------------------------------------------
certbot     certbot certonly --webroot ...   Exit 0                      
db          docker-entrypoint.sh --def ...   Up       3306/tcp, 33060/tcp
webserver   nginx -g daemon off;             Up       0.0.0.0:80-&gt;80/tcp
wordpress   docker-entrypoint.sh php-fpm     Up       9000/tcp           
</code></pre>
<p>Si ve algo diferente de <code>Up</code> en la columna <code>State</code> para los servicios <code>db</code>, <code>wordpress</code> o  <code>webserver</code>, o un estado de salida distinto a <code>0</code> para el contenedor <code>certbot</code>, asegúrese de verificar los registros de servicio con el comando <a href="https://docs.docker.com/compose/reference/logs/"><code>docker-compose logs</code></a>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose logs <span class="highlight">service_name</span>
</li></ul></code></pre>
<p>Ahora podrá verificar que sus certificados se hayan montado en el contenedor <code>webserver</code> con <a href="https://docs.docker.com/compose/reference/exec/"><code>docker-compose exec</code></a>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose exec webserver ls -la /etc/letsencrypt/live
</li></ul></code></pre>
<p>Si sus solicitudes de certificado se completan de forma correcta, verá un resultado como este:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>total 16
drwx------    3 root     root          4096 May 10 15:45 .
drwxr-xr-x    9 root     root          4096 May 10 15:45 ..
-rw-r--r--    1 root     root           740 May 10 15:45 README
drwxr-xr-x    2 root     root          4096 May 10 15:45 <span class="highlight">example.com</span>
</code></pre>
<p>Ahora que sabe que su solicitud será correcta, puede editar la definición de servicio <code>certbot</code> para eliminar el marcador <code>--staging</code>.</p>

<p>Abra <code>docker-compose.yml</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano docker-compose.yml
</li></ul></code></pre>
<p>Encuentre la sección del archivo con la definición de servicio <code>certbot</code> y sustituya el indicador <code>--staging</code> en la opción <code>command</code> por el indicador <code>--force-renewal</code>, el cual indicará a Certbot que desea solicitar un nuevo certificado con los mismos dominios que un certificado existente. Ahora, la definición de servicio <code>certbot</code> tendrá este aspecto:</p>
<div class="code-label " title="~/wordpress/docker-compose.yml">~/wordpress/docker-compose.yml</div><pre class="code-pre "><code langs="">...
  certbot:
    depends_on:
      - webserver
    image: certbot/certbot
    container_name: certbot
    volumes:
      - certbot-etc:/etc/letsencrypt
      - certbot-var:/var/lib/letsencrypt
      - wordpress:/var/www/html
    command: certonly --webroot --webroot-path=/var/www/html --email <span class="highlight">sammy@example.com</span> --agree-tos --no-eff-email <span class="highlight">--force-renewal</span> -d <span class="highlight">example.com</span> -d www.<span class="highlight">example.com</span>
...
</code></pre>
<p>Ahora podrá ejecutar <code>docker-compose</code> para recrear el contenedor <code>certbot</code>. También incluiremos la opción <code>--no-deps</code> para indicar a Compose que puede omitir el inicio del servicio <code>webserver</code>, dado que ya está en ejecución:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose up --force-recreate --no-deps certbot
</li></ul></code></pre>
<p>Verá un resultado que indicará que su solicitud de certificado fue exitosa:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Recreating certbot ... done
Attaching to certbot
certbot      | Saving debug log to /var/log/letsencrypt/letsencrypt.log
certbot      | Plugins selected: Authenticator webroot, Installer None
certbot      | Renewing an existing certificate
certbot      | Performing the following challenges:
certbot      | http-01 challenge for <span class="highlight">example.com</span>
certbot      | http-01 challenge for www.<span class="highlight">example.com</span>
certbot      | Using the webroot path /var/www/html for all unmatched domains.
certbot      | Waiting for verification...
certbot      | Cleaning up challenges
certbot      | IMPORTANT NOTES:
certbot      |  - Congratulations! Your certificate and chain have been saved at:
certbot      |    /etc/letsencrypt/live/<span class="highlight">example.com</span>/fullchain.pem
certbot      |    Your key file has been saved at:
certbot      |    /etc/letsencrypt/live/<span class="highlight">example.com</span>/privkey.pem
certbot      |    Your cert will expire on 2019-08-08. To obtain a new or tweaked
certbot      |    version of this certificate in the future, simply run certbot
certbot      |    again. To non-interactively renew *all* of your certificates, run
certbot      |    "certbot renew"
certbot      |  - Your account credentials have been saved in your Certbot
certbot      |    configuration directory at /etc/letsencrypt. You should make a
certbot      |    secure backup of this folder now. This configuration directory will
certbot      |    also contain certificates and private keys obtained by Certbot so
certbot      |    making regular backups of this folder is ideal.
certbot      |  - If you like Certbot, please consider supporting our work by:
certbot      |
certbot      |    Donating to ISRG / Let's Encrypt:   https://letsencrypt.org/donate
certbot      |    Donating to EFF:                    https://eff.org/donate-le
certbot      |
certbot exited with code 0
</code></pre>
<p>Una vez implementados sus certificados, podrá modificar su configuración de Nginx para incluir SSL.</p>

<h2 id="paso-5-modificar-la-configuración-del-servidor-web-y-la-definición-del-servicio">Paso 5: Modificar la configuración del servidor web y la definición del servicio</h2>

<p>Habilitar SSL en nuestra configuración de Nginx implicará añadir un redireccionamiento HTTP a HTTPS especificando nuestras ubicaciones de certificados y claves SSL, y agregando parámetros y encabezados de seguridad.</p>

<p>Debido a que recreará el servicio <code>webserver</code> para incluir estas adiciones, puede detenerlo ahora:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose stop webserver
</li></ul></code></pre>
<p>Antes de modificar el propio archivo de configuración, primero obtendremos los <a href="https://github.com/certbot/certbot/blob/master/certbot-nginx/certbot_nginx/tls_configs/options-ssl-nginx.conf">parámetros de seguridad de Nginx recomendados</a> de Certbot usando <code>curl</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">curl -sSLo nginx-conf/options-ssl-nginx.conf https://raw.githubusercontent.com/certbot/certbot/master/certbot-nginx/certbot_nginx/tls_configs/options-ssl-nginx.conf
</li></ul></code></pre>
<p>Con este comando se guardará estos parámetros en un archivo llamado <code>options-ssl-nginx.conf</code>, ubicado en el directorio <code>nginx-conf</code>.</p>

<p>A continuación, elimine el archivo de configuración de Nginx que creó anteriormente:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">rm nginx-conf/nginx.conf
</li></ul></code></pre>
<p>Abra otra versión del archivo:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano nginx-conf/nginx.conf
</li></ul></code></pre>
<p>Añada el siguiente código al archivo para redireccionar HTTP a HTTP y para agregar credenciales, protocolos y encabezados de seguridad SSL. Recuerde sustituir <code><span class="highlight">example.com</span></code> por su propio dominio:</p>
<div class="code-label " title="~/wordpress/nginx-conf/nginx.conf">~/wordpress/nginx-conf/nginx.conf</div><pre class="code-pre "><code langs="">server {
        listen 80;
        listen [::]:80;

        server_name <span class="highlight">example.com</span> www.<span class="highlight">example.com</span>;

        location ~ /.well-known/acme-challenge {
                allow all;
                root /var/www/html;
        }

        location / {
                rewrite ^ https://$host$request_uri? permanent;
        }
}

server {
        listen 443 ssl http2;
        listen [::]:443 ssl http2;
        server_name <span class="highlight">example.com</span> www.<span class="highlight">example.com</span>;

        index index.php index.html index.htm;

        root /var/www/html;

        server_tokens off;

        ssl_certificate /etc/letsencrypt/live/<span class="highlight">example.com</span>/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/<span class="highlight">example.com</span>/privkey.pem;

        include /etc/nginx/conf.d/options-ssl-nginx.conf;

        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header Referrer-Policy "no-referrer-when-downgrade" always;
        add_header Content-Security-Policy "default-src * data: 'unsafe-eval' 'unsafe-inline'" always;
        # add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
        # enable strict transport security only if you understand the implications

        location / {
                try_files $uri $uri/ /index.php$is_args$args;
        }

        location ~ \.php$ {
                try_files $uri =404;
                fastcgi_split_path_info ^(.+\.php)(/.+)$;
                fastcgi_pass <span class="highlight">wordpress</span>:9000;
                fastcgi_index index.php;
                include fastcgi_params;
                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
                fastcgi_param PATH_INFO $fastcgi_path_info;
        }

        location ~ /\.ht {
                deny all;
        }

        location = /favicon.ico {
                log_not_found off; access_log off;
        }
        location = /robots.txt {
                log_not_found off; access_log off; allow all;
        }
        location ~* \.(css|gif|ico|jpeg|jpg|js|png)$ {
                expires max;
                log_not_found off;
        }
}
</code></pre>
<p>El bloque de servidor HTTP especifica el webroot para solicitudes de renovación de Certbot al directorio <code>.well-known/acme-challenge</code>. También incluye una <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite">directiva de reescritura</a> que dirige las solicitudes HTTP al directorio root hacia HTTPS.</p>

<p>El bloque de servidor HTTPS habilita <code>ssl</code> y <code>http2</code>. Para obtener más información sobre la iteración de HTTP/2 en protocolos HTTP y los beneficios que puede tener para el rendimiento de sitios web, consulte la introducción de <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-nginx-with-http-2-support-on-ubuntu-18-04">Cómo configurar Nginx con compatibilidad para HTTP/2 en Ubuntu 18.04</a>.</p>

<p>En este bloque también se incluyen las ubicaciones de nuestros certificados y claves SSL, junto con los parámetros de seguridad de Certbot recomendados que guardamos en <code>nginx-conf/options-ssl-nginx.conf</code>.</p>

<p>Además, incluimos algunos encabezados de seguridad que nos permitirán obtener las calificaciones <strong>A</strong> en aspectos como los sitios de prueba de servidores de <a href="https://www.ssllabs.com/ssltest/">SSL Labs</a> y <a href="https://securityheaders.com/">Security Headers</a>. Entre estos encabezados se incluyen<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options"><code>X-frame-Options</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options"><code>X-Content-Type-Options</code></a>, <a href="https://scotthelme.co.uk/a-new-security-header-referrer-policy/"><code>Referer Policy</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy"><code>Content-Security-Policy</code></a> y <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection"><code>X-XSS-Protection</code></a>. El encabezado <a href="https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security">HTTP <code>Strict Transport Security</code></a> (HSTS) no se incluye: habilítelo solo si comprende las implicaciones y evaluó su <a href="https://hstspreload.org/">funcionalidad de “precarga”</a>.</p>

<p>Nuestras directivas <code>root</code> e <code>index</code> también se encuentran en este bloque, al igual que el resto de los bloques de ubicación específicos de WordPress analizados en el <a href="https://www.digitalocean.com/community/tutorials/how-to-install-wordpress-with-docker-compose#step-1-%E2%80%94-defining-the-web-server-configuration">paso 1</a>.</p>

<p>Una vez que finalice la edición, guarde y cierre el archivo.</p>

<p>Antes de recrear el servicio <code>webserver</code>, deberá añadir una asignación del puerto <code>443</code> a su definición de servicio <code>webserver</code>.</p>

<p>Abra su archivo <code>docker-compose.yml</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano docker-compose.yml
</li></ul></code></pre>
<p>En la definición de servicio <code>webserver</code>, agregue la siguiente asignación de puerto:</p>
<div class="code-label " title="~/wordpress/docker-compose.yml">~/wordpress/docker-compose.yml</div><pre class="code-pre "><code langs="">...
  webserver:
    depends_on:
      - wordpress
    image: nginx:<span class="highlight">1.15.12</span>-alpine
    container_name: webserver
    restart: unless-stopped
    ports:
      - "80:80"
      - <span class="highlight">"443:443"</span>
    volumes:
      - wordpress:/var/www/html
      - ./nginx-conf:/etc/nginx/conf.d
      - certbot-etc:/etc/letsencrypt
    networks:
      - app-network
</code></pre>
<p>El archivo <code>docker-compose.yml</code> tendrá este aspecto al terminar la operación:</p>
<div class="code-label " title="~/wordpress/docker-compose.yml">~/wordpress/docker-compose.yml</div><pre class="code-pre "><code langs="">version: '3'

services:
  db:
    image: mysql:<span class="highlight">8.0</span>
    container_name: db
    restart: unless-stopped
    env_file: .env
    environment:
      - MYSQL_DATABASE=wordpress
    volumes:
      - dbdata:/var/lib/mysql
    command: '--default-authentication-plugin=mysql_native_password'
    networks:
      - app-network

  wordpress:
    depends_on:
      - db
    image: wordpress:<span class="highlight">5.1.1</span>-fpm-alpine
    container_name: wordpress
    restart: unless-stopped
    env_file: .env
    environment:
      - WORDPRESS_DB_HOST=db:3306
      - WORDPRESS_DB_USER=$MYSQL_USER
      - WORDPRESS_DB_PASSWORD=$MYSQL_PASSWORD
      - WORDPRESS_DB_NAME=wordpress
    volumes:
      - wordpress:/var/www/html
    networks:
      - app-network

  webserver:
    depends_on:
      - wordpress
    image: nginx:<span class="highlight">1.15.12</span>-alpine
    container_name: webserver
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - wordpress:/var/www/html
      - ./nginx-conf:/etc/nginx/conf.d
      - certbot-etc:/etc/letsencrypt
    networks:
      - app-network

  certbot:
    depends_on:
      - webserver
    image: certbot/certbot
    container_name: certbot
    volumes:
      - certbot-etc:/etc/letsencrypt
      - wordpress:/var/www/html
    command: certonly --webroot --webroot-path=/var/www/html --email <span class="highlight">sammy@example.com</span> --agree-tos --no-eff-email --force-renewal -d <span class="highlight">example.com</span> -d www.<span class="highlight">example.com</span>

volumes:
  certbot-etc:
  wordpress:
  dbdata:

networks:
  app-network:
    driver: bridge  
</code></pre>
<p>Guarde y cierre el archivo cuando concluya la edición.</p>

<p>Recree el servicio <code>webserver</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose up -d --force-recreate --no-deps webserver
</li></ul></code></pre>
<p>Compruebe sus servicios con <code>docker-compose ps</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose ps
</li></ul></code></pre>
<p>Debería ver un resultado que indique que sus servicios <code>db</code>, <code>wordpress</code> y <code>webserver</code> se encuentran en ejecución:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>  Name                 Command               State                     Ports                  
----------------------------------------------------------------------------------------------
certbot     certbot certonly --webroot ...   Exit 0                                           
db          docker-entrypoint.sh --def ...   Up       3306/tcp, 33060/tcp                     
webserver   nginx -g daemon off;             Up       0.0.0.0:443-&gt;443/tcp, 0.0.0.0:80-&gt;80/tcp
wordpress   docker-entrypoint.sh php-fpm     Up       9000/tcp    
</code></pre>
<p>Una vez que sus contenedores se encuentren en ejecución, podrá completar su instalación de WordPress a través de la interfaz web.</p>

<h2 id="paso-6-completar-la-instalación-a-través-de-la-interfaz-web">Paso 6: Completar la instalación a través de la interfaz web</h2>

<p>Al contar con nuestros contenedores en ejecución, podemos terminar la instalación a través de la interfaz web de WordPress.</p>

<p>En su navegador web, acceda al dominio de su servidor. Recuerde sustituir aquí <code><span class="highlight">example.com</span></code> por su propio nombre de dominio:</p>
<pre class="code-pre "><code langs="">https://<span class="highlight">example.com</span>
</code></pre>
<p>Seleccione el idioma que desee utilizar:</p>

<p><img src="https://assets.digitalocean.com/articles/docker-wordpress/wp_language_select.png" alt="Selector de lenguaje de WordPress"></p>

<p>Después de hacer clic en** Continue**, accederá a la página de configuración principal, en la que deberá elegir un nombre para su sitio y un nombre de usuario. Se recomienda elegir aquí un nombre de usuario fácil de recordar (en lugar de “admin”) y una contraseña segura. Puede usar la contraseña que WordPress genera de manera automática o crear una propia.</p>

<p>Por último, deberá ingresar su dirección de correo electrónico y decidir si quiere evitar que los motores de búsqueda indexen su sitio:</p>

<p><img src="https://assets.digitalocean.com/articles/docker-wordpress/wp_main_setup.png" alt="Página principal de configuración de WordPress"></p>

<p>Al hacer clic sobre <strong>Install WordPress</strong> en la parte inferior de la página, accederá a una solicitud de inicio de sesión:</p>

<p><img src="https://assets.digitalocean.com/articles/docker-wordpress/wp_login.png" alt="Pantalla de inicio de sesión de WordPress"></p>

<p>Una vez que inicie sesión, tendrá acceso al panel de administración de WordPress:</p>

<p><img src="https://assets.digitalocean.com/articles/docker-wordpress/wp_main_dash.png" alt="Panel principal de administración de WordPress"></p>

<p>Una vez completada su instalación de WordPress, podrá tomar medidas para asegurarse de que sus certificados SSL se renueven de forma automática.</p>

<h2 id="paso-7-renovar-certificados">Paso 7: Renovar certificados</h2>

<p>Los certificados de Let&rsquo;s Encrypt son válidos durante 90 días, por lo que le convendrá configurar un proceso de renovación automática para asegurarse de que no caduquen. Una forma de hacerlo es crear una tarea con la utilidad de programación <code>cron</code>. En este caso, crearemos una tarea <code>cron</code> para que de forma periódica ejecute una secuencia de comandos que renovará nuestros certificados y volverá a cargar nuestra configuración de Nginx.</p>

<p>Primero, abra una secuencia de comandos llamada <code>ssl_renew.sh</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano ssl_renew.sh
</li></ul></code></pre>
<p>Agregue el siguiente código a la secuencia de comandos para renovar sus certificados y volver a cargar la configuración de su servidor web. No se olvide de sustituir el nombre de usuario de ejemplo por su nombre de usuario no root:</p>
<div class="code-label " title="~/wordpress/ssl_renew.sh">~/wordpress/ssl_renew.sh</div><pre class="code-pre "><code class="code-highlight language-bash">#!/bin/bash

COMPOSE="/usr/local/bin/docker-compose --no-ansi"

cd /home/<span class="highlight">sammy</span>/wordpress/
$COMPOSE run certbot renew --dry-run &amp;&amp; $COMPOSE kill -s SIGHUP webserver
</code></pre>
<p>Esta secuencia de comandos primero asigna el binario <code>docker-compose</code> a una variable llamada <code>COMPOSE</code> y especifica la opción <code>--no-ansi</code>, que ejecutará comandos <code>docker-compose</code> sin los <a href="https://vt100.net/docs/vt510-rm/chapter4.html">caracteres de control ANSI</a>. Luego cambia el posicionamiento al directorio del proyecto <code>~/wordpress</code> y ejecuta los siguientes comandos <code>docker-compose</code>:</p>

<ul>
<li><code>docker-compose run</code>: iniciará un contenedor <code>certbot</code> y anulará el <code>command</code> proporcionado en nuestra definición de servicio <code>certbot</code>. En lugar de usar el subcomando de <code>certonly</code>, usaremos aquí el subcomando <code>renew</code> que renovará certificados que caducarán pronto. En este caso, incluimos la opción <code>--dry-run</code> para probar nuestra secuencia de comandos.</li>
<li><a href="https://docs.docker.com/compose/reference/kill/"><code>docker-compose kill</code></a>: enviará una <a href="https://en.wikipedia.org/wiki/SIGHUP">señal de <code>SIGHUP</code></a> al contenedor <code>webserver</code> para volver a cargar la configuración de Nginx. Si desea obtener más información sobre el uso de este proceso para volver a cargar su configuración de Nginx, consulte <a href="https://blog.docker.com/2015/04/tips-for-deploying-nginx-official-image-with-docker/">este post del blog de Docker sobre la implementación de la imagen oficial de Nginx con Docker</a>.</li>
</ul>

<p>Cierre el archivo cuando finalice la edición. Haga que sea ejecutable:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">chmod +x ssl_renew.sh
</li></ul></code></pre>
<p>A continuación, abra su archivo <strong>root</strong> <code>crontab</code> para ejecutar la secuencia de comandos de renovación en un intervalo especificado:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo crontab -e
</li></ul></code></pre>
<p>Si es la primera vez que edita este archivo, se le solicitará elegir un editor:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>no crontab for root - using an empty one

Select an editor.  To change later, run 'select-editor'.
  1. /bin/nano        &lt;---- easiest
  2. /usr/bin/vim.basic
  3. /usr/bin/vim.tiny
  4. /bin/ed

Choose 1-4 [1]:
...
</code></pre>
<p>Al final del archivo, añada la siguiente línea:</p>
<div class="code-label " title="crontab">crontab</div><pre class="code-pre "><code langs="">...
*/5 * * * * /home/<span class="highlight">sammy</span>/wordpress/ssl_renew.sh &gt;&gt; /var/log/cron.log 2&gt;&amp;1
</code></pre>
<p>Esto fijará un intervalo de tarea de cinco minutos, de modo que puede probar si su solicitud de renovación funcionó según lo previsto. También creamos un archivo de registro, <code>cron.log</code> para registrar el resultado pertinente de la tarea.</p>

<p>Una vez que transcurran cinco minutos, revise ​​​​​<code>cron.log​​​​​​</code> para comprobar si la solicitud de renovación se realizó con éxito o no:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">tail -f /var/log/cron.log
</li></ul></code></pre>
<p>Debería ver un resultado que confirme el éxito de la renovación:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
** DRY RUN: simulating 'certbot renew' close to cert expiry
**          (The test certificates below have not been saved.)

Congratulations, all renewals succeeded. The following certs have been renewed:
  /etc/letsencrypt/live/<span class="highlight">example.com</span>/fullchain.pem (success)
** DRY RUN: simulating 'certbot renew' close to cert expiry
**          (The test certificates above have not been saved.)
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
</code></pre>
<p>Ahora podrá modificar el archivo de <code>crontab</code> para establecer un intervalo diario. Para ejecutar la secuencia de comandos cada día al mediodía, por ejemplo, se debería modificar la última línea del archivo de modo que tenga el siguiente aspecto:</p>
<div class="code-label " title="crontab">crontab</div><pre class="code-pre "><code langs="">...
0 12 * * * /home/<span class="highlight">sammy</span>/wordpress/ssl_renew.sh &gt;&gt; /var/log/cron.log 2&gt;&amp;1
</code></pre>
<p>También le convendrá eliminar la opción <code>--dry-run</code> de su secuencia de comandos <code>ssl_renew.sh</code>:</p>
<div class="code-label " title="~/wordpress/ssl_renew.sh">~/wordpress/ssl_renew.sh</div><pre class="code-pre "><code class="code-highlight language-bash">#!/bin/bash

COMPOSE="/usr/local/bin/docker-compose --no-ansi"

cd /home/<span class="highlight">sammy</span>/wordpress/
$COMPOSE run certbot renew &amp;&amp; $COMPOSE kill -s SIGHUP webserver
</code></pre>
<p>Su tarea <code>cron</code> controlará que sus certificados de Let´s Encrypt no caduquen al renovarlos cuando reúnan las condiciones. También puede <a href="https://www.digitalocean.com/community/tutorials/how-to-manage-logfiles-with-logrotate-on-ubuntu-16-04">configurar la rotación de registros con la utilidad Logrotate</a> para rotar y comprimir sus archivos de registro.</p>

<h2 id="conclusión">Conclusión</h2>

<p>A través de este tutorial, utilizó Docker Compose para crear una instalación de WordPress con un servidor web de Nginx. Como parte de este flujo de trabajo, obtuvo certificados TLS y SSL para el dominio que quiere asociar con su sitio de WordPress. Además, creó una tarea <code>cron</code> para renovar estos certificados cuando sea necesario.</p>

<p>Como pasos adicionales para mejorar el rendimiento y la redundancia del sitio, puede consultar los siguientes artículos sobre la entrega y el respaldo de activos de WordPress:</p>

<ul>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-speed-up-wordpress-asset-delivery-using-digitalocean-spaces-cdn">Cómo acelerar la entrega de recursos de WordPress usando el CDN de Spaces de DigitalOcean</a>.</li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-back-up-a-wordpress-site-to-spaces">Cómo respaldar un sitio de WordPress en Spaces</a>.</li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-store-wordpress-assets-on-digitalocean-spaces">Cómo almacenar recursos de WordPress en los espacios de DigitalOcean</a>.</li>
</ul>

<p>Si está interesado en explorar un flujo de trabajo en contenedor con Kubernetes, también puede consultar lo siguiente:</p>

<ul>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-wordpress-with-mysql-on-kubernetes-using-helm">Cómo configurar WordPress con MySQL en Kubernetes usando Helm</a>.</li>
</ul>
