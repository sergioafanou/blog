---
layout: post
title: Como Gerenciar Réplicas e Clientes no Redis
network: digitalocean
date: January 22, 2020 at 08:03PM
url: https://www.digitalocean.com/community/tutorials/how-to-manage-replicas-and-clients-in-redis-pt
image: http://ifttt.com/images/no_image_card.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="introdução">Introdução</h3>

<p>O <a href="https://redis.io/">Redis</a> é um armazenamento de dados open-source de chave-valor na memória. Um dos seus recursos mais procurados é o suporte à replicação: qualquer servidor Redis pode replicar seus dados para qualquer número de réplicas, permitindo alta escalabilidade de leitura e forte redundância de dados. Além disso, o Redis foi projetado para permitir que muitos clientes (até 10000, por padrão) se conectem e interajam com os dados, tornando-o uma boa opção para casos em que muitos usuários precisam acessar o mesmo <em>dataset</em> ou conjunto de dados.</p>

<p>Este tutorial aborda os comandos usados para gerenciar clientes e réplicas Redis.</p>

<h4 id="como-usar-este-guia">Como Usar Este Guia</h4>

<p>Este guia foi escrito como uma consulta rápida com exemplos independentes. Recomendamos que você pule para qualquer seção que seja relevante para a tarefa que você está tentando concluir.</p>

<p>Os comandos mostrados neste guia foram testados em um servidor Ubuntu 18.04 executando a versão do Redis <span class="highlight">4.0.9</span>. Para configurar um ambiente semelhante, você pode seguir o <strong>Passo 1</strong> do nosso guia <a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-redis-on-ubuntu-18-04-pt">Como Instalar e Proteger o Redis no Ubuntu 18.04</a>. Vamos demonstrar como esses comandos se comportam executando-os com <code>redis-cli</code>, a interface de linha de comando do Redis. Observe que se você estiver usando uma interface Redis diferente — <a href="https://github.com/IBM-Cloud/redli">Redli</a>, por exemplo — a saída exata de certos comandos pode ser diferente.</p>

<p>Alternativamente, você pode provisionar uma instância de banco de dados Redis gerenciada para testar esses comandos, mas observe que, dependendo do nível de controle permitido pelo seu provedor de banco de dados, alguns comandos neste guia podem não funcionar como descrito. Para provisionar um banco de dados gerenciado na DigitalOcean, siga nossa <a href="https://www.digitalocean.com/docs/databases/redis/quickstart/">documentação do produto Managed Databases</a>. Em seguida, você deve <a href="https://www.digitalocean.com/community/tutorials/how-to-connect-to-managed-database-ubuntu-18-04#connecting-to-a-managed-redis-database"><strong>instalar o Redli</strong></a> <strong>ou</strong> <a href="https://www.digitalocean.com/community/tutorials/how-to-connect-to-managed-redis-over-tls-with-stunnel-and-redis-%20cli"><strong>configurar um túnel TLS</strong></a> para conectar-se ao banco de dados gerenciado via TLS.</p>

<span class='note'><p>
<strong>Nota:</strong> O projeto Redis usa os termos &ldquo;master&rdquo; e &ldquo;slave&rdquo; em sua documentação e em vários comandos para identificar diferentes funções na replicação, embora os colaboradores do projeto <a href="https://github.com/antirez/redis/issues/5335">estejam tomando medidas para alterar essa linguagem</a> nos casos onde isso não cause problemas de compatibilidade. A DigitalOcean geralmente prefere usar os termos alternativos &ldquo;primary&rdquo; e &ldquo;replica&rdquo;.</p>

<p>Este guia assumirá o padrão &ldquo;primary&rdquo; e &ldquo;replica&rdquo; sempre que possível, mas observe que existem algumas circunstâncias em que os termos &ldquo;master&rdquo; e &ldquo;slave&rdquo; inevitavelmente aparecem.<br></p></span>

<h2 id="gerenciando-réplicas">Gerenciando Réplicas</h2>

<p>Um dos recursos que mais se destaca no Redis é sua <a href="https://redis.io/topics/replication">replicação embutida</a>. Ao usar a replicação, o Redis cria cópias exatas da instância primária. Essas instâncias secundárias se reconectam à primária sempre que suas conexões quebram e sempre procurarão permanecer como uma cópia exata da primária.</p>

<p>Se você não tiver certeza se a instância do Redis à qual você está conectado atualmente é uma instância primária ou uma réplica, verifique com o comando <code>role</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="127.0.0.1:6379&gt;">role
</li></ul></code></pre>
<p>Este comando retornará <code>master</code> ou <code>slave</code> ou, potencialmente, <code>sentinel</code> se você estiver usando <a href="https://redis.io/topics/sentinel">Redis Sentinel</a>.</p>

<p>Para designar uma instância do Redis como uma réplica de outra instância em tempo real, execute o comando <code>replicaof</code>. Este comando usa o nome do host ou o endereço IP do servidor primário pretendido e a porta como argumentos:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="127.0.0.1:6379&gt;">replicaof <span class="highlight">hostname_ou_IP</span> <span class="highlight">porta</span>
</li></ul></code></pre>
<p>Se o servidor já era uma réplica de outro primário, ele interromperá a replicação do servidor antigo e começará a sincronizar imediatamente com o novo. Ele também descartará o dataset antigo.</p>

<p>Para promover uma réplica de volta para ser primária, execute o seguinte comando <code>replicaof</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="127.0.0.1:6379&gt;">replicaof no one
</li></ul></code></pre>
<p>Isso impedirá a instância de replicar o servidor primário, mas não descartará o dataset que já foi replicado. Essa sintaxe é útil nos casos em que o primário original falha. Depois de executar <code>replicaof no one</code> em uma réplica do primário com falha, a réplica anterior pode ser usada como o novo primário e ter suas próprias réplicas como um mecanismo de proteção a falhas.</p>

<p><span class='note'><strong>Nota:</strong> Antes da versão 5.0.0, o Redis incluía uma versão deste comando chamada <code>slaveof</code>.<br></span></p>

<h2 id="gerenciando-clientes">Gerenciando Clientes</h2>

<p>Um <a href="https://pt.wikipedia.org/wiki/Cliente_(computa%C3%A7%C3%A3o)"><em>cliente</em></a> é qualquer máquina ou software que se conecta a um servidor para acessar um serviço. O Redis vem com vários comandos que ajudam a rastrear e gerenciar conexões de clientes.</p>

<p>O comando <code>client list</code> retorna um conjunto de informações legíveis sobre as conexões atuais de cliente:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="127.0.0.1:6379&gt;">client list
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>"id=18165 addr=[2001:db8:0:0::12]:47460 fd=7 name=jerry age=72756 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=ping
id=18166 addr=[2001:db8:0:1::12]:47466 fd=8 name= age=72755 idle=5 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=info
id=19381 addr=[2001:db8:0:2::12]:54910 fd=9 name= age=9 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client
"
</code></pre>
<p>Aqui está o que cada um desses campos significa:</p>

<ul>
<li><code>id</code>: um ID de cliente exclusivo de 64 bits</li>
<li><code>name</code>: o nome da conexão do cliente, conforme definido por um comando anterior <code>client setname</code></li>
<li><code>addr</code>: o endereço e a porta a partir da qual o cliente está se conectando</li>
<li><code>fd</code>: o <a href="https://pt.wikipedia.org/wiki/Descritor_de_arquivo">descritor de arquivo</a> que corresponde ao soquete no qual o cliente está se conectando</li>
<li><code>age</code>: a duração total da conexão do cliente, em segundos</li>
<li><code>flags</code>: um conjunto de uma ou mais flags de caractere simples que fornecem detalhes mais granulares sobre os clientes; veja a <a href="https://redis.io/commands/client-list">documentação do comando <code>client list</code></a> para mais detalhes</li>
<li><code>db</code>: o número atual do ID do banco de dados ao qual o cliente está conectado (pode ser de <code>0</code> a <code>15</code>)</li>
<li><code>sub</code>:o número de canais aos quais o cliente está inscrito</li>
<li><code>psub</code>: o número de subscrições correspondentes ao padrão do cliente</li>
<li><code>mutli</code>: o número de comandos que o cliente enfileirou em uma <a href="https://www.digitalocean.com/community/cheatsheets/how-to-run-transactions-in-redis">transação</a> (mostrará <code>-1</code> se o cliente não iniciou uma transação ou <code>0</code> se apenas iniciou uma transação e não colocou nenhum comando na fila)</li>
<li><code>qbuf</code>:o tamanho do buffer de consulta do cliente, com &ldquo;0&rdquo; significando que não há consultas pendentes</li>
<li><code>qbuf-free</code>: a quantidade de espaço livre no buffer de consulta do cliente, com &ldquo;0&rdquo; significando que o buffer de consulta está cheio</li>
<li><code>obl</code>: o comprimento do buffer de saída do cliente</li>
<li><code>oll</code>: o comprimento da lista de saída do cliente, onde as respostas são colocadas na fila quando o buffer está cheio</li>
<li><code>omem</code>: a memória usada pelo buffer de saída do cliente</li>
<li><code>events</code>: eventos do descritor de arquivo do cliente, eles podem ser <code>r</code> para &ldquo;legível&rdquo;, <code>w</code> para &ldquo;gravável&rdquo; ou ambos</li>
<li><code>cmd</code>: o último comando executado pelo cliente</li>
</ul>

<p>Definir nomes de clientes é útil para <em>debugar</em> vazamentos de conexão em qualquer aplicativo que esteja usando o Redis. Toda nova conexão é iniciada sem um nome atribuído, mas <code>client setname</code> pode ser usado para criar um para a conexão atual do cliente. Não há limite para o tamanho dos nomes dos clientes, embora o Redis normalmente limite os comprimentos de string de caracteres para 512 MB. Observe, porém, que os nomes dos clientes não podem incluir espaços:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="127.0.0.1:6379&gt;">client setname elaine
</li></ul></code></pre>
<p>Para obter o nome de uma conexão de cliente, use o comando <code>client getname</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="127.0.0.1:6379&gt;">client getname
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>"elaine"
</code></pre>
<p>Para buscar o ID de conexão de um cliente, use o comando <code>client id</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="127.0.0.1:6379&gt;">client id
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>(integer) "19492"
</code></pre>
<p>Os IDs de clientes Redis nunca são repetidos e são monotonicamente incrementais. Isso significa que, se um cliente tiver um ID maior que outro, então ele foi estabelecido posteriormente.</p>

<h2 id="bloqueando-clientes-e-fechando-conexões-de-cliente">Bloqueando Clientes e Fechando Conexões de Cliente</h2>

<p>Os sistemas de replicação são normalmente descritos como sendo <em>síncronos</em> ou <em>assíncronos</em>. Na replicação síncrona, sempre que um cliente adiciona ou altera dados, ele deve receber algum tipo de reconhecimento de um certo número de réplicas para que a alteração seja registrada como confirmada. Isso ajuda a impedir que os nodes tenham conflitos de dados, mas tem um custo de latência, já que o cliente deve esperar para executar outra operação até receber uma resposta de um certo número de réplicas.</p>

<p>Na replicação assíncrona, por outro lado, o cliente vê uma confirmação de que a operação é concluída assim que os dados são gravados no armazenamento local. No entanto, pode haver um atraso entre isso e quando as réplicas realmente gravam os dados. Se uma das réplicas falhar antes de poder gravar a alteração, essa gravação será perdida para sempre. Portanto, embora a replicação assíncrona permita que os clientes continuem executando operações sem a latência causada pela espera das réplicas, isso pode levar a conflitos de dados entre nodes e pode exigir trabalho extra por parte do administrador do banco de dados para resolver esses conflitos.</p>

<p>Devido ao seu foco no desempenho e na baixa latência, o Redis implementa a replicação assíncrona por padrão. No entanto, você pode simular a replicação síncrona com o comando <code>wait</code>. O <code>wait</code> bloqueia a conexão do cliente atual por um período de tempo especificado (em milissegundos) até que todos os comandos de gravação anteriores sejam transferidos e aceitos com sucesso por um número especificado de réplicas. Este comando usa a seguinte sintaxe:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="127.0.0.1:6379&gt;">wait <span class="highlight">número_de_réplicas</span> <span class="highlight">número_de_milisegundos</span>
</li></ul></code></pre>
<p>Por exemplo, se você deseja bloquear a sua conexão de cliente até que todas as gravações anteriores sejam registradas por pelo menos três réplicas dentro de um tempo limite de 30 milissegundos, sua sintaxe <code>wait</code> se parecerá com esta:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="127.0.0.1:6379&gt;">wait 3 30
</li></ul></code></pre>
<p>O comando <code>wait</code> retorna um número inteiro que representa o número de réplicas que reconheceram os comandos de gravação, mesmo que nem todas as réplicas o façam:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>2
</code></pre>
<p>Para desbloquear uma conexão de cliente que foi bloqueada anteriormente, seja de um comando <code>wait</code>, <code>brpop</code> ou <code>xread</code>, você pode executar um comando <code>client unblock</code> com a seguinte sintaxe:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="127.0.0.1:6379&gt;">client unblock <span class="highlight">client_id</span>
</li></ul></code></pre>
<p>Para suspender temporariamente todos os clientes atualmente conectados ao servidor Redis, você pode usar o comando <code>client pause</code>. Isso é útil nos casos em que você precisa fazer alterações na configuração do Redis de maneira controlada. Por exemplo, se você estiver promovendo uma de suas réplicas como a instância primária, poderá pausar todos os clientes com antecedência para promover a réplica e fazer com que os clientes se conectem a ela como o novo primário sem perder nenhuma operação de gravação no processo.</p>

<p>O comando <code>client pause</code> exige que você especifique a quantidade de tempo (em milissegundos) que deseja suspender os clientes. O exemplo a seguir suspenderá todos os clientes por um segundo:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="127.0.0.1:6379&gt;">client pause 1000
</li></ul></code></pre>
<p>A sintaxe do <code>client kill</code> permite que você feche uma única conexão ou um conjunto de conexões específicas com base em vários filtros diferentes. A sintaxe é assim:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="127.0.0.1:6379&gt;">client kill <span class="highlight">filtro_1</span> <span class="highlight">valor_1</span> ... <span class="highlight">filtro_n</span> <span class="highlight">valor_n</span>
</li></ul></code></pre>
<p>Nas versões do Redis 2.8.12 e posteriores, os seguintes filtros estão disponíveis:</p>

<ul>
<li><code>addr</code>: permite fechar uma conexão de cliente a partir de um endereço IP e porta especificados</li>
<li><code>client-id</code>: permite fechar uma conexão de cliente com base em seu campo de ID exclusivo</li>
<li><code>type</code>: fecha todo cliente de um determinado tipo, que pode ser <code>normal</code>, <code>master</code>, <code>slave</code> ou <code>pubsub</code></li>
<li><code>skipme</code>: as opções de valor para este filtro são <code>yes</code> e <code>no</code>:

<ul>
<li>se <code>no</code> for especificado, o cliente que chama o comando <code>client kill</code> não será ignorado e será eliminado se os outros filtros se aplicarem a ele</li>
<li>se <code>yes</code> for especificado, o cliente executando o comando será ignorado e o comando kill não terá efeito no cliente. <code>skipme</code> é sempre<code>yes</code> por padrão</li>
</ul></li>
</ul>

<h2 id="conclusão">Conclusão</h2>

<p>Este guia detalha vários comandos usados para gerenciar clientes e réplicas Redis. Se houver outros comandos, argumentos ou procedimentos relacionados que você gostaria de ver descritos neste guia, peça ou faça sugestões nos comentários abaixo.</p>

<p>Para obter mais informações sobre comandos Redis, consulte nossa série de tutoriais sobre <a href="https://www.digitalocean.com/community/tutorial_series/how-to-manage-a-redis-database">Como gerenciar um banco de dados Redis</a>.</p>
