---
layout: post
title: Обслуживание приложений Flask с uWSGI и Nginx в Ubuntu 18.04
network: digitalocean
date: January 07, 2020 at 07:55PM
url: https://www.digitalocean.com/community/tutorials/how-to-serve-flask-applications-with-uswgi-and-nginx-on-ubuntu-18-04-ru
image: https://assets.digitalocean.com/articles/nginx_uwsgi_wsgi_1404/test_app.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="Введение">Введение</h3>

<p>В этом обучающем модуле вы создадите приложение Python с использованием микроструктуры Flask в Ubuntu 18.04. Основная часть этой статьи посвящена настройке <a href="http://uwsgi-docs.readthedocs.io/en/latest/">сервера приложений uWSGI</a>, запуску приложения и настройке <a href="https://www.nginx.com/">Nginx</a> для работы в режиме обратного прокси-сервера фронтенда.</p>

<h2 id="Предварительные-требования">Предварительные требования</h2>

<p>Перед началом прохождения этого обучающего модуля вам потребуется следующее:</p>

<ul>
<li>Сервер с установленной операционной системой Ubuntu 18.04 и пользователь без привилегий root и с привилегиями sudo. Следуйте указаниям нашего <a href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04">руководства по начальной настройке сервера</a>.</li>
<li>Веб-сервер Nginx, установленный в соответствии с шагами 1 и 2 модуля <a href="https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-ubuntu-18-04">Установка Nginx в Ubuntu 18.04</a>.</li>
<li><p>Доменное имя, настроенное так, чтобы указывать на ваш сервер. Вы можете приобрести его на <a href="https://namecheap.com">Namecheap</a> или получить бесплатно на <a href="http://www.freenom.com/en/index.html">Freenom</a>. Вы можете узнать, как указывать домены на DigitalOcean, из соответствующей <a href="https://www.digitalocean.com/docs/networking/dns/">документации по доменам и DNS</a>. Обязательно создайте следующие записи DNS:</p>

<ul>
<li>Запись A, где <code><span class="highlight">your_domain</span></code> указывает на публичный IP-адрес вашего сервера.</li>
<li>Запись A, где <code>www.<span class="highlight">your_domain</span></code> указывает на публичный IP-адрес вашего сервера.</li>
</ul></li>
<li><p>Знакомство с нашим сервером приложений uWSGI и спецификацией WSGI. <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-uwsgi-and-nginx-to-serve-python-apps-on-ubuntu-14-04#definitions-and-concepts">В этом обсуждении</a> определений и концепций о них рассказывается более подробно.</p></li>
</ul>

<h2 id="Шаг-1-—-Установка-компонентов-из-хранилищ-ubuntu">Шаг 1 — Установка компонентов из хранилищ Ubuntu</h2>

<p>Первым шагом будет установка всех необходимых нам элементов из хранилищ Ubuntu. Для управления нашими компонентами Python мы установим <code>pip</code>, диспетчер пакетов Python. Также мы получим файлы разработки Python, необходимые для создания uWSGI.</p>

<p>Вначале обновим локальный индекс пакетов и установим пакеты, которые позволят нам создать нашу среду Python. Мы установим пакет <code>python3-pip</code>, а также еще несколько пакетов и средств разработки, необходимых для создания надежной среды программирования:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt update
</li><li class="line" prefix="$">sudo apt install python3-pip python3-dev build-essential libssl-dev libffi-dev python3-setuptools
</li></ul></code></pre>
<p>С этими пакетами мы перейдем к созданию виртуальной среды для нашего проекта.</p>

<h2 id="Шаг-2-—-Создание-виртуальной-среды-python">Шаг 2 — Создание виртуальной среды Python</h2>

<p>Теперь мы настроим виртуальную среду, чтобы изолировать наше приложение Flask от других файлов Python в системе.</p>

<p>Для начала установим пакет <code>python3-venv</code>, который установит модуль <code>venv</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt install python3-venv
</li></ul></code></pre>
<p>Затем создадим родительский каталог для нашего проекта Flask. Перейдите в каталог после его создания:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir ~/<span class="highlight">myproject</span>
</li><li class="line" prefix="$">cd ~/<span class="highlight">myproject</span>
</li></ul></code></pre>
<p>Создайте виртуальную среду для хранения требований Python для вашего проекта Flask, введя следующую команду:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">python3.6 -m venv <span class="highlight">myprojectenv</span>
</li></ul></code></pre>
<p>Локальные копии Python и <code>pip</code> будут установлены в каталог <code><span class="highlight">myprojectenv</span></code> в каталоге вашего проекта.</p>

<p>Прежде чем устанавливать приложения в виртуальной среде, ее нужно активировать. Для этого нужно ввести следующую команду:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">source <span class="highlight">myprojectenv</span>/bin/activate
</li></ul></code></pre>
<p>Командная строка изменится, показывая, что теперь вы работаете в виртуальной среде. Она будет выглядеть примерно так: <code>(<span class="highlight">myprojectenv</span>)<span class="highlight">user</span>@<span class="highlight">host</span>:~/<span class="highlight">myproject</span>$</code>.</p>

<h2 id="Шаг-3-—-Настройка-приложения-flask">Шаг 3 — Настройка приложения Flask</h2>

<p>Находясь в виртуальной среде, вы можете установить Flask и uWSGI и начать работу над созданием вашего приложения.</p>

<p>Вначале мы установим <code>wheel</code> с локальным экземпляром <code>pip</code>, чтобы убедиться, что наши пакеты будут устанавливаться даже при отсутствии архивов wheel:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">pip install wheel
</li></ul></code></pre>
<p><span class='note'><strong>Примечание.</strong> Если виртуальная среда активна, то вне зависимости от того, какую версию Python вы используете, вы должны использовать команду <code>pip</code> (а не <code>pip3</code>).<br></span></p>

<p>Затем установим Flask и uWSGI:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(myprojectenv) $">pip install uwsgi flask
</li></ul></code></pre>
<h3 id="Создание-образца-приложения">Создание образца приложения</h3>

<p>Теперь вы можете использовать Flask для создания простого приложения. Flask представляет собой микроструктуру. В ней отсутствуют многие инструменты, входящие в полноценные инфраструктуры программирования, и она существует в основном в виде модуля, который вы можете импортировать в проекты для инициализации веб-приложения.</p>

<p>Хотя ваше приложение может быть более сложным, мы создадим наше приложение Flask в одном файле с именем <code>myproject.py</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(myprojectenv) $">nano ~/<span class="highlight">myproject</span>/<span class="highlight">myproject</span>.py
</li></ul></code></pre>
<p>Код приложения будет находиться в этом файле. Он импортирует Flask и создаст экземпляр объекта Flask. Вы можете использовать его для определения функций, которые запускаться при запросе конкретного маршрута:</p>
<div class="code-label " title="~/myproject/myproject.py">~/myproject/myproject.py</div><pre class="code-pre "><code class="code-highlight language-python">from flask import Flask
app = Flask(__name__)

@app.route("/")
def hello():
    return "&lt;h1 style='color:blue'&gt;Hello There!&lt;/h1&gt;"

if __name__ == "__main__":
    app.run(host='0.0.0.0')
</code></pre>
<p>Здесь определяется, какой контент должен выводиться при доступе к корневому домену. Сохраните файл и закройте его после завершения.</p>

<p>Если вы следовали указаниям модуля по начальной настройке сервера, у вас должен быть включен брандмауэр UFW. Чтобы протестировать приложение, вам нужно разрешить доступ к порту <code>5000</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(myprojectenv) $">sudo ufw allow 5000
</li></ul></code></pre>
<p>Теперь вы можете протестировать приложение Flask с помощью следующей команды:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(myprojectenv) $">python <span class="highlight">myproject</span>.py
</li></ul></code></pre>
<p>Вы увидите следующий результат, в том числе полезное предупреждение, напоминающее не использовать эти настройки сервера в реальной работе:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>* Serving Flask app "myproject" (lazy loading)
 * Environment: production
   WARNING: Do not use the development server in a production environment.
   Use a production WSGI server instead.
 * Debug mode: off
 * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)
</code></pre>
<p>Откройте в браузере IP-адрес вашего сервера с суффиксом <code>:5000</code>:</p>
<pre class="code-pre "><code langs="">http://<span class="highlight">your_server_ip</span>:5000
</code></pre>
<p>Вы увидите примерно следующее:</p>

<p><img src="https://assets.digitalocean.com/articles/nginx_uwsgi_wsgi_1404/test_app.png" alt="Образец приложения Flask"></p>

<p>Когда вы закончите, нажмите <code>CTRL+C</code> в окне терминала, чтобы остановить сервер разработки Flask.</p>

<h3 id="Создание-точки-входа-wsgi">Создание точки входа WSGI</h3>

<p>Теперь создадим файл, который будет служить точкой входа в наше приложение. Это покажет серверу uWSGI, как с ним взаимодействовать.</p>

<p>Мы назовем этот файл <code>wsgi.py</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(myprojectenv) $">nano ~/<span class="highlight">myproject</span>/wsgi.py
</li></ul></code></pre>
<p>Сейчас мы импортируем экземпляр Flask из нашего приложения в этот файл и запустим его:</p>
<div class="code-label " title="~/myproject/wsgi.py">~/myproject/wsgi.py</div><pre class="code-pre "><code class="code-highlight language-python">from myproject import app

if __name__ == "__main__":
    app.run()
</code></pre>
<p>Сохраните файл и закройте его после завершения.</p>

<h2 id="Шаг-4-—-Настройка-uwsgi">Шаг 4 — Настройка uWSGI</h2>

<p>Ваше приложение написано, и для него создана точка входа. Теперь мы можем перейти к настройке uWSGI.</p>

<h3 id="Тестирование-обслуживания-uwsgi">Тестирование обслуживания uWSGI</h3>

<p>Проверим способность uWSGI обслуживать наше приложение.</p>

<p>Для этого нужно просто передать имя нашей точки входа. Оно составляется из имени модуля (без расширения <code>.py</code>) и имени вызываемого элемента приложения. В нашем случае это <code>wsgi:app</code>.</p>

<p>Также укажем сокет, чтобы запуск осуществлялся через общедоступный интерфейс, а также протокол, чтобы использовать протокол HTTP вместо двоичного протокола <code>uwsgi</code>. Мы будем использовать номер порта <code>5000</code>, который открывали ранее:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(myprojectenv) $">uwsgi --socket 0.0.0.0:5000 --protocol=http -w wsgi:app
</li></ul></code></pre>
<p>Откройте в браузере IP-адрес вашего сервера с суффиксом <code>:5000</code>.</p>
<pre class="code-pre "><code langs="">http://<span class="highlight">your_server_ip</span>:5000
</code></pre>
<p>Теперь вы снова увидите результат выполнения вашего приложения:</p>

<p><img src="https://assets.digitalocean.com/articles/nginx_uwsgi_wsgi_1404/test_app.png" alt="Образец приложения Flask"></p>

<p>Убедившись в его нормальной работе, нажмите <code>CTRL+C</code> в окне терминала.</p>

<p>Мы закончили работу с виртуальной средой, и теперь можем отключить ее:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(myprojectenv) $">deactivate
</li></ul></code></pre>
<p>Теперь любые команды Python снова будут использовать системную среду Python.</p>

<h3 id="Создание-файла-конфигурации-uwsgi">Создание файла конфигурации uWSGI</h3>

<p>Вы убедились, что uWSGI может обслуживать ваше приложение, но вам нужно что-то более надежное для долгосрочного использования. Для этой цели вы можете создать файл конфигурации uWSGI с соответствующими параметрами.</p>

<p>Поместим этот файл в каталоге нашего проекта и назовем его <code>myproject.ini</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano ~/<span class="highlight">myproject</span>/<span class="highlight">myproject</span>.ini
</li></ul></code></pre>
<p>В начало файла мы добавим заголовок <code>[uwsgi]</code>, чтобы указать uWSGI на необходимость применения настроек. Мы укажем сам модуль посредством ссылки на файл <code>wsgi.py</code> без расширения, и вызываемый элемент файла, <code>app</code>:</p>
<div class="code-label " title="~/myproject/myproject.ini">~/myproject/myproject.ini</div><pre class="code-pre "><code langs="">[uwsgi]
module = wsgi:app
</code></pre>
<p>Затем мы укажем uWSGI начать работу в режиме мастера и создать пять рабочих процессов для обслуживания фактических запросов:</p>
<div class="code-label " title="~/myproject/myproject.ini">~/myproject/myproject.ini</div><pre class="code-pre "><code langs="">[uwsgi]
module = wsgi:app

master = true
processes = 5
</code></pre>
<p>По время тестирования вы разместили uWSGI на сетевом порту. Однако для обработки фактических клиентских подключений вы будете использовать веб-сервер Nginx, который будет передавать запросы uWSGI. Поскольку эти компоненты работают на одном компьютере, предпочтительно будет использовать сокет Unix, так как он быстрее и безопаснее. Назовем этот сокет <code><span class="highlight">myproject</span>.sock</code> и разместим его в этом каталоге.</p>

<p>Также изменим разрешения сокета. Позднее мы сделаем группу Nginx владельцем процесса uWSGI, и поэтому нужно сделать так, чтобы владелец группы сокета мог считывать из нее информацию и записывать в нее информацию. Также мы выполним очистку сокета после остановки процесса, для чего используем опцию <code>vacuum</code>:</p>
<div class="code-label " title="~/myproject/myproject.ini">~/myproject/myproject.ini</div><pre class="code-pre "><code langs="">[uwsgi]
module = wsgi:app

master = true
processes = 5

socket = <span class="highlight">myproject</span>.sock
chmod-socket = 660
vacuum = true
</code></pre>
<p>В заключение мы установим опцию <code>die-on-term</code>. Благодаря этому система инициализации и uWSGI будут одинаково интерпретировать каждый сигнал процесса. Эта настройка обеспечивает соответствие двух системных компонентов и позволяет добиться ожидаемого поведения:</p>
<div class="code-label " title="~/myproject/myproject.ini">~/myproject/myproject.ini</div><pre class="code-pre "><code langs="">[uwsgi]
module = wsgi:app

master = true
processes = 5

socket = <span class="highlight">myproject</span>.sock
chmod-socket = 660
vacuum = true

die-on-term = true
</code></pre>
<p>Возможно вы заметили, что мы не указали протокол, как делали это из командной строки. Это связано с тем, что по умолчанию uWSGI использует для связи протокол <code>uwsgi</code>. Это быстрый двоичный протокол, созданный для коммуникации с другими серверами. В Nginx имеется изначальная поддержка этого протокола, и поэтому лучше использовать его, чем принудительно требовать использования протокола HTTP.</p>

<p>После завершения редактирования сохраните и закройте файл.</p>

<h2 id="Шаг-5-—-Создание-файла-элементов-systemd">Шаг 5 — Создание файла элементов systemd</h2>

<p>Далее мы созадим файл служебных элементов systemd. Создание файла элементов systemd позволит системе инициализации Ubuntu автоматически запускать uWSGI и обслуживать приложение Flask при загрузке сервера.</p>

<p>Для начала создайте файл элементов с расширением <code>.service</code> в каталоге <code>/etc/systemd/system</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nano /etc/systemd/system/<span class="highlight">myproject</span>.service
</li></ul></code></pre>
<p>Мы начнем с раздела <code>[Unit]</code> этого файла, где указываются метаданные и зависимости. Здесь мы разместим описание службы и предпишем системе инициализации запускать ее только после достижения сетевой цели:</p>
<div class="code-label " title="/etc/systemd/system/myproject.service">/etc/systemd/system/myproject.service</div><pre class="code-pre "><code langs="">[Unit]
Description=uWSGI instance to serve <span class="highlight">myproject</span>
After=network.target
</code></pre>
<p>Теперь откроем раздел <code>[Service]</code>. Здесь указывается пользователь и группа, от имени которых мы хотим запустить данный процесс. Сделаем владельем процесса учетную запись обычного пользователя, поскольку этот пользователь является владельцем всех соответствующих файлов. Также назначим владельцем группу <code>www-data</code>, чтобы упростить коммуникацию Nginx с процессами uWSGI. Не забудьте заменить приведенное имя пользователя своим именем пользователя:</p>
<div class="code-label " title="/etc/systemd/system/myproject.service">/etc/systemd/system/myproject.service</div><pre class="code-pre "><code langs="">[Unit]
Description=uWSGI instance to serve <span class="highlight">myproject</span>
After=network.target

[Service]
User=<span class="highlight">sammy</span>
Group=www-data
</code></pre>
<p>Теперь составим карту рабочего каталога и зададим переменную среды <code>PATH</code>, чтобы система инициализации знала, что исполняемые файлы этого процесса находятся в нашей виртуальной среде. Также укажем команду для запуска службы. Systemd требует, чтобы мы указывали полный путь исполняемого файла uWSGI, установленного в нашей виртуальной среде. Мы передадим имя файла конфигурации <code>.ini</code>, который создали в каталоге нашего проекта.</p>

<p>Не забудьте заменить имя пользователя и пути проекта собственными данными:</p>
<div class="code-label " title="/etc/systemd/system/myproject.service">/etc/systemd/system/myproject.service</div><pre class="code-pre "><code langs="">[Unit]
Description=uWSGI instance to serve <span class="highlight">myproject</span>
After=network.target

[Service]
User=<span class="highlight">sammy</span>
Group=www-data
WorkingDirectory=/home/<span class="highlight">sammy</span>/<span class="highlight">myproject</span>
Environment="PATH=/home/<span class="highlight">sammy</span>/<span class="highlight">myproject</span>/<span class="highlight">myprojectenv</span>/bin"
ExecStart=/home/<span class="highlight">sammy</span>/<span class="highlight">myproject</span>/<span class="highlight">myprojectenv</span>/bin/uwsgi --ini <span class="highlight">myproject</span>.ini
</code></pre>
<p>Наконец, добавим раздел <code>[Install]</code>. Это покажет systemd, куда привязывать эту службу, если мы активируем ее запуск при загрузке. Нам нужно, чтобы эта служба запускалась во время работы обычной многопользовательской системы:</p>
<div class="code-label " title="/etc/systemd/system/myproject.service">/etc/systemd/system/myproject.service</div><pre class="code-pre "><code langs="">[Unit]
Description=uWSGI instance to serve <span class="highlight">myproject</span>
After=network.target

[Service]
User=<span class="highlight">sammy</span>
Group=www-data
WorkingDirectory=/home/<span class="highlight">sammy</span>/<span class="highlight">myproject</span>
Environment="PATH=/home/<span class="highlight">sammy</span>/<span class="highlight">myproject</span>/<span class="highlight">myprojectenv</span>/bin"
ExecStart=/home/<span class="highlight">sammy</span>/<span class="highlight">myproject</span>/<span class="highlight">myprojectenv</span>/bin/uwsgi --ini <span class="highlight">myproject</span>.ini

[Install]
WantedBy=multi-user.target
</code></pre>
<p>Теперь служебный файл systemd готов. Сохраните и закройте его.</p>

<p>Теперь мы запустим созданную службу uWSGI и активируем ее запуск при загрузке системы:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl start <span class="highlight">myproject</span>
</li><li class="line" prefix="$">sudo systemctl enable <span class="highlight">myproject</span>
</li></ul></code></pre>
<p>Теперь проверим состояние:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl status <span class="highlight">myproject</span>
</li></ul></code></pre>
<p>Результат должен выглядеть следующим образом:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>● myproject.service - uWSGI instance to serve myproject
   Loaded: loaded (/etc/systemd/system/myproject.service; enabled; vendor preset: enabled)
   Active: <span class="highlight">active (running)</span> since Fri 2018-07-13 14:28:39 UTC; 46s ago
 Main PID: 30360 (uwsgi)
    Tasks: 6 (limit: 1153)
   CGroup: /system.slice/myproject.service
           ├─30360 /home/sammy/myproject/myprojectenv/bin/uwsgi --ini myproject.ini
           ├─30378 /home/sammy/myproject/myprojectenv/bin/uwsgi --ini myproject.ini
           ├─30379 /home/sammy/myproject/myprojectenv/bin/uwsgi --ini myproject.ini
           ├─30380 /home/sammy/myproject/myprojectenv/bin/uwsgi --ini myproject.ini
           ├─30381 /home/sammy/myproject/myprojectenv/bin/uwsgi --ini myproject.ini
           └─30382 /home/sammy/myproject/myprojectenv/bin/uwsgi --ini myproject.ini
</code></pre>
<p>Если вы увидите какие-либо ошибки, устраните их, прежде чем продолжить выполнение этого обучающего модуля.</p>

<h2 id="Шаг-6-—-Настройка-nginx-для-работы-с-запросами-прокси-сервера">Шаг 6 — Настройка Nginx для работы с запросами прокси-сервера</h2>

<p>Сервер приложений uWSGI должен быть запущен и ожидать запросы файла сокета в каталоге проекта. Настроим Nginx для передачи веб-запросов на этот сокет с помощью протокола <code>uwsgi</code>.</p>

<p>Вначале мы создадим новый файл конфигурации серверных блоков в каталоге Nginx <code>sites-available</code>. Назовем его <code><span class="highlight">myproject</span></code> для соответствия остальным именам в этом модуле:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nano /etc/nginx/sites-available/<span class="highlight">myproject</span>
</li></ul></code></pre>
<p>Откройте серверный блок и укажите Nginx прослушивать порт по умолчанию <code>80</code>. Также укажите использовать этот блок для запросов доменного имени нашего сервера:</p>
<div class="code-label " title="/etc/nginx/sites-available/myproject">/etc/nginx/sites-available/myproject</div><pre class="code-pre "><code langs="">server {
    listen 80;
    server_name <span class="highlight">your_domain</span> www.<span class="highlight">your_domain</span>;
}
</code></pre>
<p>Затем добавим блок расположения, соответствующий каждому запросу. В этот блок мы добавим файл <code>uwsgi_params</code>, определяющий некоторые общие параметры uWSGI, которые необходимо настроить. После этого запросы будут переданы на сокет, который мы определили с помощью директивы <code>uwsgi_pass</code>:</p>
<div class="code-label " title="/etc/nginx/sites-available/myproject">/etc/nginx/sites-available/myproject</div><pre class="code-pre "><code langs="">server {
    listen 80;
    server_name <span class="highlight">your_domain</span> www.<span class="highlight">your_domain</span>;

    location / {
        include uwsgi_params;
        uwsgi_pass unix:/home/<span class="highlight">sammy</span>/<span class="highlight">myproject</span>/<span class="highlight">myproject</span>.sock;
    }
}
</code></pre>
<p>Сохраните файл и закройте его после завершения.</p>

<p>Чтобы активировать созданную конфигурацию серверных блоков Nginx, необходимо привязать файл к каталогу <code>sites-enabled</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo ln -s /etc/nginx/sites-available/<span class="highlight">myproject</span> /etc/nginx/sites-enabled
</li></ul></code></pre>
<p>Когда этот файл будет в данном каталоге, мы сможем провести проверку на ошибки синтаксиса с помощью следующей команды:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nginx -t
</li></ul></code></pre>
<p>Если ошибок обнаружено не будет, перезапустите процесс Nginx для чтения новой конфигурации:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl restart nginx
</li></ul></code></pre>
<p>В заключение снова изменим настройки брандмауэра. Нам больше не потребуется доступ через порт <code>5000</code>, и мы можем удалить это правило. Затем мы сможем разрешить доступ к серверу Nginx:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo ufw delete allow 5000
</li><li class="line" prefix="$">sudo ufw allow 'Nginx Full'
</li></ul></code></pre>
<p>Теперь у вас должна быть возможность открыть доменное имя вашего сервера в браузере:</p>
<pre class="code-pre "><code langs="">http://<span class="highlight">your_domain</span>
</code></pre>
<p>Вы должны увидеть результат выполнения вашего приложения:</p>

<p><img src="https://assets.digitalocean.com/articles/nginx_uwsgi_wsgi_1404/test_app.png" alt="Образец приложения Flask"></p>

<p>Если будут обнаружены любые ошибки, проверьте следующее:</p>

<ul>
<li><code>sudo less /var/log/nginx/error.log</code>: проверяет журналы ошибок Nginx.</li>
<li><code>sudo less /var/log/nginx/access.log</code>: проверяет журналы доступа Nginx.</li>
<li><code>sudo journalctl -u nginx</code>: проверяет журналы процессов Nginx.</li>
<li><code>sudo journalctl -u <span class="highlight">myproject</span></code>: проверяет журналы uWSGI вашего приложения Flask.</li>
</ul>

<h2 id="Шаг-7-—-Защита-приложения">Шаг 7 — Защита приложения</h2>

<p>Чтобы обеспечить защиту трафика вашего сервера, необходимо получить сертификат SSL для вашего домена. Этого можно добиться несколькими способами, в том числе получить бесплатный сертификат от <a href="https://letsencrypt.org/">Let&rsquo;s Encrypt</a>, <a href="https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-nginx-in-ubuntu-18-04">сгенерировать сертификат с собственной подпись</a> ю или приобрести <a href="https://www.digitalocean.com/community/tutorials/how-to-install-an-ssl-certificate-from-a-commercial-certificate-authority">сертификат у другого поставщика</a>  и настроить Nginx для его использования, для чего потребуется выполнить шаги с 2 по 6 <a href="https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-nginx-in-ubuntu-18-04#step-2-%E2%80%93-configuring-nginx-to-use-ssl">обучающего модуля Создание сертификата SSL с собственной подписью для Nginx в Ubuntu 18.04</a>. Для удобства мы выберем первый вариант.</p>

<p>Вначале добавьте хранилище Certbot Ubuntu:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo add-apt-repository ppa:certbot/certbot
</li></ul></code></pre>
<p>Вам нужно будет нажать <code>ENTER</code> для подтверждения.</p>

<p>Затем установите пакет Certbot Nginx с <code>apt</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt install python-certbot-nginx
</li></ul></code></pre>
<p>Certbot предоставляет широкий выбор способов получения сертификатов SSL с помощью плагинов: Плагин Nginx изменит конфигурацию Nginx и перезагрузит ее, когда это потребуется. Для использования этого плагина введите следующую команду:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo certbot --nginx -d <span class="highlight">your_domain</span> -d www.<span class="highlight">your_domain</span>
</li></ul></code></pre>
<p>Эта команда запускает <code>certbot</code> с плагином <code>--nginx</code>, используя опцию <code>-d</code> to для указания имен, для которых должен действовать сертификат.</p>

<p>Если это первый запуск <code>certbot</code>, вам будет предложено указать адрес эл. почты и принять условия обслуживания. После этого <code>certbot</code> свяжется с сервером Let&rsquo;s Encrypt и отправит запрос с целью подтвердить, что вы контролируете домен, для которого запрашиваете сертификат.</p>

<p>Если это будет подтверждено, <code>certbot</code> запросит у вас предпочитаемый вариант настройки HTTPS:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Please choose whether or not to redirect HTTP traffic to HTTPS, removing HTTP access.
-------------------------------------------------------------------------------
1: No redirect - Make no further changes to the webserver configuration.
2: Redirect - Make all requests redirect to secure HTTPS access. Choose this for
new sites, or if you're confident your site works on HTTPS. You can undo this
change by editing your web server's configuration.
-------------------------------------------------------------------------------
Select the appropriate number [1-2] then [enter] (press 'c' to cancel):
</code></pre>
<p>Выберите желаемый вариант, после чего нажмите <code>ENTER</code>. Конфигурация будет обновлена, а Nginx перезагрузится для получения новых настроек. Затем <code>certbot</code> завершит работу и выведет сообщение, подтверждающее завершение процесса и указывающее место хранения ваших сертификатов:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>IMPORTANT NOTES:
 - Congratulations! Your certificate and chain have been saved at:
   /etc/letsencrypt/live/<span class="highlight">your_domain</span>/fullchain.pem
   Your key file has been saved at:
   /etc/letsencrypt/live/<span class="highlight">your_domain</span>/privkey.pem
   Your cert will expire on 2018-07-23. To obtain a new or tweaked
   version of this certificate in the future, simply run certbot again
   with the "certonly" option. To non-interactively renew *all* of
   your certificates, run "certbot renew"
 - Your account credentials have been saved in your Certbot
   configuration directory at /etc/letsencrypt. You should make a
   secure backup of this folder now. This configuration directory will
   also contain certificates and private keys obtained by Certbot so
   making regular backups of this folder is ideal.
 - If you like Certbot, please consider supporting our work by:

   Donating to ISRG / Let's Encrypt:   https://letsencrypt.org/donate
   Donating to EFF:                    https://eff.org/donate-le

</code></pre>
<p>Если вы следовали инструкциям по установке Nginx из предварительных требований, вам больше не потребуется разрешать профиль HTTP лишний раз:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo ufw delete allow 'Nginx HTTP'
</li></ul></code></pre>
<p>Чтобы подтвердить конфигурацию, снова перейдите в свой домен, используя префикс адреса <code>https://</code>:</p>
<pre class="code-pre "><code langs="">https://<span class="highlight">your_domain</span>
</code></pre>
<p>Вы снова должны увидеть результат выполнения приложения, а также значок замка в браузере, подтверждающий, что сайт защищен.</p>

<h2 id="Заключение">Заключение</h2>

<p>В этом обучающем модуле вы научились создавать и защищать простое приложение Flask в виртуальной среде Python. Вы создали точку входа WSGI, с которой может взаимодействовать любой сервер приложений с поддержкой WSGI, а затем настроили сервер приложения uWSGI для обеспечения этой функции. После этого вы создали служебный файл systemd, который автоматически запускает сервер приложений при загрузке. Также вы создали серверный блок Nginx, который передает трафик веб-клиента на сервер приложений, перенаправляет внешние запросы и защищает трафик вашего сервера с помощью сертификата Let&rsquo;s Encrypt.</p>

<p>Flask — простая, но очень гибкая инфраструктура приложения, обеспечивающая работу приложений без значительных структурных ограничений. Вы можете использовать описанный в этом обучающем модуле комплекс для обслуживания разрабатываемых вами приложений flask.</p>
