---
layout: post
title: Как настроить Nginx Ingress с Cert-Manager в DigitalOcean Kubernetes
network: digitalocean
date: January 07, 2020 at 08:01PM
url: https://www.digitalocean.com/community/tutorials/how-to-set-up-an-nginx-ingress-with-cert-manager-on-digitalocean-kubernetes-ru
image: http://ifttt.com/images/no_image_card.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="Введение">Введение</h3>

<p>Сущности <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/">Ingress</a> в Kubernetes обеспечивают гибкую маршрутизацию внешнего трафика кластера Kubernetes среди служб внутри кластера. Это достигается с помощью <em>ресурсов</em> Ingress, которые определяют правила маршрутизации трафика HTTP и HTTPS для служб Kubernetes, и <em>контроллеров</em> Ingress, которые реализуют правила порседством балансировки нагрузки трафика и его перенаправления на соответствующие службы серверной части. В число популярных контроллеров Ingress входят <a href="https://github.com/kubernetes/ingress-nginx/blob/master/README.md">Nginx</a>, <a href="https://github.com/heptio/contour">Contour</a>, <a href="https://www.haproxy.com/blog/haproxy_ingress_controller_for_kubernetes/">HAProxy</a> и <a href="https://github.com/containous/traefik">Traefik</a>. Сущности Ingress — это более эффективная и гибкая альтернатива настройке множеству разных объектов служб LoadBalancer, каждый из которых использует собственный выделенный балансировщик нагрузки.</p>

<p>В этом руководстве мы настроим <a href="https://github.com/kubernetes/ingress-nginx">контроллер Nginx Ingress</a>, обслуживаемый Kubernetes, и создадим несколько ресурсов Ingress для маршуртизации трафика на фиктивные серверные службы. После настройки Ingress мы установим в наш кластер <a href="https://github.com/jetstack/cert-manager">cert-manager</a> для управления и распределения сертификатами TLS для шифрования трафика HTTP в Ingress.</p>

<h2 id="Предварительные-требования">Предварительные требования</h2>

<p>Прежде чем начать прохождение этого обучающего модуля, вам потребуется следующее:</p>

<ul>
<li>Кластер Kubernetes 1.10+ с включенным <a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">контролем доступа на основе ролей</a> (RBAC)</li>
<li>Инструмент командной строки <code>kubectl</code>, установленный на локальном компьютере и настроенный для подключения к вашему кластеру. Дополнительную информацию об установке <code>kubectl</code> можно найти в <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/">официальной документации</a>.</li>
<li>Доменное имя и записи DNS A, которые можно направить на балансировщик нагрузки DigitalOcean, используемый Ingress. Если вы используете DigitalOcean для управления записями DNS вашего домена, руководство <a href="https://www.digitalocean.com/docs/networking/dns/how-to/manage-records/">Управление записями DNS</a> поможет вам научиться создавать записи класса A.</li>
<li>Диспетчер пакетов Helm на локальном компьютере и Tiller на кластере, установленные в соответствии с указаниями обучающего модуля <a href="https://www.digitalocean.com/community/tutorials/how-to-install-software-on-kubernetes-clusters-with-the-helm-package-manager">«Установка программного обеспечения на кластерах Kubernetes с диспетчером пакетов Helm»</a>. Убедитесь, что вы используете версию Helm 2.12.1 или более позднюю, иначе могут возникнуть проблемы с установкой таблицы cert-manager в Helm. Чтобы проверить установленную версию Helm, запустите команду <code>helm version</code> на локальном компьютере.</li>
<li>Инструмент командной строки <code>wget</code>, установленный на локальном компьютере. Вы можете установить <code>wget</code> с помощью диспетчера пакетов, встроенного в операционную систему.</li>
</ul>

<p>Проверив наличие этих компонентов, вы можете начинать прохождение этого обучающего модуля.</p>

<h2 id="Шаг-1-—-Настройка-фиктивных-серверных-служб">Шаг 1 — Настройка фиктивных серверных служб</h2>

<p>Перед развертыванием контроллера Ingress мы создадим и развернем две фиктивных службы echo, на которые будем перенаправлять внешний трафик с помощью Ingress. Службы echo будут запускать контейнер <a href="https://hub.docker.com/r/hashicorp/http-echo/"><code>hashicorp/http-echo</code></a>, возвращающий страницу с текстовой строкой, переданной при запуске веб-сервера. Дополнительную информацию по <code>http-echo</code> можно получить в <a href="https://github.com/hashicorp/http-echo">GitHub Repo</a>, а дополнительную информацию о службах Kubernetes можно найти в разделе <a href="https://kubernetes.io/docs/concepts/services-networking/service/">Services</a> в официальной документации Kubernetes.</p>

<p>Создайте на локальном компьютере файл <code>echo1.yaml</code> и откройте его в <code>nano</code> или другом текстовом редакторе:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano echo1.yaml
</li></ul></code></pre>
<p>Вставьте в него следующий манифест служб и развертывания:</p>
<div class="code-label " title="echo1.yaml">echo1.yaml</div><pre class="code-pre "><code langs="">apiVersion: v1
kind: Service
metadata:
  name: echo1
spec:
  ports:
  - port: 80
    targetPort: 5678
  selector:
    app: echo1
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: echo1
spec:
  selector:
    matchLabels:
      app: echo1
  replicas: 2
  template:
    metadata:
      labels:
        app: echo1
    spec:
      containers:
      - name: echo1
        image: hashicorp/http-echo
        args:
        - "-text=echo1"
        ports:
        - containerPort: 5678
</code></pre>
<p>В этом файле мы определяем службу с именем <code>echo1</code>, которая перенаправляет трафик в поды  с помощью селектора ярлыка <code>app: echo1</code>. Она принимает трафик TCP на порту <code>80</code> и перенаправляет его на порт <code>5678</code>,используемый <code>http-echo</code> по умолчанию.</p>

<p>Затем мы определяем развертывание с именем <code>echo1</code>, которое управляет подами с селектором <code>app: echo1</code> <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/">Label Selector</a>. Мы указываем, что в развертывании должно быть 2 копии пода, и что поды должны запускать контейнер <code>echo1</code> с образом <code>hashicorp/http-echo</code>. Мы передаем параметр <code>text</code> и устанавливаем для него значение <code>echo1</code>, так что веб-сервер <code>http-echo</code> возвращает <code>echo1</code>. Наконец, мы открываем порт <code>5678</code> в контейнере подов.</p>

<p>Проверив манифест фиктивной службы и развертывания, сохраните и закройте файл.</p>

<p>Создайте ресурсы Kubernetes с помощью <code>kubectl create</code> с флагом <code>-f</code>, указав только что сохраненный файл в качестве параметра:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl create -f echo1.yaml
</li></ul></code></pre>
<p>Вы должны увидеть следующий результат:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>service/echo1 created
deployment.apps/echo1 created
</code></pre>
<p>Убедитесь, что служба запустилась правильно, и проверьте наличие ClusterIP, внутреннего IP-адреса, по которому доступна служба:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get svc echo1
</li></ul></code></pre>
<p>Вы должны увидеть следующий результат:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME      TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE
echo1     ClusterIP   10.245.222.129   &lt;none&gt;        80/TCP    60s
</code></pre>
<p>Это означает, что служба <code>echo1</code> доступна по внутреннему IP-адресу <code>10.245.222.129</code> на порту <code>80</code>. Она будет перенаправлять трафик в порт контейнера <code>5678</code> на выбранных ей подах.</p>

<p>Теперь служба <code>echo1</code> запущена, и мы можем повторить процедуру для службы <code>echo2</code>.</p>

<p>Создайте и откройте файл с именем <code>echo2.yaml</code>:</p>
<div class="code-label " title="echo2.yaml">echo2.yaml</div><pre class="code-pre "><code langs="">apiVersion: v1
kind: Service
metadata:
  name: echo2
spec:
  ports:
  - port: 80
    targetPort: 5678
  selector:
    app: echo2
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: echo2
spec:
  selector:
    matchLabels:
      app: echo2
  replicas: 1
  template:
    metadata:
      labels:
        app: echo2
    spec:
      containers:
      - name: echo2
        image: hashicorp/http-echo
        args:
        - "-text=echo2"
        ports:
        - containerPort: 5678
</code></pre>
<p>Здесь мы используем тот же манифест служб и развертывания, что и выше, но будем использовать имя и ярлык <code>echo2</code>. Кроме того, для разнообразия мы создадим только 1 копию пода. Для параметра <code>text</code> мы установим значение <code>echo2</code>, чтобы веб-сервер возвращал текст <code>echo2</code>.</p>

<p>Сохраните и закройте файл и создайте ресурсы Kubernetes с помощью <code>kubectl</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl create -f echo2.yaml
</li></ul></code></pre>
<p>Вы должны увидеть следующий результат:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>service/echo2 created
deployment.apps/echo2 created
</code></pre>
<p>Еще раз проверьте, запущена ли служба:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get svc
</li></ul></code></pre>
<p>Вы должны увидеть службы <code>echo1</code> и <code>echo2</code> с назначенными им значениями ClusterIP:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE
echo1        ClusterIP   10.245.222.129   &lt;none&gt;        80/TCP    6m6s
echo2        ClusterIP   10.245.128.224   &lt;none&gt;        80/TCP    6m3s
kubernetes   ClusterIP   10.245.0.1       &lt;none&gt;        443/TCP   4d21h
</code></pre>
<p>Теперь наши фиктивные веб-службы эхо запущены, и мы можем перейти к развертыванию контроллера Nginx Ingress.</p>

<h2 id="Шаг-2-—-Настройка-контроллера-kubernetes-nginx-ingress">Шаг 2 — Настройка контроллера Kubernetes Nginx Ingress</h2>

<p>На этом шаге мы развернем версию <code><span class="highlight">v0.24.1</span></code> <a href="https://github.com/kubernetes/ingress-nginx">контроллера Nginx Ingress</a>, обслуживаемого Kubernetes. Существует <a href="https://github.com/nginxinc/kubernetes-ingress/blob/master/docs/nginx-ingress-controllers.md">несколько</a> контроллеров Nginx Ingress. Сообщество Kubernetes обслуживает контроллер, используемый в этом обучающем модуле, а Nginx Inc. обслуживает <a href="https://github.com/nginxinc/kubernetes-ingress">kubernetes-ingress</a>. Указания этого обучающего модуля основаны на приведенных в <a href="https://kubernetes.github.io/ingress-nginx/deploy/">официальном руководстве по установке контроллера Kubernetes Nginx Ingress</a>.</p>

<p>Контроллер Nginx Ingress состоит из пода, который запускает веб-сервер Nginx и наблюдает за плоскостью управления Kubernetes для обнаружения новых и обновленных объектов ресурсов Ingress. Ресурс Ingress фактически представляет собой список правил маршрутизации трафика для серверных служб. Например, правило Ingress может указывать, что входящий трафик HTTP на пути <code>/web1</code> следует перенаправлять на веб-сервер <code>web1</code>. С помощью ресурсов Ingress также можно выполнять маршрутизацию на базе хоста: например, запросы маршрутизации для <code>web1.your_domain.com</code> на серверную службу Kubernetes <code>web1</code>.</p>

<p>В данном случае мы развертываем контроллер Ingress в кластере DigitalOcean Kubernetes, и контроллер создаст службу LoadBalancer, запускающую балансировщик нагрузки DigitalOcean, на который будет направляться весь внешний трафик. Балансировщик нагрузки будет направлять внешний трафик на под контроллера Ingress под управлением Nginx, откуда трафик будет перенаправляться в соответствующие серверные службы.</p>

<p>Для начала мы создадим необходимые ресурсы Kubernetes для контроллера Nginx Ingress. В их число входят карты ConfigMaps, содержащие конфигурацию контроллера, роли системы RBAC, предоставляющие контроллеру доступ Kubernetes API, и фактическое развертывание контроллера Ingress, использующее версию <a href="https://quay.io/repository/kubernetes-ingress-controller/nginx-ingress-controller?tag=0.24.1&amp;tab=tags">0.24.1</a> образа контроллера Nginx Ingress. Чтоб просмотреть полный список требуемых ресурсов, ознакомьтесь с <a href="https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.24.1/deploy/mandatory.yaml">манифестом</a> репозитория контроллера Kubernetes Nginx Ingress на GitHub.</p>

<p>Для создания этих обязательных ресурсов используйте команду <code>kubectl apply</code> с флагом <code>-f</code> для указания файла манифеста, размещенного на GitHub:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/<span class="highlight">nginx-0.24.1</span>/deploy/mandatory.yaml
</li></ul></code></pre>
<p>Мы используем <code>apply</code> вместо <code>create</code> ,чтобы в будущем мы могли <code>применять</code> изменения к объектам контроллера Ingress, а не перезаписывать их полностью. Дополнительную информацию о команде <code>apply</code> можно найти в разделе <a href="https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#kubectl-apply">«Управление ресурсами»</a> в официальной документации по Kubernetes.</p>

<p>Вы должны увидеть следующий результат:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>namespace/ingress-nginx created
configmap/nginx-configuration created
configmap/tcp-services created
configmap/udp-services created
serviceaccount/nginx-ingress-serviceaccount created
clusterrole.rbac.authorization.k8s.io/nginx-ingress-clusterrole created
role.rbac.authorization.k8s.io/nginx-ingress-role created
rolebinding.rbac.authorization.k8s.io/nginx-ingress-role-nisa-binding created
clusterrolebinding.rbac.authorization.k8s.io/nginx-ingress-clusterrole-nisa-binding created
deployment.extensions/nginx-ingress-controller created
</code></pre>
<p>На этом экране результатов приведен удобный обзор всех объектов контроллера Ingress, созданных из манифеста <code>mandatory.yaml</code>.</p>

<p>Далее мы создадим службу LoadBalancer контроллера Ingress, которая создаст балансировщик нагрузки DigitalOcean для балансировки и маршрутизации трафика HTTP и HTTPS на под контроллера Ingress, который мы развернули предыдущей командой.</p>

<p>Для создания службы LoadBalancer мы снова используем команду <code>kubectl</code> apply с файлом манифеста, содержащим определение службы:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/<span class="highlight">nginx-0.24.1</span>/deploy/provider/cloud-generic.yaml
</li></ul></code></pre>
<p>Вы должны увидеть следующий результат:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>service/ingress-nginx created
</code></pre>
<p>Убедитесь, что балансировщик нагрузки DigitalOcean создан успешно, получив детали службы с помощью команды <code>kubectl</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get svc --namespace=ingress-nginx
</li></ul></code></pre>
<p>Вы должны использовать внешний IP-адрес, соответствующий IP-адресу балансировщика нагрузки DigitalOcean:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME            TYPE           CLUSTER-IP      EXTERNAL-IP       PORT(S)                      AGE
ingress-nginx   LoadBalancer   <span class="highlight">10.245.247.67</span>   <span class="highlight">203.0.113.0</span>   80:32486/TCP,443:32096/TCP   20h
</code></pre>
<p>Запишите внешний IP-адрес балансировщика нагрузки, поскольку он потребуется вам позднее.</p>

<p><span class='note'><strong>Примечание.</strong> По умолчанию служба Nginx Ingress LoadBalancer использует для параметра <code>service.spec.externalTrafficPolicy</code> значение <code>Local</code>, в результате чего весь трафик балансировщика нагрузки перенаправляется на узлы, где запущены поды Nginx Ingress. Другие узлы целенаправленно не будут проходить проверки балансировщика нагрузки, чтобы трафик Ingress не направлялся на эти узлы. Политики внешнего трафика не описываются в этом обучающем модуле, но дополнительную информацию можно найти в руководствах <a href="https://www.asykim.com/blog/deep-dive-into-kubernetes-external-traffic-policies">«Подробное описание политик внешнего трафика Kubernetes»</a> и <a href="https://kubernetes.io/docs/tutorials/services/source-ip/#source-ip-for-services-with-type-loadbalancer">«Исходный IP для служб с типом Type=LoadBalancer»</a> в официальной документации по Kubernetes.<br></span></p>

<p>Этот балансировщик нагрузки принимает трафик на портах HTTP и HTTPS 80 и 443, и перенаправляет его на под контроллера Ingress. Контроллер Ingress перенаправляет трафик на соответствующую серверную службу.</p>

<p>Теперь мы сделаем так, чтобы наши записи DNS указывали на этот внешний балансировщик нагрузки, и создадим некоторые ресурсы Ingress для внедрения правил маршрутизации трафика.</p>

<h2 id="Шаг-3-—-Создание-ресурсов-ingress">Шаг 3 — Создание ресурсов Ingress</h2>

<p>Для начала мы создадим минимальный ресурс Ingress для перенаправления трафика указанного субдомена на соответствующую серверную службу.</p>

<p>В этом обучающем модуле мы используем тестовый домен <strong>example.com</strong>. Вы должны заменить его вашим доменным именем.</p>

<p>Вначале мы создадим простое правило для перенаправления адресованного <strong>echo1.<span class="highlight">example.com</span></strong> трафика на серверную службу <code>echo1</code> и адресованного <strong>echo2.<span class="highlight">example.com</span></strong> трафика на серверную службу <code>echo2</code>.</p>

<p>Для начала откройте файл <code>echo_ingress.yaml</code> в предпочитаемом редакторе:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano echo_ingress.yaml
</li></ul></code></pre>
<p>Вставьте следующее определение Ingress:</p>
<div class="code-label " title="echo_ingress.yaml">echo_ingress.yaml</div><pre class="code-pre "><code langs="">apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: echo-ingress
spec:
  rules:
  - host: echo1.<span class="highlight">example.com</span>
    http:
      paths:
      - backend:
          serviceName: echo1
          servicePort: 80
  - host: echo2.<span class="highlight">example.com</span>
    http:
      paths:
      - backend:
          serviceName: echo2
          servicePort: 80
</code></pre>
<p>Когда вы закончите редактирование правил Ingress, сохраните и закройте файл.</p>

<p>Мы указали, что хотим создать ресурс Ingress с именем <code>echo-ingress</code> и перенаправлять трафик на базе заголовка Host. В запросе HTTP заголовок Host указывает доменное имя целевого сервера. Дополнительную информацию о заголовках Host можно найти <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host">на странице определений</a> Mozilla Developer Network. Запросы хоста <strong>echo1.<span class="highlight">example.com</span></strong> будут перенаправляться на серверную службу <code>echo1</code>, настроенную на шаге 1, а запросы хоста <strong>echo2.<span class="highlight">example.com</span></strong> будут перенаправляться на серверную службу <code>echo2</code>.</p>

<p>Теперь вы можете создать Ingress с помощью <code>kubectl</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f echo_ingress.yaml
</li></ul></code></pre>
<p>Вы увидите следующий экран результатов, подвтерждающий создание Ingress:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>ingress.extensions/echo-ingress created
</code></pre>
<p>Чтобы протестировать Ingress, перейдите в службу управления DNS и создайте записи A для <code>echo1.example.com</code> и <code>echo2.example.com</code>, указывающие на внешний IP-адрес балансировщика нагрузки DigitalOcean. Внешний IP-адрес балансировщика нагрузки соответствует внешнему IP-адресу службы i<code>ngress-nginx</code>, полученному на предыдущем шаге. Если вы используете DigitalOcean для управления записями DNS вашего домена, руководство <a href="https://www.digitalocean.com/docs/networking/dns/how-to/manage-records/">Управление записями DNS</a> поможет вам научиться создавать записи класса A.</p>

<p>После создания необходимых записей <code>echo1.example.com</code> и <code>echo2.example.com</code> вы можете протестировать контроллер Ingress и созданные ресурсы с помощью утилиты командной строки <code>curl</code>.</p>

<p>Выполните команду <code>curl</code> для службы <code>echo1</code> на локальном компьютере:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">curl echo1.example.com
</li></ul></code></pre>
<p>Вы должны получить следующий ответ от службы <code>echo1</code>:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>echo1
</code></pre>
<p>Это подтверждает, что ваш запрос <code>echo1.example.com</code> правильно перенаправляется через Nginx ingress в серверную службу <code>echo1</code>.</p>

<p>Теперь повторите этот тест для службы <code>echo2</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">curl echo2.example.com
</li></ul></code></pre>
<p>Вы должны получить следующий ответ от службы <code>echo2</code>:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>echo2
</code></pre>
<p>Это подтверждает, что ваш запрос <code>echo2.example.com</code> правильно перенаправляется через Nginx ingress в серверную службу <code>echo2</code>.</p>

<p>Вы успешно выполнили базовую настройку Nginx Ingress для маршрутизации на базе виртуального хоста. На следующем шаге мы установим <a href="https://github.com/jetstack/cert-manager">cert-manager</a> с помощью Helm для предоставления сертификатов TLS для Ingress и использования более защищенного протокола HTTPS.</p>

<h2 id="Шаг-4-—-Установка-и-настройка-cert-manager">Шаг 4 — Установка и настройка Cert-Manager</h2>

<p>На этмо шаге мы используем Helm для установки cert-manager в нашем кластере. cert-manager — это служба Kubernetes, предоставляющая сертификаты TLS от <a href="https://letsencrypt.org/">Let&rsquo;s Encrypt</a> и других центров сертификации и управляющая их жизненными циклами. Сертификаты можно запрашивать и настраивать посредством аннотации ресурсов Ingress с помощью аннотации <code>certmanager.k8s.io/issuer</code> с добавлением раздела <code>tls</code> в спецификацию Ingress и настройкой одного или нескольких элементов <em>Issuer</em> для определения предпочитаемого центра сертификации. Дополнительную информацию об объектах Issuer можно найти в официальной документации cert-manager по элементам <a href="https://cert-manager.readthedocs.io/en/latest/reference/issuers.html">Issuer</a>.</p>

<p><span class='note'><strong>Примечание.</strong> Перед установкой cert-manager убедитесь, что вы используете версию Helm 2.12.1 или более позднюю версию. Чтобы проверить установленную версию Helm, запустите команду <code>helm version</code> на локальном компьютере.<br></span></p>

<p>Прежде чем использовать Helm для установки cert-manager в нашем кластере, нам нужно создать <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/">собственные определения ресурсов</a> (CRD) для cert-manager. Используйте для их создания команду <code>apply</code>, чтобы применить их непосредственно из <a href="https://github.com/jetstack/cert-manager/">репозитория cert-manager на GitHub</a>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply \
</li><li class="line" prefix="$">    -f https://raw.githubusercontent.com/jetstack/cert-manager/release-0.8/deploy/manifests/00-crds.yaml
</li></ul></code></pre>
<p>Вы должны увидеть следующий результат:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>customresourcedefinition.apiextensions.k8s.io/certificates.certmanager.k8s.io created
customresourcedefinition.apiextensions.k8s.io/issuers.certmanager.k8s.io created
customresourcedefinition.apiextensions.k8s.io/clusterissuers.certmanager.k8s.io created
customresourcedefinition.apiextensions.k8s.io/orders.certmanager.k8s.io created
customresourcedefinition.apiextensions.k8s.io/challenges.certmanager.k8s.io created
</code></pre>
<p>Теперь мы добавим ярлык пространства имен <code>kube-system</code>, куда мы устанавливаем cert-manager, чтобы обеспечить расширенную проверку ресурсов с помощью <a href="https://docs.cert-manager.io/en/venafi/admin/resource-validation-webhook.html">webhook</a>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl label namespace kube-system certmanager.k8s.io/disable-validation="true"
</li></ul></code></pre>
<p>Теперь мы добавим <a href="https://hub.helm.sh/charts/jetstack">репозиторий Jetstack Helm</a> в Helm. Этот репозиторий содержит <a href="https://hub.helm.sh/charts/jetstack/cert-manager">таблицу Helm</a> для cert-manager.</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">helm repo add jetstack https://charts.jetstack.io
</li></ul></code></pre>
<p>Наконец, мы установим таблицу в пространство имен <code>kube-system</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">helm install --name cert-manager --namespace kube-system jetstack/cert-manager --version v0.8.0
</li></ul></code></pre>
<p>Вы должны увидеть следующий результат:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>. . .
NOTES:
cert-manager has been deployed successfully!

In order to begin issuing certificates, you will need to set up a ClusterIssuer
or Issuer resource (for example, by creating a 'letsencrypt-staging' issuer).

More information on the different types of issuers and how to configure them
can be found in our documentation:

https://cert-manager.readthedocs.io/en/latest/reference/issuers.html

For information on how to configure cert-manager to automatically provision
Certificates for Ingress resources, take a look at the `ingress-shim`
documentation:

https://cert-manager.readthedocs.io/en/latest/reference/ingress-shim.html
</code></pre>
<p>Это означает, что установка cert-manager выполнена успешно.</p>

<p>Прежде чем мы начнем выдачу сертификатов для наших хостов Ingress, нам нужно создать элемент Issuer, определяющий центр сертификации, откуда можно получить подписанные сертификаты x509. В этом обучающем модуле мы используем центр сертификации Let&rsquo;s Encrypt, предоставляющий бесплатные сертификаты TLS и обеспечивающий сервер для тестирования конфигурации сертификатов и рабочий сервер для развертывания проверяемых сертификатов TLS.</p>

<p>Создадим тестовый элемент Issuer, чтобы проверить правильность работы механизма распределения сертификатов. Откройте файл с именем <code>staging_issuer.yaml</code> в своем любимом текстовом редакторе:</p>
<pre class="code-pre "><code langs="">nano staging_issuer.yaml
</code></pre>
<p>Вставьте в него следующий манифест ClusterIssuer:</p>
<div class="code-label " title="staging_issuer.yaml">staging_issuer.yaml</div><pre class="code-pre "><code langs="">apiVersion: certmanager.k8s.io/v1alpha1
kind: ClusterIssuer
metadata:
 name: letsencrypt-staging
spec:
 acme:
   # The ACME server URL
   server: https://acme-staging-v02.api.letsencrypt.org/directory
   # Email address used for ACME registration
   email: <span class="highlight">your_email_address_here</span>
   # Name of a secret used to store the ACME account private key
   privateKeySecretRef:
     name: letsencrypt-staging
   # Enable the HTTP-01 challenge provider
   http01: {}
</code></pre>
<p>Здесь мы указываем, что хотим создать объект ClusterIssuer с именем <code>letsencrypt-staging</code> и использовать сервер размещения Let&rsquo;s Encrypt. Далее мы будем использовать для развертывания сертификатов производственный сервер, но в на этом сервере может быть ограничено количество запросов, и поэтому для тестирования лучше всего использовать URL сервера размещения.</p>

<p>Затем мы укажем адрес электронной почты для регистрации сертификата и создадим <a href="https://kubernetes.io/docs/concepts/configuration/secret/">секрет</a> Kubernetes с именем <code>letsencrypt-staging</code> для сохранения закрытого ключа учетной записи ACME. Также мы активируем механизм вызовов <code>HTTP-01</code>. Дополнительную информацию об этих параметрах можно найти в официальной документации cert-manager по элементам <a href="https://cert-manager.readthedocs.io/en/latest/reference/issuers.html">Issuer</a>.</p>

<p>Разверните ClusterIssuer с помощью <code>kubectl</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl create -f staging_issuer.yaml
</li></ul></code></pre>
<p>Вы должны увидеть следующий результат:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>clusterissuer.certmanager.k8s.io/letsencrypt-staging created
</code></pre>
<p>Теперь мы создали элемент Issuer для сервера размещения Let&rsquo;s Encrypt и готовы изменить созданный выше ресурс Ingress и активировать шифрование TLS для путей <code>echo1.example.com</code> и <code>echo2.example.com</code>.</p>

<p>Откройте <code>echo_ingress.yaml</code> в своем любимом редакторе еще раз:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano echo_ingress.yaml
</li></ul></code></pre>
<p>Добавьте в манифест ресурсов Ingress следующее:</p>
<div class="code-label " title="echo_ingress.yaml">echo_ingress.yaml</div><pre class="code-pre "><code langs="">apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: echo-ingress
  <span class="highlight">annotations:</span>  
    <span class="highlight">kubernetes.io/ingress.class: nginx</span>
    <span class="highlight">certmanager.k8s.io/cluster-issuer: letsencrypt-staging</span>
spec:
  <span class="highlight">tls:</span>
  <span class="highlight">- hosts:</span>
    <span class="highlight">- echo1.example.com</span>
    <span class="highlight">- echo2.example.com</span>
    <span class="highlight">secretName: letsencrypt-staging</span>
  rules:
  - host: echo1.example.com
    http:
      paths:
      - backend:
          serviceName: echo1
          servicePort: 80
  - host: echo2.example.com
    http:
      paths:
      - backend:
          serviceName: echo2
          servicePort: 80
</code></pre>
<p>Здесь мы добавим несколько аннотаций для указания класса <code>Ingress.class</code>, определяющего контроллер Ingress, который должен использоваться для реализации правил Ingress. Кроме того, мы определим для <code>cluster-issuer</code> элемент сертификации <code>letsencrypt-staging,</code> который мы только что создали.</p>

<p>Наконец, мы добавим блок <code>tls</code> для указания хостов, для которых мы хотим получить сертификаты, а также укажем <code>secretName</code>. Этот секрет будет содержать закрытый ключ TLS и выданный сертификат.</p>

<p>Когда вы закончите внесение изменений, сохраните и закройте файл.</p>

<p>Теперь мы обновим существующие ресурсы Ingress с помощью команды <code>kubectl apply</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f echo_ingress.yaml
</li></ul></code></pre>
<p>Вы должны увидеть следующий результат:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>ingress.extensions/echo-ingress configured
</code></pre>
<p>Вы можете использовать команду <code>kubectl describe</code> для отслеживания состояния изменений Ingress, которые вы только что применили:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl describe ingress
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Events:
  Type    Reason             Age               From                      Message
  ----    ------             ----              ----                      -------
  Normal  CREATE             14m               nginx-ingress-controller  Ingress default/echo-ingress
  Normal  UPDATE             1m (x2 over 13m)  nginx-ingress-controller  Ingress default/echo-ingress
  Normal  CreateCertificate  1m                cert-manager              Successfully created Certificate "letsencrypt-staging"
</code></pre>
<p>После успешного создания сертификата вы можете запустить дополнительную команду <code>describe</code>, чтобы еще раз убедиться в успешном его создании:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl describe certificate
</li></ul></code></pre>
<p>Вы должны увидеть следующие результаты в разделе <code>Events</code>:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Events:
  Type    Reason         Age   From          Message
  ----    ------         ----  ----          -------
  Normal  Generated      63s   cert-manager  Generated new private key
  Normal  OrderCreated   63s   cert-manager  Created Order resource "letsencrypt-staging-147606226"
  Normal  OrderComplete  19s   cert-manager  Order "letsencrypt-staging-147606226" completed successfully
  Normal  CertIssued     18s   cert-manager  Certificate issued successfully
</code></pre>
<p>Это подтверждает, что сертификат TLS выдан успешно, и шифрование HTTPS активно для двух настроенных доменов.</p>

<p>Теперь мы готовы отправить запрос на сервер <code>echo</code> для тестирования работы HTTPS.</p>

<p>Запустите следующую команду <code>wget</code> для отправки запроса на <code>echo1.example.com</code> и распечатайте заголовки ответов в <code>STDOUT</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">wget --save-headers -O- echo1.example.com
</li></ul></code></pre>
<p>Вы должны увидеть следующий результат:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>URL transformed to HTTPS due to an HSTS policy
--2018-12-11 14:38:24--  https://echo1.example.com/
Resolving echo1.example.com (echo1.example.com)... 203.0.113.0
Connecting to echo1.example.com (echo1.example.net)|203.0.113.0|:443... connected.
ERROR: cannot verify echo1.example.com's certificate, issued by ‘CN=Fake LE Intermediate X1’:
  Unable to locally verify the issuer's authority.
To connect to echo1.example.com insecurely, use `--no-check-certificate'.
</code></pre>
<p>Это означает, что протокол HTTPS успешно активирован, но сертификат не удается проверить, поскольку это фиктивный временный сертификат, выданный сервером размещения Let&rsquo;s Encrypt.</p>

<p>Мы убедились, что с временным фиктивным сертификатом все работает и можем развернуть два производственных сертификата для двух хостов <code>echo1.example.com</code> и <code>echo2.example.com</code>.</p>

<h2 id="Шаг-5-—-Развертывание-элемента-issuer-в-производственной-среде">Шаг 5 — Развертывание элемента Issuer в производственной среде</h2>

<p>На этом шаге мы изменим процедуру, используемую для выделения фиктивных сертификатов, и генерируем действительный производственный сертификат для наших хостов Ingress.</p>

<p>Вначале мы создадим производственный сертификат ClusterIssuer.</p>

<p>Откройте файл с именем <code>prod_issuer.yaml</code> в своем любимом редакторе:</p>
<pre class="code-pre "><code langs="">nano prod_issuer.yaml
</code></pre>
<p>Вставьте в него следующий манифест:</p>
<div class="code-label " title="prod_issuer.yaml">prod_issuer.yaml</div><pre class="code-pre "><code langs="">apiVersion: certmanager.k8s.io/v1alpha1
kind: ClusterIssuer
metadata:
  name: letsencrypt-prod
spec:
  acme:
    # The ACME server URL
    server: https://acme-v02.api.letsencrypt.org/directory
    # Email address used for ACME registration
    email: <span class="highlight">your_email_address_here</span>
    # Name of a secret used to store the ACME account private key
    privateKeySecretRef:
      name: letsencrypt-prod
    # Enable the HTTP-01 challenge provider
    http01: {}
</code></pre>
<p>Обратите внимание на другой URL сервера ACME и имя секретного ключа <code>letsencrypt-prod</code>.</p>

<p>Когда вы закончите редактирование, сохраните и закройте файл.</p>

<p>Теперь разверните элемент Issuer с помощью <code>kubectl</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl create -f prod_issuer.yaml
</li></ul></code></pre>
<p>Вы должны увидеть следующий результат:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>clusterissuer.certmanager.k8s.io/letsencrypt-prod created
</code></pre>
<p>Обновите <code>echo_ingress.yaml</code> для использования нового элемента Issuer:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano echo_ingress.yaml
</li></ul></code></pre>
<p>Внесите в файл следующие изменения:</p>
<div class="code-label " title="echo_ingress.yaml">echo_ingress.yaml</div><pre class="code-pre "><code langs="">apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: echo-ingress
  annotations:  
    kubernetes.io/ingress.class: nginx
    certmanager.k8s.io/cluster-issuer: <span class="highlight">letsencrypt-prod</span>
spec:
  tls:
  - hosts:
    - echo1.example.com
    - echo2.example.com
    secretName: <span class="highlight">letsencrypt-prod</span>
  rules:
  - host: echo1.example.com
    http:
      paths:
      - backend:
          serviceName: echo1
          servicePort: 80
  - host: echo2.example.com
    http:
      paths:
      - backend:
          serviceName: echo2
          servicePort: 80
</code></pre>
<p>Здесь мы обновим ClusterIssuer и секретное имя на <code>letsencrypt-prod</code>.</p>

<p>После внесения изменений сохраните и закройте файл.</p>

<p>Разверните изменения с помощью команды <code>kubectl apply</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f echo_ingress.yaml
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>ingress.extensions/echo-ingress configured
</code></pre>
<p>Подождите несколько минут, чтобы дать производственному серверу Let&rsquo;s Encrypt выдать сертификат. Вы можете отслеживать ход выполнения с помощью команды <code>kubectl describe</code> для объекта <code>certificate</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl describe certificate letsencrypt-prod
</li></ul></code></pre>
<p>Следующий экран результатов означает, что сертификат успешно установлен:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Events:
  Type    Reason         Age   From          Message
  ----    ------         ----  ----          -------
  Normal  Generated      82s   cert-manager  Generated new private key
  Normal  OrderCreated   82s   cert-manager  Created Order resource "letsencrypt-prod-2626449824"
  Normal  OrderComplete  37s   cert-manager  Order "letsencrypt-prod-2626449824" completed successfully
  Normal  CertIssued     37s   cert-manager  Certificate issued successfully
</code></pre>
<p>Теперь мы проведем тестирование с помощью <code>curl</code>, чтобы подтвердить правильную работу HTTPS:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">curl echo1.example.com
</li></ul></code></pre>
<p>Вы должны увидеть следующее:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>&lt;html&gt;
&lt;head&gt;&lt;title&gt;308 Permanent Redirect&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;center&gt;&lt;h1&gt;308 Permanent Redirect&lt;/h1&gt;&lt;/center&gt;
&lt;hr&gt;&lt;center&gt;nginx/1.15.9&lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Это означает, что запросы HTTP перенаправляются для использования HTTPS.</p>

<p>Запустите <code>curl</code> на <code>https://echo1.example.com</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">curl https://echo1.example.com
</li></ul></code></pre>
<p>Вы должны увидеть следующий результат:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>echo1
</code></pre>
<p>Вы можете запустить предыдущую команду с флагом <code>-v</code> для получения развернутой информации о соединении сертификата и проверки информации о сертификате.</p>

<p>Вы успешно настроили HTTPS с помощью сертификата Let&rsquo;s Encrypt для вашего Nginx Ingress.</p>

<h2 id="Заключение">Заключение</h2>

<p>В этом обучающем модуле вы настроили Nginx Ingress для балансировки нагрузки и перенаправления внешних запросов на серверные службы внутри кластера Kubernetes. Также вы защитили Ingress, установив элемент обеспечения сертификата cert-manager и установив для двух путей хоста сертификат Let&rsquo;s Encrypt.</p>

<p>Существует множество альтернатив использованию контроллера Nginx Ingress. Дополнительную информацию можно найти в разделе <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-controllers">«Контроллеры Ingress»</a> в официальной документации Kubernetes.</p>
