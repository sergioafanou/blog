---
layout: post
title: Знакомство с картами в Go
network: digitalocean
date: January 24, 2020 at 04:41AM
url: https://www.digitalocean.com/community/tutorials/understanding-maps-in-go-ru
image: http://ifttt.com/images/no_image_card.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<p>В большинстве современных языков программирования применяется концепция <em>словаря</em> или <em>хэша</em>. Эти типы обычно используются для хранения данных в парах, где <strong>ключ</strong> соответствует <strong>значению</strong>.</p>

<p>В Go тип данных <em>map</em> используется как тип <em>dictionary</em> в большинстве других языков программирования. Он сопоставляет ключи со значениями, создавая пары ключ-значение, представляющие собой полезный способ хранения данных в Go. Построение карты осуществляется с помощью ключевого слова <code>map</code> с последующим указанием типа данных ключа в квадратных скобках <code>[ ]</code> и типа данных значения. Пары ключ-значение заключаются в фигурные скобки { }:</p>
<pre class="code-pre plain"><code langs="">map[<span class="highlight">key</span>]<span class="highlight">value</span>{}
</code></pre>
<p>Карты в Go обычно используются для хранения связанных данных, например, содержащейся в идентификаторах информации. Карта с данными выглядит следующим образом:</p>
<pre class="code-pre "><code class="code-highlight language-go">map[string]string{"name": "Sammy", "animal": "shark", "color": "blue", "location": "ocean"}
</code></pre>
<p>В дополнение к фигурным скобкам в карте используются двоеточия, соединяющие пары ключ-значение. Слова слева от двоеточий являются ключами. Ключи могут иметь любой <em>сравниваемый</em> тип в Go, в том числе <code>строки</code>, <code>целые числа</code> и т. д.</p>

<p>Ключи в примере карты:</p>

<ul>
<li><code>"name"</code></li>
<li><code>"animal"</code></li>
<li><code>"color"</code></li>
<li><code>"location"</code></li>
</ul>

<p>Слова справа от двоеточий являются значениями. Значения могут относиться к любому типу данных. Значения в примере карты:</p>

<ul>
<li><code>"Sammy"</code></li>
<li><code>"shark"</code></li>
<li><code>"blue"</code></li>
<li><code>"ocean"</code></li>
</ul>

<p>Как и другие типы данных, карты могут храниться в переменных и выводиться:</p>
<pre class="code-pre "><code class="code-highlight language-go">sammy := map[string]string{"name": "Sammy", "animal": "shark", "color": "blue", "location": "ocean"}
fmt.Println(sammy)
</code></pre>
<p>Результат будет выглядеть так:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>map[animal:shark color:blue location:ocean name:Sammy]
</code></pre>
<p>Порядок пар ключ-значение можно изменять. Тип данных карт Go является неупорядоченным. Вне зависимости от порядка, пары ключ-значение останутся без изменений, что даст возможность доступа к данным по их относительному значению.</p>

<h2 id="Доступ-к-элементам-карты">Доступ к элементам карты</h2>

<p>Вы можете вызывать значения карты, ссылаясь на соответствующие ключи. Поскольку карты предоставляют пары ключ-значение для хранения данных, они могут стать полезным элементом вашей программы Go.</p>

<p>Если вы хотите изолировать имя пользователя Sammy, вы можете вызвать для этого переменную <code>sammy["name"]</code>, которая содержит карту и связанный ключ. Распечатаем результат:</p>
<pre class="code-pre "><code class="code-highlight language-go">fmt.Println(sammy["name"])
</code></pre>
<p>Получим значение в качестве результата:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Sammy
</code></pre>
<p>Карты похожи на базы данных, однако вместо вызова целого числа для получения определенного значения индекса, как в срезе, вы присваиваете значение ключу и вызываете ключ для получения связанного значения.</p>

<p>Вызывая ключ <code>"name"</code>, вы получаете значение этого ключа, то есть <code>"Sammy"</code>.</p>

<p>Также вы можете вызывать остальные значения карты <code>sammy</code> в том же формате:</p>
<pre class="code-pre "><code class="code-highlight language-go">fmt.Println(sammy["animal"])
// returns shark

fmt.Println(sammy["color"])
// returns blue

fmt.Println(sammy["location"])
// returns ocean
</code></pre>
<p>Используя пары ключ-значение в типах данных карт, вы можете ссылаться на ключи для получения значений.</p>

<h2 id="Ключи-и-значения">Ключи и значения</h2>

<p>В отличие от некоторых языков программирования, в Go отсутствуют <em>удобные</em> функции вывода списка ключей или значений карты. В качестве примера такой функции можно назвать метод Python <code>.keys()</code> для словарей. Однако он поддерживает итерацию с использованием оператора <code>range</code>:</p>
<pre class="code-pre "><code class="code-highlight language-go">for key, value := range sammy {
    fmt.Printf("%q is the key for the value %q\n", key, value)
}
</code></pre>
<p>При ранжировании карты в Go выводится два значения. Первое значение будет ключом, а второе — значением. Go создаст эти переменные с правильным типом данных. В данном случае ключ карты представлял собой <code>строку</code>, поэтому <code>ключ</code> также будет строкой. <code>Значение</code> также является строкой:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>"animal" is the key for the value "shark"
"color" is the key for the value "blue"
"location" is the key for the value "ocean"
"name" is the key for the value "Sammy"
</code></pre>
<p>Чтобы получить только список ключей, вы можете еще раз использовать оператор range. Чтобы получить доступ только к ключам, вы можете декларировать только одну переменную:</p>
<pre class="code-pre "><code class="code-highlight language-go">keys := []string{}

for key := range sammy {
    keys = append(keys, key)
}
fmt.Printf("%q", keys)
</code></pre>
<p>Вначале программа декларирует срез для хранения ваших ключей.</p>

<p>В результатах будут показаны только ключи вашей карты:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>["color" "location" "name" "animal"]
</code></pre>
<p>Ключи не сортируются. Если вы хотите сортировать их, используйте функцию <code>sort.Strings</code> из пакета <a href="https://golang.org/pkg/sort"><code>sort</code></a>:</p>
<pre class="code-pre "><code class="code-highlight language-go">sort.Strings(keys)
</code></pre>
<p>С помощью этой функции вы получите следующие результаты:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>["animal" "color" "location" "name"]
</code></pre>
<p>Вы можете использовать тот же шаблон для получения значений карты. В следующем примере вы предварительно выделите заранее срез для предотвращения подобных действий, что сделает программу более эффективной:</p>
<pre class="code-pre "><code class="code-highlight language-go">sammy := map[string]string{"name": "Sammy", "animal": "shark", "color": "blue", "location": "ocean"}

items := make([]string, len(sammy))

var i int

for _, v := range sammy {
    items[i] = v
    i++
}
fmt.Printf("%q", items)
</code></pre>
<p>Вначале вы декларируете срез для хранения ключей. Поскольку вы знаете, сколько вам требуется элементов, вы можете избежать несоответствия при выделении памяти, определив точный размер среза. После этого вы декларируете переменную индекса. Поскольку вам не нужен ключ, вы используете оператор <code>_</code> при запуске цикла, чтобы игнорировать значение ключа. Результат будет выглядеть так:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>["ocean" "Sammy" "shark" "blue"]
</code></pre>
<p>Чтобы определить количество элементов на карте, вы можете использовать встроенную функцию <code>len</code>:</p>
<pre class="code-pre "><code class="code-highlight language-go">sammy := map[string]string{"name": "Sammy", "animal": "shark", "color": "blue", "location": "ocean"}
fmt.Println(len(sammy))
</code></pre>
<p>В результатах будет показано количество элементов на вашей карте:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>4
</code></pre>
<p>Хотя в Go отсутствуют удобные функции получения ключей и значений, при необходимости их можно получить с помощью нескольких строчек кода.</p>

<h2 id="Проверка-существования">Проверка существования</h2>

<p>Если запрошенный ключ отсутствует, карты Go возвращают нулевое значение для типа значений карты. Поэтому вам нужен альтернативный способ отличить сохраненный ноль от отсутствующего ключа.</p>

<p>Поищем в карте заведомо несуществующее значение и посмотрим на результат:</p>
<pre class="code-pre "><code class="code-highlight language-go">counts := map[string]int{}
fmt.Println(counts["sammy"])
</code></pre>
<p>Вывод должен выглядеть так:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>0
</code></pre>
<p>Хотя ключ <code>sammy</code> отсутствует в карте, Go возвращает значение <code>0</code>. Это связано с тем, что используется тип данных значения <code>int</code>, и поскольку в Go задано нулевое значение всех переменных, возвращается нулевое значение <code>0</code>.</p>

<p>Во многих случаях такое поведение нежелательно и может вызвать ошибку в программе. При поиске значения на карте Go может вывести второе <em>опциональное</em> значение. Это второе значение является <code>булевым значением</code> <code>true</code> в случае обнаружения ключа или <code>false</code> в случае отсутствия ключа. В Go это называется идиомой <code>ok</code>. Хотя вы можете присвоить любое имя переменной, получающей второй аргумент, в Go всегда следует использовать имя <code>ok</code>:</p>
<pre class="code-pre "><code class="code-highlight language-go">count, ok := counts["sammy"]
</code></pre>
<p>Если ключ <code>sammy</code> существует в карте <code>counts</code>, <code>ok</code> будет иметь значение <code>true.</code> В противном случае <code>ok</code> будет иметь значение false.</p>

<p>Вы можете использовать переменную <code>ok</code> для определения действий в программе:</p>
<pre class="code-pre "><code class="code-highlight language-go">if ok {
    fmt.Printf("Sammy has a count of %d\n", count)
} else {
    fmt.Println("Sammy was not found")
}
</code></pre>
<p>Результат будет выглядеть следующим образом:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Sammy was not found
</code></pre>
<p>В Go вы можете комбинировать декларирование переменных и условную проверку с помощью блока if/else. Это позволяет использовать для такой проверки одно выражение:</p>
<pre class="code-pre "><code class="code-highlight language-go">if count, ok := counts["sammy"]; ok {
    fmt.Printf("Sammy has a count of %d\n", count)
} else {
    fmt.Println("Sammy was not found")
}
</code></pre>
<p>При получении значения из карты в Go всегда полезно проверить его существование, чтобы избежать ошибок в программе.</p>

<h2 id="Изменение-карт">Изменение карт</h2>

<p>Карты — это мутируемая структура данных, и вы можете изменять их. В этом разделе мы рассмотрим добавление и удаление элементов карт.</p>

<h3 id="Добавление-и-изменение-элементов-карт">Добавление и изменение элементов карт</h3>

<p>Вы можете добавлять на карты пары ключ-значение, не используя методы или функции. Для этого используется имя переменной карт, за которым идет значение ключа в квадратных скобках <code>[ ]</code> и оператор равенства <code>=</code> для определения нового значения:</p>
<pre class="code-pre "><code class="code-highlight language-go">map[<span class="highlight">key</span>] = <span class="highlight">value</span>
</code></pre>
<p>Покажем это на примере добавления пары ключ-значение в карту с именем <code>usernames</code>:</p>
<pre class="code-pre "><code class="code-highlight language-go">usernames := map[string]string{"Sammy": "sammy-shark", "Jamie": "mantisshrimp54"}

usernames["Drew"] = "squidly"
fmt.Println(usernames)
</code></pre>
<p>В результате на карте будет выведена новая пара ключ-значение <code>Drew:squidly</code>:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>map[Drew:squidly Jamie:mantisshrimp54 Sammy:sammy-shark]
</code></pre>
<p>Поскольку карты выводятся в неупорядоченном виде, эта пара может появиться в карте где угодно. Если вы используете карту <code>usernames</code> в следующих частях вашего файла программы, она будет содержать дополнительную пару ключ-значение.</p>

<p>Также этот синтаксис можно использовать для изменения значения, назначенного ключу. В этом случае вы ссылаетесь на существующий ключ и передаете ему новое значение.</p>

<p>Рассмотрим карту с именем <code>followers</code>, которая отслеживает подписчиков пользователей определенной сети. У пользователя <code>"drew"</code> сегодня выросло число подписчиков, и поэтому нужно обновить целочисленное значение, которое передается для ключа <code>"drew"</code>. Мы используем функцию <code>Println()</code> для проверки изменения карты:</p>
<pre class="code-pre "><code class="code-highlight language-go">followers := map[string]int{"drew": 305, "mary": 428, "cindy": 918}
followers["drew"] = 342
fmt.Println(followers)
</code></pre>
<p>В результатах будет показано обновленное значение <code>drew</code>:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>map[cindy:918 drew:342 mary:428]
</code></pre>
<p>Мы видим, что количество подписчиков увеличилось с целого числа <code>305</code> до <code>342</code>.</p>

<p>Вы можете использовать этот метод для добавления пар ключ-значение в карты с вводимыми пользователем данными. Напишем небольшую программу <code>usernames.go</code>, которая выполняется в командной строке и позволяет пользователю вводить дополнительные имена и связанные с ними имена пользователей:</p>
<div class="code-label " title="usernames.go">usernames.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import (
    "fmt"
    "strings"
)

func main() {
    usernames := map[string]string{"Sammy": "sammy-shark", "Jamie": "mantisshrimp54"}

    for {
        fmt.Println("Enter a name:")

        var name string
        _, err := fmt.Scanln(&amp;name)

        if err != nil {
            panic(err)
        }

        name = strings.TrimSpace(name)

        if u, ok := usernames[name]; ok {
            fmt.Printf("%q is the username of %q\n", u, name)
            continue
        }

        fmt.Printf("I don't have %v's username, what is it?\n", name)

        var username string
        _, err = fmt.Scanln(&amp;username)

        if err != nil {
            panic(err)
        }

        username = strings.TrimSpace(username)

        usernames[name] = username

        fmt.Println("Data updated.")
    }
}
</code></pre>
<p>Вначале мы определим в файле <code>usernames.go</code> первоначальную карту. Затем мы зададим цикл итерации имен. Мы предлагаем пользователю ввести имя и декларируем переменную для его сохранения. Затем мы проверяем наличие ошибок, и если они есть, в программе возникает <em>паника</em>, и она закрывается. Поскольку <code>Scanln</code> получает все вводимые данные, включая символ возврата каретки, нам нужно удалить из вводимых данных все пробелы. Для этого мы используем функцию <code>strings.TrimSpace</code>.</p>

<p>Блок <code>if</code> проверяет наличие имени на карте и выводит обратную связь. Если имя присутствует на карте, программа возвращается в начало цикла. Если имени нет на карте, пользователю направляется обратная связь и предлагается ввести новое имя пользователя для данного имени. Затем программа снова проверяет наличие ошибок. При отсутствии ошибок программа удаляет символ возврата каретки, назначает значение имени пользователя ключу name и выводит сообщение об обновлении данных.</p>

<p>Запустим эту программу в командной строке:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go run usernames.go
</li></ul></code></pre>
<p>Вывод должен выглядеть так:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Enter a name:
Sammy
"sammy-shark" is the username of "Sammy"
Enter a name:
Jesse
I don't have Jesse's username, what is it?
JOctopus
Data updated.
Enter a name:
</code></pre>
<p>После завершения тестирования нажмите <code>CTRL + C</code> для выхода из программы.</p>

<p>Это показывает возможность интерактивного изменения карт. В данной конкретной программе при выходе с помощью клавиш <code>CTRL + C</code> вы потеряете все данные, если не реализуете способ чтения и записи файлов.</p>

<p>Таким образом, мы можем добавлять элементы на карты или изменять их значения с помощью синтаксиса <code>map[key] = value</code>.</p>

<h3 id="Удаление-элементов-карт">Удаление элементов карт</h3>

<p>Мы можем не только добавлять пары ключ-значение и изменять значения типа данных карты, но и удалять элементы карт.</p>

<p>Чтобы удалить пару ключ-значение с карты, можно использовать встроенную функцию <code>delete()</code>. Первый аргумент — это карта, откуда мы удаляем элемент. Второй аргумент — это удаляемый ключ:</p>
<pre class="code-pre "><code class="code-highlight language-go">delete(map, key)
</code></pre>
<p>Определим карту разрешений:</p>
<pre class="code-pre "><code class="code-highlight language-go">permissions := map[int]string{1: "read", 2: "write", 4: "delete", 8: "create", 16:"modify"}
</code></pre>
<p>Нам больше не нужно разрешение <code>modify</code>, поэтому мы удалим его с нашей карты. Затем мы выведем карту, чтобы убедиться в его удалении:</p>
<pre class="code-pre "><code class="code-highlight language-go">permissions := map[int]string{1: "read", 2: "write", 4: "delete", 8: "create", 16: "modify"}
delete(permissions, 16)
fmt.Println(permissions)
</code></pre>
<p>Результат подтвердит удаление:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>map[1:read 2:write 4:delete 8:create]
</code></pre>
<p>Строка <code>delete(permissions, 16)</code> удаляет пару ключ-значение <code>16:"modify"</code> из карты <code>permissions</code>.</p>

<p>Если вы хотите очистить карту от всех значений, вы можете задать ее равной пустой карте того же типа. При этом будет создана новая пустая карта, а сборщик мусора очистит память от старой карты.</p>

<p>Удалим все элементы из карты <code>permissions</code>:</p>
<pre class="code-pre "><code class="code-highlight language-go">permissions = map[int]string{}
fmt.Println(permissions)
</code></pre>
<p>Результаты показывают, что мы получили пустую карту без пар ключ-значение:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>map[]
</code></pre>
<p>Поскольку карты имеют мутируемый тип данных, они поддерживают добавление, изменение, удаление и очистку элементов.</p>

<h2 id="Заключение">Заключение</h2>

<p>В этом материале мы рассказали о структуре карт в Go. Карты состоят из пар ключ-значение и предоставляют возможность хранения данных без использования индексов. Это позволяет получать значения на основе их смысла и связи с другими типами данных.</p>
