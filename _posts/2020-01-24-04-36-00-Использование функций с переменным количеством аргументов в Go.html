---
layout: post
title: Использование функций с переменным количеством аргументов в Go
network: digitalocean
date: January 24, 2020 at 04:36AM
url: https://www.digitalocean.com/community/tutorials/how-to-use-variadic-functions-in-go-ru
image: http://ifttt.com/images/no_image_card.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="Введение">Введение</h3>

<p><em>Функция с переменным количеством аргументов</em> — это функция, которая принимает ноль, одно или больше значений в качестве одного аргумента. Хотя функции с переменным количеством аргументов встречаются редко, их можно использовать, чтобы сделать код более чистым и удобным для чтения.</p>

<p>Функции с переменным количеством аргументов встречаются чаще, чем кажется. Наиболее распространенная из них — функция <code>Println</code> из пакета <a href="https://golang.org/pkg/fmt"><code>fmt</code></a>.</p>
<pre class="code-pre "><code class="code-highlight language-go">func Println(a ...interface{}) (n int, err error)
</code></pre>
<p><a href="https://www.digitalocean.com/community/tutorials/how-to-define-and-call-functions-in-go">Функция</a> с параметром, которому предшествует набор многоточий (<code>...</code>), считается функцией с переменным количеством аргументов. Многоточие означает, что предоставляемый параметр может иметь ноль, одно или несколько значений. Для пакета <code>fmt.Println</code> это указывает, что параметр <code>a</code> является параметром с переменным количеством аргументов.</p>

<p>Создадим программу, которая использует функцию <code>fmt.Println</code> и передает ноль, одно или несколько значений:</p>
<div class="code-label " title="print.go">print.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

func main() {
    fmt.Println()
    fmt.Println("one")
    fmt.Println("one", "two")
    fmt.Println("one", "two", "three")
}
</code></pre>
<p>При первом вызове <code>fmt.Println</code> мы не передаем никаких аргументов. При втором вызове <code>fmt.Println</code> мы передаем только один аргументо со значением <code>one</code>. Затем мы передаем значения <code>one</code> и <code>two</code>, и в заключение <code>one</code>, <code>two</code> и <code>three</code>.</p>

<p>Запустим программу с помощью следующей команды:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go run print.go
</li></ul></code></pre>
<p>Результат должен выглядеть так:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>
one
one two
one two three
</code></pre>
<p>Первая выводимая строка будет пустой. Это связано с тем, что мы не передали никаких аргументов при первом вызове <code>fmt.Println</code>. При втором вызове будет выведено значение <code>one</code>. Затем будут выведены значения <code>one</code> и <code>two</code>, а в заключение — <code>one</code>, <code>two</code> и <code>three</code>.</p>

<p>Мы показали, как вызывать функцию с переменным количеством аргументов, а теперь посмотрим, как можно определить собственную функцию с переменным количеством аргументов.</p>

<h2 id="Определение-функции-с-переменным-количеством-аргументов">Определение функции с переменным количеством аргументов</h2>

<p>Для определения функции с переменным количеством аргументов мы используем символ многоточия (<code>...</code>) перед аргументом. Создадим программу, которая будет приветствовать людей при отправке их имен в функцию:</p>
<div class="code-label " title="hello.go">hello.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

func main() {
    sayHello()
    sayHello("Sammy")
    sayHello("Sammy", "Jessica", "Drew", "Jamie")
}

func sayHello(names ...string) {
    for _, n := range names {
        fmt.Printf("Hello %s\n", n)
    }
}
</code></pre>
<p>Мы создали функцию <code>sayHello</code>, которая принимает только один параметр с именем <code>names</code>. Это параметр с переменным количеством аргументов, поскольку мы поставили многоточие (<code>...</code>) перед типом данных: <code>...string</code>. Это указывает Go, что функция может принимать ноль, один или много аргументов.</p>

<p>Функция <code>sayHello</code> получает параметр <code>names</code> в качестве <a href="https://www.digitalocean.com/community/tutorials/understanding-arrays-and-slices-in-go#slices"><code>среза</code></a>. Поскольку используется тип данных <a href="https://www.digitalocean.com/community/tutorials/understanding-data-types-in-go#strings"><code>string</code></a>, параметр <code>names</code> можно рассматривать как срез строк (<code>[]string</code>) в теле функции. Мы можем создать цикл с оператором <a href="https://www.digitalocean.com/community/tutorials/how-to-construct-for-loops-in-go#looping-through-sequential-data-types-with-rangeclause"><code>range</code></a> и выполнять итерацию в слайсе строк.</p>

<p>Если мы запустим программу, результат будет выглядеть так:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Hello Sammy
Hello Sammy
Hello Jessica
Hello Drew
Hello Jamie
</code></pre>
<p>Обратите внимание, что при первом вызове <code>sayHello</code> ничего не выводится. Это связано с тем, что значением параметра с переменным количеством аргументов были пустой <code>срез</code> или пустая <code>строка</code>. Поскольку мы выполняем цикл в срезе, объектов для итерации нет, и функция <code>fmt.Printf</code> не вызывается.</p>

<p>Изменим программу так, чтобы она определяла, что никакие значения в нее не отправляются:</p>
<div class="code-label " title="hello.go">hello.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

func main() {
    sayHello()
    sayHello("Sammy")
    sayHello("Sammy", "Jessica", "Drew", "Jamie")
}

func sayHello(names ...string) {
    if len(names) == 0 {
        fmt.Println("nobody to greet")
        return
    }
    for _, n := range names {
        fmt.Printf("Hello %s\n", n)
    }
}
</code></pre>
<p>Теперь, если при использовании <a href="https://www.digitalocean.com/community/tutorials/how-to-write-conditional-statements-in-go#if-statements">выражения <code>if</code></a> не передаются никакие значения, длина <code>names</code> будет равна <code>0</code>, и мы <code>не будем приветствовать никого</code>:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>nobody to greet
Hello Sammy
Hello Sammy
Hello Jessica
Hello Drew
Hello Jamie
</code></pre>
<p>Использование параметра с переменным количеством аргументов делает код удобнее для чтения. Создадим функцию, объединяющую слова с заданным разделителем. Вначале мы создадим эту программу без функции с переменным количеством аргументов, чтобы показать, как будет проводиться чтение:</p>
<div class="code-label " title="join.go">join.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

func main() {
    var line string

    line = join(",", []string{"Sammy", "Jessica", "Drew", "Jamie"})
    fmt.Println(line)

    line = join(",", []string{"Sammy", "Jessica"})
    fmt.Println(line)

    line = join(",", []string{"Sammy"})
    fmt.Println(line)
}

func join(del string, values []string) string {
    var line string
    for i, v := range values {
        line = line + v
        if i != len(values)-1 {
            line = line + del
        }
    }
    return line
}
</code></pre>
<p>В этой программе мы передаем запятую (<code>,</code>) в качестве разделителя для функции <code>join</code>. В этом случае мы передаем срез значений для объединения. Результат будет выглядеть так:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Sammy,Jessica,Drew,Jamie
Sammy,Jessica
Sammy
</code></pre>
<p>Поскольку функция принимает срез строки в качестве параметра <code>values</code>, нам нужно было заключать все слова в срез при вызове функции <code>join</code>. Это усложняет чтение кода.</p>

<p>Теперь напишем ту же функцию, но как функцию с переменным количеством аргументов:</p>
<div class="code-label " title="join.go">join.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

func main() {
    var line string

    line = join(",", "Sammy", "Jessica", "Drew", "Jamie")
    fmt.Println(line)

    line = join(",", "Sammy", "Jessica")
    fmt.Println(line)

    line = join(",", "Sammy")
    fmt.Println(line)
}

func join(del string, values ...string) string {
    var line string
    for i, v := range values {
        line = line + v
        if i != len(values)-1 {
            line = line + del
        }
    }
    return line
}
</code></pre>
<p>Если мы запустим эту программу, результат будет выглядеть как предыдущая программа:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Sammy,Jessica,Drew,Jamie
Sammy,Jessica
Sammy
</code></pre>
<p>Хотя обе версии функции <code>join</code> выполняют одно и то же с программной точки зрения, версия функции с переменным количеством аргументов намного проще читается при вызове.</p>

<h2 id="Порядок-при-переменном-количестве-аргументов">Порядок при переменном количестве аргументов</h2>

<p>В функции может быть только один параметр с переменным количеством аргументов, и это должен быть последний определяемый в функции параметр. Определение параметров в функции с переменным количеством аргументов в любом другом порядке вызовет ошибку при компиляции:</p>
<div class="code-label " title="join.go">join.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

func main() {
    var line string

    line = join(",", "Sammy", "Jessica", "Drew", "Jamie")
    fmt.Println(line)

    line = join(",", "Sammy", "Jessica")
    fmt.Println(line)

    line = join(",", "Sammy")
    fmt.Println(line)
}

func join(values ...string, del string) string {
    var line string
    for i, v := range values {
        line = line + v
        if i != len(values)-1 {
            line = line + del
        }
    }
    return line
}
</code></pre>
<p>В этот раз мы поместим параметр <code>values</code> первым в функции <code>join</code>. В результате возникнет следующая ошибка компиляции:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>./join_error.go:18:11: syntax error: cannot use ... with non-final parameter values
</code></pre>
<p>При определении любой функции с переменным количеством аргументов только последний параметр может иметь переменное количество аргументов.</p>

<h2 id="Раскрывающиеся-аргументы">Раскрывающиеся аргументы</h2>

<p>Мы показали, что в функцию с переменным количеством аргументов можно передать ноль, одно или несколько значений. Однако бывает и так, что нам нужно отправить в функцию с переменным количеством аргументов целый срез значений.</p>

<p>Возьмем функцию <code>join</code> из последнего раздела и посмотрим, что получится:</p>
<div class="code-label " title="join.go">join.go</div><pre class="code-pre "><code langs="">package main

import "fmt"

func main() {
    var line string

    <span class="highlight">names := []string{"Sammy", "Jessica", "Drew", "Jamie"}</span>

    line = join(",", <span class="highlight">names</span>)
    fmt.Println(line)
}

func join(del string, values ...string) string {
    var line string
    for i, v := range values {
        line = line + v
        if i != len(values)-1 {
            line = line + del
        }
    }
    return line
}
</code></pre>
<p>Если мы запустим эту программу, то получим ошибку компиляции:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>./join-error.go:10:14: cannot use names (type []string) as type string in argument to join
</code></pre>
<p>Хотя функция с переменным количеством аргументов конвертирует параметр <code>values ...string</code> в срез строк <code>[]string</code>, мы не можем передать срез строк в качестве аргумента. Это связано с тем, что компилятор ожидает получить дискретные аргументы строк.</p>

<p>Чтобы обойти эту сложность, мы можем <em>раскрыть</em> срез, добавив в него суффикс многоточия (<code>...</code>) и превратив его в дискретные аргументы, которые будут передаваться в функцию с переменным количеством аргументов:</p>
<div class="code-label " title="join.go">join.go</div><pre class="code-pre "><code langs="">package main

import "fmt"

func main() {
    var line string

    names := []string{"Sammy", "Jessica", "Drew", "Jamie"}

    line = join(",", <span class="highlight">names...</span>)
    fmt.Println(line)
}

func join(del string, values ...string) string {
    var line string
    for i, v := range values {
        line = line + v
        if i != len(values)-1 {
            line = line + del
        }
    }
    return line
}
</code></pre>
<p>Теперь при вызове функции <code>join</code> мы раскрываем срез <code>names</code> посредством добавления многоточия (<code>...</code>).</p>

<p>Так программа работает ожидаемым образом:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Sammy,Jessica,Drew,Jamie
</code></pre>
<p>Важно отметить, что мы можем передать ноль, один или несколько аргументов в дополнение к срезу, который мы раскрываем. Вот так будет выглядеть код, передающий все варианты, которые мы видели до этого:</p>
<div class="code-label " title="join.go">join.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

func main() {
    var line string

    line = join(",", []string{"Sammy", "Jessica", "Drew", "Jamie"}<span class="highlight">...</span>)
    fmt.Println(line)

    line = join(",", "Sammy", "Jessica", "Drew", "Jamie")
    fmt.Println(line)

    line = join(",", "Sammy", "Jessica")
    fmt.Println(line)

    line = join(",", "Sammy")
    fmt.Println(line)

}

func join(del string, values ...string) string {
    var line string
    for i, v := range values {
        line = line + v
        if i != len(values)-1 {
            line = line + del
        }
    }
    return line
}
</code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Sammy,Jessica,Drew,Jamie
Sammy,Jessica,Drew,Jamie
Sammy,Jessica
Sammy
</code></pre>
<p>Теперь мы знаем, как передавать в функцию с переменным количеством аргументов ноль, один или несколько аргументов, а также раскрываемый срез.</p>

<h2 id="Заключение">Заключение</h2>

<p>В этой статье мы показали, как можно использовать функции с переменным количеством аргументов, чтобы сделать код более удобочитаемым. Хотя и требуются не всегда, но они могут оказаться для вас полезными:</p>

<ul>
<li>Если вы создаете временный срез, только чтобы передать его функции.</li>
<li>Если количество входных параметров неизвестно или может меняться при вызове.</li>
<li>Если вы хотите сделать код более удобочитаемым.</li>
</ul>

<p>Чтобы узнать больше о создании и вызове функций, вы можете прочитать материал <a href="https://www.digitalocean.com/community/tutorials/how-to-define-and-call-functions-in-go">Определение и вызов функций в Go</a>.</p>
