---
layout: post
title: Выражения defer в Go
network: digitalocean
date: January 24, 2020 at 04:41AM
url: https://www.digitalocean.com/community/tutorials/understanding-defer-in-go-ru
image: http://ifttt.com/images/no_image_card.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="Введение">Введение</h3>

<p>В Go используется много общих управляющих ключевых слов, которые используются и в других языках программирования. В число этих ключевых слов входят <code>if</code>, <code>switch</code>, <code>for</code> и т. д. Однако некоторые ключевые слова отсутствуют в большинстве языков программирования. Одно из них — ключевое слово <code>defer</code>, и хотя оно используется нечасто, вы быстро поймете, насколько полезно оно может быть для ваших программ.</p>

<p>Одно из основных назначений выражения <code>defer</code> заключается в очистке ресурсов, в том числе открытых файлов, сетевых подключений и <a href="https://en.wikipedia.org/wiki/Handle_(computing)">инициализаций в базе данных</a>. Когда ваша программа закончит использовать эти ресурсы, их важно закрыть, чтобы не доводить программу до предела и дать другим программам доступ к этим ресурсам. Выражение <code>defer</code> делает код чище и снижает вероятность ошибок за счет хранения вызовов закрытия файла или ресурса вблизи к вызовам открытия.</p>

<p>В этой статье мы расскажем о том, как правильно использовать выражение <code>defer</code> для очистки ресурсов, а также о некоторых распространенных ошибках, которые встречаются при использовании <code>defer</code>.</p>

<h2 id="Что-представляет-собой-выражение-defer">Что представляет собой выражение <code>defer</code></h2>

<p>Выражение <code>defer</code> добавляет вызов <a href="https://www.digitalocean.com/community/tutorials/how-to-define-and-call-functions-in-go">функции</a> после ключевого слова <code>defer</code> в стеке приложения. Все вызовы в стеке вызываются при возврате функции, в которой они добавлены. Поскольку вызовы помещаются в стек, они производятся в порядке от последнего к первому.</p>

<p>Посмотрим, как <code>выражение</code> defer работает при выводе текста:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

func main() {
    defer fmt.Println("Bye")
    fmt.Println("Hi")
}
</code></pre>
<p>В функции <code>main</code> два выражения. Первое выражение начинается с ключевого слова <code>defer</code>, за которым идет выражение <code>print</code>, которое выводит текст <code>Bye</code>. Следующая строчка выводит текст <code>Hi</code>.</p>

<p>Если мы запустим программу, результат будет выглядеть так:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Hi
Bye
</code></pre>
<p>Обратите внимание, что в первую очередь было выведено слово <code>Hi</code>. Это связано с тем, что любое выражение, перед которым идет ключевое слово <code>defer</code>, не вызывается до конца функции, где использовалось ключевое слово <code>defer</code>.</p>

<p>Давайте посмотрим на программу еще раз и добавим несколько комментариев, которые помогут проиллюстрировать ситуацию:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

func main() {
    // defer statement is executed, and places
    // fmt.Println("Bye") on a list to be executed prior to the function returning
    defer fmt.Println("Bye")

    // The next line is executed immediately
    fmt.Println("Hi")

    // fmt.Println*("Bye") is now invoked, as we are at the end of the function scope
}
</code></pre>
<p>Для понимания ключевого слова <code>defer</code> важно знать, что при выполнении выражения <code>defer</code> аргументы отложенной функции оцениваются немедленно. При выполнении <code>defer</code> идущее после него в списке выражение вызывается до возврата функции.</p>

<p>Хотя этот код иллюстрирует порядок запуска <code>defer</code>, это не совсем обычный способ, который использовался бы при написании программы Go. Более вероятно использование <code>defer</code> для очистки ресурса, например дескриптора файла. Далее мы покажем, как это сделать.</p>

<h2 id="Использование-defer-для-очистки-ресурсов">Использование <code>defer</code> для очистки ресурсов</h2>

<p>Использование <code>defer</code> для очистки ресурсов часто применяется в Go. Вначале рассмотрим программу, которая записывает строку в файл, но не использует <code>defer</code> для очистки ресурсов:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import (
    "io"
    "log"
    "os"
)

func main() {
    if err := write("readme.txt", "This is a readme file"); err != nil {
        log.Fatal("failed to write file:", err)
    }
}

func write(fileName string, text string) error {
    file, err := os.Create(fileName)
    if err != nil {
        return err
    }
    _, err = io.WriteString(file, text)
    if err != nil {
        return err
    }
    file.Close()
    return nil
}
</code></pre>
<p>В этой программе имеется функция <code>write</code>, которая вначале пытается создать файл. При возникновении ошибки функция выводит сообщение об ошибке и закрывается. Затем она пытается записать строку <code>This is a readme file</code> в указанный файл. При возникновении ошибки функция выводит сообщение об ошибке и закрывается. Затем функция пытается закрыть файл и вернуть ресурс в систему. В заключение функция возвращает значение <code>nil</code>, подтверждая выполнение функции без ошибки.</p>

<p>Хотя этот код работает, в нем есть небольшая ошибка. Если вызов <code>io.WriteString</code> не обрабатывается надлежащим образом, функция прекращает работу без закрытия файла и возврата ресурса в систему.</p>

<p>Эту проблему можно решить, добавив еще одно выражение <code>file.Close()</code>, которое позволит решить проблему без использования <code>defer</code>:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre plain"><code langs="">package main

import (
    "io"
    "log"
    "os"
)

func main() {
    if err := write("readme.txt", "This is a readme file"); err != nil {
        log.Fatal("failed to write file:", err)
    }
}

func write(fileName string, text string) error {
    file, err := os.Create(fileName)
    if err != nil {
        return err
    }
    _, err = io.WriteString(file, text)
    if err != nil {
        <span class="highlight">file.Close()</span>
        return err
    }
    file.Close()
    return nil
}
</code></pre>
<p>Теперь программа закроет файл, даже если вызов <code>io.WriteString</code> не будет обработан надлежащим образом. Хотя эту ошибку было относительно легко найти и исправить, в более сложной функции ее можно было и пропустить.</p>

<p>Вместо добавления второго вызова <code>file.Close()</code> мы можем использовать выражение <code>defer</code>, чтобы вызывать <code>Close()</code> вне зависимости от хода выполнения функции.</p>

<p>Вот версия, использующая ключевое слово <code>defer</code>:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre plain"><code langs="">package main

import (
    "io"
    "log"
    "os"
)

func main() {
    if err := write("readme.txt", "This is a readme file"); err != nil {
        log.Fatal("failed to write file:", err)
    }
}

func write(fileName string, text string) error {
    file, err := os.Create(fileName)
    if err != nil {
        return err
    }
    <span class="highlight">defer file.Close()</span>
    _, err = io.WriteString(file, text)
    if err != nil {
        return err
    }
    return nil
}
</code></pre>
<p>В этот раз мы добавили строчку кода: <code>defer file.Close()</code>. Это указывает компилятору, что функцию <code>file.Close</code> нужно выполнить перед выходом из функции <code>write</code>.</p>

<p>Теперь программа всегда будет очищать ресурсы и закрывать файл, даже если мы добавим дополнительный код и создадим другое ответвление кода с выходом из функции.</p>

<p>Однако, добавив defer, мы внесли в код  еще одну ошибку. Мы больше не проверяем ошибки, которые может возвратить метод <code>Close</code>. Это связано с тем, что при использовании <code>defer</code> нет способа передать в функцию какое-либо возвращаемое значение.</p>

<p>В Go считается безопасным и приемлемым вызывать функцию <code>Close()</code> несколько раз, и это не повлияет на поведение программы. Если <code>Close()</code> возвратит ошибку, это произойдет при первом вызове. Это позволит нам явно вызвать эту команду на успешном пути выполнения нашей функции.</p>

<p>Теперь посмотрим, как мы можем <code>отложить</code> вызов <code>Close</code> и при этом сообщить об ошибке, если она возникнет.</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre plain"><code langs="">package main

import (
    "io"
    "log"
    "os"
)

func main() {
    if err := write("readme.txt", "This is a readme file"); err != nil {
        log.Fatal("failed to write file:", err)
    }
}

func write(fileName string, text string) error {
    file, err := os.Create(fileName)
    if err != nil {
        return err
    }
    defer file.Close()
    _, err = io.WriteString(file, text)
    if err != nil {
        return err
    }

    return <span class="highlight">file.Close()</span>
}
</code></pre>
<p>Единственное изменение этой программы мы внесли в последнюю строку, где мы возвращаем <code>file.Close()</code>. Если при вызове <code>Close</code> возникает ошибка, она будет возвращена вызывающей функции, как и ожидается. Необходимо помнить, что выражение <code>defer file.Close()</code> также будет выполняться после выражения <code>return</code>. Это означает, что функция <code>file.Close()</code> может быть вызвана дважды. Хотя это не идеально, эта практика является допустимой, поскольку она не создаст никаких побочных эффектов для вашей программы.</p>

<p>Если ошибка возникнет раньше, например при вызове <code>WriteString</code>, функция выведет сообщение об ошибке и попытается вызвать <code>file.Close</code>, поскольку это отложенная команда. Хотя <code>file.Close</code> может также возвратить ошибку, и скорее всего это произойдет, нам больше не нужно беспокоиться о причинах, поскольку сообщение об ошибке укажет на них.</p>

<p>Мы посмотрели, как использовать одно выражение <code>defer</code> для правильной очистки ресурсов. Далее мы посмотрим, как использовать несколько выражений <code>defer</code> для очистки нескольких ресурсов.</p>

<h2 id="Использование-нескольких-выражений-defer">Использование нескольких выражений <code>defer</code></h2>

<p>Функция может содержать несколько выражений <code>defer</code>. Создадим программу, которая будет содержать только выражения <code>defer</code>, и посмотрим, что произойдет при использовании нескольких выражений defer:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

func main() {
    defer fmt.Println("one")
    defer fmt.Println("two")
    defer fmt.Println("three")
}
</code></pre>
<p>Если мы запустим программу, результат будет выглядеть следующим образом:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>three
two
one
</code></pre>
<p>Обратите внимание, что порядок выполнения противоположен порядку вызова выражений <code>defer</code>. Это связано с тем, что каждое выражение defer помещается в стек поверх предыдущего и вызывается функцией в обратном порядке (<em>Last In, First Out</em>).</p>

<p>Вы можете использовать в функции любое количество выражений defer, но важно помнить, что они вызываются в порядке, обратном порядку их выполнения.</p>

<p>Теперь мы понимаем порядок выполнения нескольких выражений defer и можем посмотреть, как использовать несколько выражений defer для очистки нескольких ресурсов. Мы создадим программу, которая открывает файл, выполняет в него запись и снова открывает его для копирования содержимого в другой файл.</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import (
    "fmt"
    "io"
    "log"
    "os"
)

func main() {
    if err := write("sample.txt", "This file contains some sample text."); err != nil {
        log.Fatal("failed to create file")
    }

    if err := fileCopy("sample.txt", "sample-copy.txt"); err != nil {
        log.Fatal("failed to copy file: %s")
    }
}

func write(fileName string, text string) error {
    file, err := os.Create(fileName)
    if err != nil {
        return err
    }
    defer file.Close()
    _, err = io.WriteString(file, text)
    if err != nil {
        return err
    }

    return file.Close()
}

func fileCopy(source string, destination string) error {
    src, err := os.Open(source)
    if err != nil {
        return err
    }
    defer src.Close()

    dst, err := os.Create(destination)
    if err != nil {
        return err
    }
    defer dst.Close()

    n, err := io.Copy(dst, src)
    if err != nil {
        return err
    }
    fmt.Printf("Copied %d bytes from %s to %s\n", n, source, destination)

    if err := src.Close(); err != nil {
        return err
    }

    return dst.Close()
}
</code></pre>
<p>Мы добавили новую функцию с именем <code>fileCopy</code>. В этой функции мы вначале откроем исходный файл, откуда будем производить копирование. Проверим наличие ошибки при открытии файла. Если есть ошибка, мы <code>возвращаем</code> ее и выходим из функции. В противном случае мы используем <code>defer</code> для закрытия исходного файла, который мы только что открыли.</p>

<p>Затем мы создаем файл назначения. После этого мы снова проверяем наличие ошибки при создании файла. Если она есть, мы <code>возвращаем</code> эту ошибку и выходим из функции. В противном случае мы также используем <code>defer</code> для функции <code>Close()</code> для закрытия файла. Теперь у нас имеется два выражения <code>defer</code>, которые должны вызываться при выходе из функции в ее области действия.</p>

<p>Теперь у нас открыты оба файла и мы выполним копирование данных с помощью функции <code>Copy()</code> из файла источника в файл назначения. Если копирование будет выполнено успешно, программа попытается закрыть оба файла. Если мы получим сообщение об ошибке при попытке закрытия любого из файлов, мы <code>возвратим</code> эту ошибку и выйдем из области функции.</p>

<p>Обратите внимание, что мы явно вызываем <code>Close()</code> для каждого файла, хотя <code>defer</code> также вызывает <code>Close()</code>. Это обеспечивает вывод сообщения об ошибке, если при закрытии файла возникнет ошибка. Если по любой причине функция закроется с ошибкой, например, при ошибке копирования между двумя файлами, каждый файл попытается правильно выполнить закрытие из отложенных вызовов.</p>

<h2 id="Заключение">Заключение</h2>

<p>В этой статье мы узнали о выражении <code>defer</code> и его использовании для правильной очистки системных ресурсов нашей программы. При правильной очистке ресурсов программа будет потреблять меньше памяти и работать более эффективно. Дополнительную информацию об использовании выражения <code>defer</code> можно найти в статье, посвященной обработке паники, и в <a href="https://www.digitalocean.com/community/tutorial_series/how-to-code-in-go">других статьях нашей серии по программированию на Go</a>.</p>
