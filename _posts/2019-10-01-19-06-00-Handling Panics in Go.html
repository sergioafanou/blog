---
layout: post
title: Handling Panics in Go
network: digitalocean
date: October 01, 2019 at 07:06PM
url: https://www.digitalocean.com/community/tutorials/handling-panics-in-go
image: http://ifttt.com/images/no_image_card.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="introduction">Introduction</h3>

<p>Errors that a program encounters fall into two broad categories: those the programmer has anticipated and those the programmer has not. The <code>error</code> interface that we have covered in our previous two articles on <a href="https://www.digitalocean.com/community/tutorials/handling-errors-in-go">error handling</a> largely deal with errors that we expect as we are writing Go programs. The <code>error</code> interface even allows us to acknowledge the rare possibility of an error occurring from function calls, so we can respond appropriately in those situations.</p>

<p>Panics fall into the second category of errors, which are unanticipated by the programmer. These unforeseen errors lead a program to spontaneously terminate and exit the running Go program. Common mistakes are often responsible for creating panics. In this tutorial, we&rsquo;ll examine a few ways that common operations can produce panics in Go, and we&rsquo;ll also see ways to avoid those panics. We&rsquo;ll also use <a href="https://www.digitalocean.com/community/tutorials/understanding-defer-in-go"><code>defer</code></a> statements along with the <code>recover</code> function to capture panics before they have a chance to unexpectedly terminate our running Go programs.</p>

<h2 id="understanding-panics">Understanding Panics</h2>

<p>There are certain operations in Go that automatically return panics and stop the program. Common operations include indexing an <a href="https://www.digitalocean.com/community/tutorials/understanding-arrays-and-slices-in-go#arrays">array</a> beyond its capacity, performing type assertions, calling methods on nil pointers, incorrectly using mutexes, and attempting to work with closed channels. Most of these situations result from mistakes made while programming that the compiler has no ability to detect while compiling your program.</p>

<p>Since panics include detail that is useful for resolving an issue, developers commonly use panics as an indication that they have made a mistake during a program&rsquo;s development.</p>

<h3 id="out-of-bounds-panics">Out of Bounds Panics</h3>

<p>When you attempt to access an index beyond the length of a slice or the capacity of an array, the Go runtime will generate a panic.</p>

<p>The following example makes the common mistake of attempting to access the last element of a slice using the length of the slice returned by the <code>len</code> builtin. Try running this code to see why this might produce a panic:</p>
<pre class="code-pre "><code class="code-highlight language-go">package main

import (
    "fmt"
)

func main() {
    names := []string{
        "lobster",
        "sea urchin",
        "sea cucumber",
    }
    fmt.Println("My favorite sea creature is:", names[len(names)])
}
</code></pre>
<p>This will have the following output:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>panic: runtime error: index out of range [3] with length 3

goroutine 1 [running]:
main.main()
    /tmp/sandbox879828148/prog.go:13 +0x20
</code></pre>
<p>The name of the panic&rsquo;s output provides a hint: <code>panic: runtime error: index out of range</code>. We created a slice with three sea creatures. We then tried to get the last element of the slice by indexing that slice with the length of the slice using the <code>len</code> builtin function. Remember that slices and arrays are zero-based; so the first element is zero and the last element in this slice is at index <code>2</code>. Since we try to access the slice at the third index, <code>3</code>, there is no element in the slice to return because it is beyond the bounds of the slice. The runtime has no option but to terminate and exit since we have asked it to do something impossible. Go also can&rsquo;t prove during compilation that this code will try to do this, so the compiler cannot catch this.</p>

<p>Notice also that the subsequent code did not run. This is because a panic is an event that completely halts the execution of your Go program. The message produced contains multiple pieces of information helpful for diagnosing the cause of the panic.</p>

<h2 id="anatomy-of-a-panic">Anatomy of a Panic</h2>

<p>Panics are composed of a message indicating the cause of the panic and a <a href="https://en.wikipedia.org/wiki/Stack_trace">stack trace</a> that helps you locate where in your code the panic was produced.</p>

<p>The first part of any panic is the message. It will always begin with the string <code>panic:</code>, which will be followed with a string that varies depending on the cause of the panic. The panic from the previous exercise has the message:</p>
<pre class="code-pre "><code langs="">panic: runtime error: index out of range [3] with length 3
</code></pre>
<p>The string <code>runtime error:</code> following the <code>panic:</code> prefix tells us that the panic was generated by the language runtime. This panic is telling us that we attempted to use an index <code>[3]</code> that was out of range of the slice&rsquo;s length <code>3</code>.</p>

<p>Following this message is the stack trace. Stack traces form a map that we can follow to locate exactly what line of code was executing when the panic was generated, and how that code was invoked by earlier code.</p>
<pre class="code-pre "><code langs="">goroutine 1 [running]:
main.main()
    /tmp/sandbox879828148/prog.go:13 +0x20
</code></pre>
<p>This stack trace, from the previous example, shows that our program generated the panic from the file <code>/tmp/sandbox879828148/prog.go</code> at line number 13. It also tells us that this panic was generated in the <code>main()</code> function from the <code>main</code> package.</p>

<p>The stack trace is broken into separate blocks—one for each <a href="https://tour.golang.org/concurrency/1">goroutine</a> in your program. Every Go program&rsquo;s execution is accomplished by one or more goroutines that can each independently and simultaneously execute parts of your Go code. Each block begins with the header <code>goroutine X [state]:</code>. The header gives the ID number of the goroutine along with the state that it was in when the panic occurred. After the header, the stack trace shows the function that the program was executing when the panic happened, along with the filename and line number where the function executed.</p>

<p>The panic in the previous example was generated by an out-of-bounds access to a slice. Panics can also be generated when methods are called on pointers that are unset.</p>

<h2 id="nil-receivers">Nil Receivers</h2>

<p>The Go programming language has pointers to refer to a specific instance of some type existing in the computer&rsquo;s memory at runtime. Pointers can assume the value <code>nil</code> indicating that they are not pointing at anything. When we attempt to call methods on a pointer that is <code>nil</code>, the Go runtime will generate a panic. Similarly, variables that are interface types will also produce panics when methods are called on them. To see the panics generated in these cases, try the following example:</p>
<pre class="code-pre "><code class="code-highlight language-go">package main

import (
    "fmt"
)

type Shark struct {
    Name string
}

func (s *Shark) SayHello() {
    fmt.Println("Hi! My name is", s.Name)
}

func main() {
    s := &amp;Shark{"Sammy"}
    s = nil
    s.SayHello()
}
</code></pre>
<p>The panics produced will look like this:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0xffffffff addr=0x0 pc=0xdfeba]

goroutine 1 [running]:
main.(*Shark).SayHello(...)
    /tmp/sandbox160713813/prog.go:12
main.main()
    /tmp/sandbox160713813/prog.go:18 +0x1a
</code></pre>
<p>In this example, we defined a struct called <code>Shark</code>. <code>Shark</code> has one method defined on its pointer receiver called <code>SayHello</code> that will print a greeting to standard out when called. Within the body of our <code>main</code> function, we create a new instance of this <code>Shark</code> struct and request a pointer to it using the <code>&amp;</code> operator. This pointer is assigned to the <code>s</code> variable. We then reassign the <code>s</code> variable to the value <code>nil</code> with the statement <code>s = nil</code>. Finally we attempt to call the <code>SayHello</code> method on the variable <code>s</code>. Instead of receiving a friendly message from Sammy, we receive a panic that we have attempted to access an invalid memory address—this is because we set the <code>s</code> variable to <code>nil</code>.</p>

<p>While we have set <code>s</code> to <code>nil</code> explicitly in this example, in practice this happens less obviously. When you see panics involving <code>nil pointer dereference</code>, be sure that you have properly assigned any pointer variables that you may have created.</p>

<p>Panics generated from nil pointers and out-of-bounds accesses are two commonly occurring panics generated by the runtime. It is also possible to manually generate a panic using a builtin function.</p>

<h2 id="using-the-panic-builtin-function">Using the <code>panic</code> Builtin Function</h2>

<p>We can also generate panics of our own using the <code>panic</code> built-in function. It takes a single string as an argument, which is the message the panic will produce. Typically this message is less verbose than rewriting our code to return an error. Furthermore, we can use this within our own packages to indicate to developers that they may have made a mistake when using our package&rsquo;s code. Whenever possible, best practice is to try to return <code>error</code> values to consumers of our package.</p>

<p>Run this code to see a panic generated from a function called from another function:</p>
<pre class="code-pre "><code class="code-highlight language-go">package main

func main() {
    foo()
}

func foo() {
    panic("oh no!")
}
</code></pre>
<p>The panic output produced looks like:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>panic: oh no!

goroutine 1 [running]:
main.foo(...)
    /tmp/sandbox494710869/prog.go:8
main.main()
    /tmp/sandbox494710869/prog.go:4 +0x40
</code></pre>
<p>Here we define a function <code>foo</code> that calls the <code>panic</code> builtin with the string <code>"oh no!"</code>. This function is called by our <code>main</code> function. Notice how the output has the message <code>panic: oh no!</code> and the stack trace shows a single goroutine with two lines in the stack trace: one for the <code>main()</code> function and one for our <code>foo()</code> function.</p>

<p>We&rsquo;ve seen that panics appear to terminate our program where they are generated. This can create problems when there are open resources that need to be properly closed. Go provides a mechanism to execute some code always, even in the presence of a panic.</p>

<h2 id="deferred-functions">Deferred Functions</h2>

<p>Your program may have resources that it must clean up properly, even while a panic is being processed by the runtime. Go allows you to defer the execution of a function call until its calling function has completed execution. Deferred functions run even in the presence of a panic, and are used as a safety mechanism to guard against the chaotic nature of panics. Functions are deferred by calling them as usual, then prefixing the entire statement with the <code>defer</code> keyword, as in <code>defer sayHello()</code>. Run this example to see how a message can be printed even though a panic was produced:</p>
<pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

func main() {
    defer func() {
        fmt.Println("hello from the deferred function!")
    }()

    panic("oh no!")
}
</code></pre>
<p>The output produced from this example will look like:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>hello from the deferred function!
panic: oh no!

goroutine 1 [running]:
main.main()
    /Users/gopherguides/learn/src/github.com/gopherguides/learn//handle-panics/src/main.go:10 +0x55
</code></pre>
<p>Within the <code>main</code> function of this example, we first <code>defer</code> a call to an anonymous function that prints the message <code>"hello from the deferred function!"</code>. The <code>main</code> function then immediately produces a panic using the <code>panic</code> function. In the output from this program, we first see that the deferred function is executed and prints its message. Following this is the panic we generated in <code>main</code>.</p>

<p>Deferred functions provide protection against the surprising nature of panics. Within deferred functions, Go also provides us the opportunity to stop a panic from terminating our Go program using another built-in function.</p>

<h2 id="handling-panics">Handling Panics</h2>

<p>Panics have a single recovery mechanism—the <code>recover</code> builtin function. This function allows you to intercept a panic on its way up through the call stack and prevent it from unexpectedly terminating your program. It has strict rules for its use, but can be invaluable in a production application.</p>

<p>Since it is part of the <code>builtin</code> package, <code>recover</code> can be called without importing any additional packages:</p>
<pre class="code-pre plain"><code langs="">package main

import (
    "fmt"
    "log"
)

func main() {
    divideByZero()
    fmt.Println("we survived dividing by zero!")

}

func divideByZero() {
    defer func() {
        if err := <span class="highlight">recover()</span>; err != nil {
            log.Println("panic occurred:", err)
        }
    }()
    fmt.Println(divide(1, 0))
}

func divide(a, b int) int {
    return a / b
}
</code></pre>
<p>This example will output:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>2009/11/10 23:00:00 panic occurred: runtime error: integer divide by zero
we survived dividing by zero!
</code></pre>
<p>Our <code>main</code> function in this example calls a function we define, <code>divideByZero</code>. Within this function, we <code>defer</code> a call to an anonymous function responsible for dealing with any panics that may arise while executing <code>divideByZero</code>. Within this deferred anonymous function, we call the <code>recover</code> builtin function and assign the error it returns to a variable. If <code>divideByZero</code> is panicking, this <code>error</code> value will be set, otherwise it will be <code>nil</code>. By comparing the <code>err</code> variable against <code>nil</code>, we can detect if a panic occurred, and in this case we log the panic using the <code>log.Println</code> function, as though it were any other <code>error</code>.</p>

<p>Following this deferred anonymous function, we call another function that we defined, <code>divide</code>, and attempt to print its results using <code>fmt.Println</code>. The arguments provided will cause <code>divide</code> to perform a division by zero, which will produce a panic.</p>

<p>In the output to this example, we first see the log message from the anonymous function that recovers the panic, followed by the message <code>we survived dividing by zero!</code>. We have indeed done this, thanks to the <code>recover</code> builtin function stopping an otherwise catastrophic panic that would terminate our Go program.</p>

<p>The <code>err</code> value returned from <code>recover()</code> is exactly the value that was provided to the call to <code>panic()</code>. It&rsquo;s therefore critical to ensure that the <code>err</code> value is only nil when a panic has not occurred.</p>

<h2 id="detecting-panics-with-recover">Detecting Panics with <code>recover</code></h2>

<p>The <code>recover</code> function relies on the value of the error to make determinations as to whether a panic occurred or not. Since the argument to the <code>panic</code> function is an empty interface, it can be any type. The zero value for any interface type, including the empty interface, is <code>nil</code>. Care must be taken to avoid <code>nil</code> as an argument to <code>panic</code> as demonstrated by this example:</p>
<pre class="code-pre "><code class="code-highlight language-go">package main

import (
    "fmt"
    "log"
)

func main() {
    divideByZero()
    fmt.Println("we survived dividing by zero!")

}

func divideByZero() {
    defer func() {
        if err := recover(); err != nil {
            log.Println("panic occurred:", err)
        }
    }()
    fmt.Println(divide(1, 0))
}

func divide(a, b int) int {
    if b == 0 {
        panic(nil)
    }
    return a / b
}

</code></pre>
<p>This will output:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>we survived dividing by zero!
</code></pre>
<p>This example is the same as the previous example involving <code>recover</code> with some slight modifications. The <code>divide</code> function has been altered to check if its divisor, <code>b</code>, is equal to <code>0</code>. If it is, it will generate a panic using the <code>panic</code> builtin with an argument of <code>nil</code>. The output, this time, does not include the log message showing that a panic occurred even though one was created by <code>divide</code>. This silent behavior is why it is very important to ensure that the argument to the <code>panic</code> builtin function is not <code>nil</code>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>We have seen a number of ways that <code>panic</code>s can be created in Go and how they can be recovered from using the <code>recover</code> builtin. While you may not necessarily use <code>panic</code> yourself, proper recovery from panics is an important step of making Go applications production-ready.</p>

<p>You can also explore <a href="https://www.digitalocean.com/community/tutorial_series/how-to-code-in-go">our entire How To Code in Go series</a>.</p>
