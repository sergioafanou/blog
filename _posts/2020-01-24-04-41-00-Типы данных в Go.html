---
layout: post
title: Типы данных в Go
network: digitalocean
date: January 24, 2020 at 04:41AM
url: https://www.digitalocean.com/community/tutorials/understanding-data-types-in-go-ru
image: http://ifttt.com/images/no_image_card.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="Введение">Введение</h3>

<p>Типы данных определяют виды значений, которые сохраняются определенными переменными при написании программы. Типы данных также помогают определить операции, которые можно выполнять с использованием данных.</p>

<p>В этой статье мы рассмотрим наиболее важные типы данных в Go. Это не исчерпывающее исследование типов данных, но оно поможет вам поближе познакомиться с доступными в Go возможностями. Понимание основных типов данных поможет писать более эффективный и понятный код.</p>

<h2 id="Базовая-информация">Базовая информация</h2>

<p>Чтобы лучше понять типы данных следует посмотреть на различные типы данных, которые мы используем в реальном мире. Например, в реальном мире мы используем числа. Это могут быть положительные числа (0, 1, 2, &hellip;), целые числа (&hellip;, -1, 0, 1, &hellip;) и, например, иррациональные числа (π).</p>

<p>Обычно в математике мы можем сочетать числа разных типов и получать определенный ответ. Например, мы можем выполнить операцию сложения 5 и π:</p>
<pre class="code-pre "><code langs="">5 + π
</code></pre>
<p>Мы можем сохранить уравнения как ответ, чтобы учитывать иррациональное число, или округлить π до числа с уменьшенным количеством знаков после запятой, а затем сложить числа:</p>
<pre class="code-pre "><code langs="">5 + π = 5 + 3.14 = 8.14
</code></pre>
<p>Однако если мы попробуем оценить числа с помощью другого типа данных, такого как слова, выражения будут иметь меньше смысла. Как мы решим следующее уравнение?</p>
<pre class="code-pre "><code langs="">shark + 8
</code></pre>
<p>Для компьютеров все типы данных отличаются, как слова и числа. В результате нам нужно осторожно подходить к использованию различных типов данных для назначения значений и манипуляции этими значениями посредством операций.</p>

<h2 id="Целые-числа">Целые числа</h2>

<p>Как и в математике, в программировании к <em>целым числам</em> относятся положительные числа, отрицательные числа и 0 (&hellip;, -1, 0, 1, &hellip;). В Go целое число определяется как <code>int</code>. Как и в других языках программирования, в числах не следует использовать запятые для отделения нулей, так что вместо 1,000 нужно писать <code>1000</code>.</p>

<p>Целое число можно вывести в простой форме:</p>
<pre class="code-pre "><code class="code-highlight language-go">fmt.Println(-459)
</code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>-459
</code></pre>
<p>Также мы можем декларировать переменную, которая будет выступать как символ используемого или изменяемого числа, например:</p>
<pre class="code-pre "><code class="code-highlight language-go">var absoluteZero int = -459
fmt.Println(absoluteZero)
</code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>-459
</code></pre>
<p>В Go  можно выполнять математические операции с целыми числами. В следующем блоке кода мы используем оператор назначения <code>:=</code> для декларирования и инициализации переменной <code>sum</code>:</p>
<pre class="code-pre "><code class="code-highlight language-go">sum := 116 - 68
fmt.Println(sum)
</code></pre><pre class="code-pre plain"><code langs=""><div class="secondary-code-label " title="Output">Output</div>48
</code></pre>
<p>Как видно на экране результатов, математический оператор <code>-</code> был использован для вычитания целого числа <code>68</code> из <code>116</code>, в результате чего получилось <code>48</code>. Дополнительную информацию о декларировании переменных можно найти в разделе <strong>Объявление типов данных для переменных</strong>.</p>

<p>Целые числа можно использовать в программах Go разными способами. По мере дальнейшего изучения Go у вас появится много возможностей работать с целыми числами и развивать знания об этом типе данных.</p>

<h2 id="Числа-с-плавающей-запятой">Числа с плавающей запятой</h2>

<p><em>Число с плавающей точкой *или</em> float *— это <a href="https://en.wikipedia.org/wiki/Real_number"><em>действительное число</em></a>, которое нельзя выразить в форме целого числа. В состав действительных чисел входят все рациональные и иррациональные числа, и поэтому числа с плавающей точкой могут содержать дробную часть, например 9,0 или -116,42. Чтобы представить тип float в программе Go, подумайте о числе с десятичной запятой.</p>

<p>Мы можем вывести число с плавающей запятой так же легко, как и целое число:</p>
<pre class="code-pre "><code class="code-highlight language-go">fmt.Println(-459.67)
</code></pre><pre class="code-pre plain"><code langs=""><div class="secondary-code-label " title="Output">Output</div>-459.67
</code></pre>
<p>Также мы можем объявить переменную, которая будет представлять число типа float:</p>
<pre class="code-pre "><code class="code-highlight language-go">absoluteZero := -459.67
fmt.Println(absoluteZero)
</code></pre><pre class="code-pre plain"><code langs=""><div class="secondary-code-label " title="Output">Output</div>-459.67
</code></pre>
<p>В Go можно выполнять математические операции с числами с плавающей точкой, как и с целыми числами:</p>
<pre class="code-pre "><code class="code-highlight language-go">var sum = 564.0 + 365.24
fmt.Println(sum)
</code></pre><pre class="code-pre plain"><code langs=""><div class="secondary-code-label " title="Output">Output</div>929.24
</code></pre>
<p>При работе с целыми числами и числами с плавающей точкой важно помнить, что 3 ≠ 3.0, поскольку 3 означает целое число, а 3.0 — число с плавающей точкой.</p>

<h2 id="Размеры-числовых-типов">Размеры числовых типов</h2>

<p>Помимо различия между целыми числами и числами с плавающей точкой, в Go имеется два типа числовых данных, которые различаются по статическому или динамическому характеру их размера. Первый тип — это <em>архитектурно-независимый</em> тип, и это означает, что размер данных в битах не изменяется вне зависимости от того, на какой машине выполняется код.</p>

<p>Сегодня большинство системных архитектур представляют собой 32-битные или 64-битные архитектуры. Например, вы можете разрабатывать приложения для современных ноутбуков с 64-битной операционной системой Windows. Однако, если вы разрабатывает приложения для таких устройств, как фитнес-браслеты, вам может потребоваться 32-битная архитектура. Если вы используете архитектурно-независимый тип, например <code>int32</code>, вне зависимости от компилируемой архитектуры, у этого типа будет постоянный размер.</p>

<p>Второй тип относится к <em>конкретному варианту реализации</em>. В этом типе разрядность может отличаться в зависимости от архитектуры, на базе которой построена программа. Например, если мы используем тип <code>int</code> при компиляции в Go для 32-битной архитектуры, размер типа данных будет составлять 32 бита. Если программа компилируется для 64-битной архитектуры, размер переменной будет составлять 64 бита.</p>

<p>Помимо разных размеров, такие типы данных, как целые числа, могут иметь два базовых типа: <em>со знаком</em> и <em>без знака</em>. <code>int8</code> — это целое число со знаком, которое может иметь значение от -128 до 127. <code>uint8</code> — целое число без знака, которое может иметь только положительное значение от 0 до 255.</p>

<p>Диапазоны зависят от размера в битах. Для двоичных данных 8 бит могут представлять 256 разных значений. Поскольку тип <code>int</code> должен поддерживать как положительные, так и отрицательные значения, 8-битное целое число (<code>int8</code>) будет иметь диапазон от -128 до 127, что соответствует 256 возможных уникальных значений.</p>

<p>В Go имеются следующие архитектурно-независимые типы целых чисел:</p>
<pre class="code-pre text"><code langs="">uint8       unsigned  8-bit integers (0 to 255)
uint16      unsigned 16-bit integers (0 to 65535)
uint32      unsigned 32-bit integers (0 to 4294967295)
uint64      unsigned 64-bit integers (0 to 18446744073709551615)
int8        signed  8-bit integers (-128 to 127)
int16       signed 16-bit integers (-32768 to 32767)
int32       signed 32-bit integers (-2147483648 to 2147483647)
int64       signed 64-bit integers (-9223372036854775808 to 9223372036854775807)
</code></pre>
<p>Числа с плавающей точкой и комплексные числа также могут иметь разные размеры:</p>
<pre class="code-pre text"><code langs="">float32     IEEE-754 32-bit floating-point numbers
float64     IEEE-754 64-bit floating-point numbers
complex64   complex numbers with float32 real and imaginary parts
complex128  complex numbers with float64 real and imaginary parts
</code></pre>
<p>Также существует несколько типов псевдонимов чисел, которые присваивают полезные имена определенным типам данных:</p>
<pre class="code-pre text"><code langs="">byte        alias for uint8
rune        alias for int32
</code></pre>
<p>Псевдоним <code>byte</code> дает понять, что ваша программа использует в качестве единицы измерения элементов символьной строки байты, а не малые целые числа, не связанные с измерением данных в байтах. Хотя после компиляции программы <code>byte</code> и <code>uint8</code> будут идентичны, <code>byte</code> часто используется для представления символьных данных в числовой форме, а <code>uint8</code> предполагается как число в программе.</p>

<p>Псевдоним <code>rune</code> немного отличается от вышеописанного. Если <code>byte</code> и <code>uint8</code> содержат одни и те же данные, <code>rune</code> может представлять собой один байт или четыре байта, определенный в <code>int32 диапазон</code>. <code>rune</code> используется для представления символа Unicode, в то время как символы ASCII может представлять только тип данных <code>int32</code>.</p>

<p>Кроме того, в Go имеются следующие типы для конркретных реализаций:</p>
<pre class="code-pre text"><code langs="">uint     unsigned, either 32 or 64 bits
int      signed, either 32 or 64 bits
uintptr  unsigned integer large enough to store the uninterpreted bits of a pointer value
</code></pre>
<p>Размер типов для конкретных реализаций определяется архитектурой, для которой скомпилирована программа.</p>

<h3 id="Выбор-числовых-типов-данных">Выбор числовых типов данных</h3>

<p>Выбор правильного размера больше зависит от производительности целевой архитектуры, чем от размера данных, с которыми вы работаете. Однако если вы не знаете особые требования вашей программы к производительности, в начале работы вы можете следовать некоторым из этих базовых рекомендаций.</p>

<p>Как обсуждалось ранее в этой статье, существуют типы, не зависящие от архитектуры, и типы, зависящие от реализации. Для целочисленных данных в Go обычно используются такие типы реализации, как <code>int</code> или <code>uint</code> вместо <code>int64</code> или <code>uint64</code>. Обычно это обеспечивает более высокую скорость обработки в целевой архитектуре. Например, если вы используете <code>int64</code> и выполняете компиляцию до 32-битной архитектуры, обработка этих значений займет в два раза меньше времени, поскольку для перемещения данных по архитектуре требуются дополнительные процессорные циклы. Если вы использовали <code>int</code>, программа определяет 32-битный размер для 32-битной архитектуры, в результате чего обработка будет значительно быстрее.</p>

<p>Если вы не хотите выходить за пределы определенного диапазона размеров, выбор архитектурно-независимого типа может увеличить скорость и снизить нагрузку на память. Например, если вы знаете, что ваши данные не превысят значение <code>100</code> и будут только положительными числами, выбор <code>uint8</code> сделает вашу программу более эффективной, поскольку для нее будет требоваться меньше памяти.</p>

<p>Мы рассмотрели некоторые возможные диапазоны типов числовых данных. Теперь посмотрим, что произойдет в случае превышения этих диапазонов в нашей программе.</p>

<h3 id="Переполнение-и-циклический-переход">Переполнение и циклический переход</h3>

<p>При попытке сохранения значения, превышающего возможности типа данных, в Go возможны <em>переполнение</em> или <em>циклический переход</em>, в зависимости от того, рассчитывается ли значение при компиляции или во время исполнения Ошибка при компиляции возникает, если программа обнаруживает ошибку при попытке сборки программы. Ошибка времени исполнения возникает во время фактического выполнения уже скомпилированной программы.</p>

<p>В следующем прмере мы зададим для <code>maxUint32</code> максимальное значение:</p>
<pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

func main() {
    var maxUint32 uint32 = 4294967295 // Max uint32 size
    fmt.Println(maxUint32)
}
</code></pre>
<p>После компиляции и запуска получим следующий результат:</p>
<pre class="code-pre "><code class="code-highlight language-go"><div class="secondary-code-label " title="Output">Output</div>4294967295
</code></pre>
<p>Если мы прибавим <code>1</code> к значению времени исполнения, произойдет циклический переход на <code>0</code>:</p>
<pre class="code-pre "><code class="code-highlight language-go"><div class="secondary-code-label " title="Output">Output</div>0
</code></pre>
<p>Теперь изменим программу, чтобы прибавить <code>1</code> к переменной при ее назначении, то есть до компиляции:</p>
<pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

func main() {
    var maxUint32 uint32 = 4294967295 + 1
    fmt.Println(maxUint32)

}
</code></pre>
<p>Во время компиляции, если компилятор определяет, что значение слишком большое для заданного типа данных, он выводит сообщение об <code>ошибке переполнения</code>. Это означает, что рассчитанное значение слишком большое для заданного типа данных.</p>

<p>Поскольку компилятор может определить переполнение, он выведет сообщение об ошибке:</p>
<pre class="code-pre plain"><code langs=""><div class="secondary-code-label " title="Output">Output</div>prog.go:6:36: constant 4294967296 overflows uint32
</code></pre>
<p>Понимание ограничений данных поможет избежать потенциальных ошибок программы в будущем.</p>

<p>Мы поговорили о числовых типах, и теперь пришло время перейти к хранению логических значений.</p>

<h2 id="Логические-операторы">Логические операторы</h2>

<p>Тип данных <em>boolean</em> может иметь значение <code>истина</code> или <code>ложь</code> и определяется как <code>bool</code> при декларировании. Логические операторы используются для представления значений истины, связанных с логическим ответвлением математики, которое информирует алгоритмы в информатике.</p>

<p>Значения <code>true</code> и <code>false</code> всегда обозначаются символами <code>t</code> и <code>f</code> в нижнем регистре, поскольку эти идентификаторы заранее декларированы в Go.</p>

<p>Многие математические операции дают ответы, соответствующие значениям «истина» или «ложь»:</p>

<ul>
<li>больше чем

<ul>
<li>500 &gt; 100 истина</li>
<li>1 &gt; 5 ложь</li>
</ul></li>
<li>меньше чем

<ul>
<li>200 &lt; 400 истина</li>
<li>4 &lt; 2 ложь</li>
</ul></li>
<li>равно

<ul>
<li>5 = 5 истина</li>
<li>500 = 400 ложь</li>
</ul></li>
</ul>

<p>Как и для чисел, значения логических операторов могут храниться в переменных:</p>
<pre class="code-pre "><code class="code-highlight language-go">myBool := 5 &gt; 8
</code></pre>
<p>Мы можем распечатать значение логического оператора посредством вызова функции <code>fmt.Println()</code>:</p>
<pre class="code-pre "><code class="code-highlight language-go">fmt.Println(myBool)
</code></pre>
<p>Поскольку <code>5</code> не больше <code>8</code>, мы получим следующий результат:</p>
<pre class="code-pre plain"><code langs=""><div class="secondary-code-label " title="Output">Output</div>false
</code></pre>
<p>Чем больше программ вы напишете на Go, тем лучше вы поймете принципы работы логических операторов и влияние оценки <code>истинности</code> и <code>ложности</code> разных функций или операций на выполнение программы.</p>

<h2 id="Строки">Строки</h2>

<p>Строка — это последовательность из одного или нескольких символов (буквы, числа, символы), которая может представлять собой константу или переменную. Строки существуют внутри одинарных кавычек <code>`</code> или двойных кавычек <code>"</code> в Go и имеют разные характеристики в зависимости от типа кавычек.</p>

<p>Если вы используете одинарные кавычки, вы создаете <em>необработанный</em> строковый литерал. Если вы используете двойные кавычки, вы создаете <em>интерпретируемый</em> строковый литерал.</p>

<h3 id="Необработанные-литералы-строк">Необработанные литералы строк</h3>

<p>Необработанные строковые литералы — это последовательности символов между одинарными кавычками. Каждый символ внутри кавычек будет выглядеть точно так же, как он отображается, за исключением самих символов одинарных кавычек.</p>
<pre class="code-pre "><code class="code-highlight language-go">a := `Say "hello" to Go!`
fmt.Println(a)
</code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Say "hello" to Go!
</code></pre>
<p>Специальные символы в строках обычно обозначаются обратной косой чертой. Например, в интерпретируемой строке <code>\n</code> представляет новую строчку в строке. Однако внутри необработанных литералов строк обратная косая черта не имеет особого значения:</p>
<pre class="code-pre "><code class="code-highlight language-go">a := `Say "hello" to Go!\n`
fmt.Println(a)
</code></pre>
<p>Поскольку в литерале строки обратная косая черта не имеет особого значения, программа будет выводить значение <code>\n</code> вместо создания новой строки:</p>
<pre class="code-pre plain"><code langs=""><div class="secondary-code-label " title="Output">Output</div>Say "hello" to Go!\n
</code></pre>
<p>Необработанные литералы строк также могут использоваться для создания строк, включающих несколько строчек:</p>
<pre class="code-pre "><code class="code-highlight language-go">a := `This string is on
multiple lines
within a single back
quote on either side.`
fmt.Println(a)
</code></pre><pre class="code-pre plain"><code langs=""><div class="secondary-code-label " title="Output">Output</div>This string is on
multiple lines
within a single back
quote on either side.
</code></pre>
<p>В предыдущих блоках кода новые строчки буквально переносились из входных данных в результаты.</p>

<h3 id="Интерпретируемые-литералы-строк">Интерпретируемые литералы строк</h3>

<p>Интерпретируемые строковые литералы — это последовательность символов внутри двойных кавычек, например, <code>"bar"</code>. Внутри кавычек может находиться любой символ, кроме символа новой строчки и незакрытых двойных кавычек. Для отображения двойных кавычек в интерпретируемой строке вы  можете использовать обратную косую черту в качестве символа перехода:</p>
<pre class="code-pre "><code class="code-highlight language-go">a := "Say \"hello\" to Go!"
fmt.Println(a)
</code></pre><pre class="code-pre plain"><code langs=""><div class="secondary-code-label " title="Output">Output</div>Say "hello" to Go!
</code></pre>
<p>Практически всегда вы будете использовать интерпретируемые строковые литералы, поскольку они позволяют выполнять экранирование символов внутри строк. Дополнительную информацию о строках можно найти в статье, посвященной <a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-working-with-strings-in-go">основам работы со строками в Go</a>.</p>

<h3 id="Строки-с-символами-utf-8">Строки с символами UTF-8</h3>

<p>UTF-8 — это схема кодировки, используемая для кодировки символов переменной ширины в 1-4 байтах. Go поддерживает символы UTF-8 без специальных настроек, библиотек или пакетов. Латинские символы, такие как буква <code>A</code>, могут быть представлены значением ASCII, например, числом 65. Однако при использовании специальных символов, таких как международный символ <code>世</code>, требуется UTF-8. Go использует тип псевдонима <code>rune</code> для данных UTF-8.</p>
<pre class="code-pre "><code class="code-highlight language-go">a := "Hello, 世界"
</code></pre>
<p>Вы можете использовать ключевое слово <code>range</code> в цикле <code>for</code> для индексации любых строк в Go, в том числе строк UTF-8. Мы более подробно расскажем о циклах <code>for</code> и о ключевом слове <code>range</code> позднее, а сейчас важно помнить, что мы можем использовать их для подсчета количества байт в строке:</p>
<pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

func main() {
    a := "Hello, 世界"
    for i, c := range a {
        fmt.Printf("%d: %s\n", i, string(c))
    }
    fmt.Println("length of 'Hello, 世界': ", len(a))
}
</code></pre>
<p>В блоке кода выше мы декларировали переменную <code>a</code> и назначили для нее значение <code>Hello, 世界</code>. Назначенный текст содержит символы UTF-8.</p>

<p>Затем мы использовали стандартный цикл <code>for</code> и ключевое слово <code>range</code>. В Go ключевое слово <code>range</code> индексирует строку, возвращая по одному символу, а также выполняет байтовую индексацию символа в строке.</p>

<p>С помощью функции <code>fmt.Printf</code> мы выводим строку формата <code>%d: %s\n</code>. <code>%d</code> — это печатное обозначение цифры (в данном случае целого числа), а <code>%s</code> — обозначение строки. Затем мы задали значения <code>i</code> или текущего индекса цикла <code>for</code>,а также <code>c</code>, который представляет текущий символ цикла <code>for</code>.</p>

<p>В заключение мы распечатали полную переменную <code>a</code> с помощью встроенной функции <code>len</code>.</p>

<p>Мы уже упоминали, что rune является псевдонимом <code>int32</code> и может состоять из 1-4 байт. Для определения символа <code>世</code> требуется три байта, и индекс перемещается соответствующим образом при изменении диапазона в строке UTF-8. По этой причине печать <code>i</code> не выполняется последовательно.</p>
<pre class="code-pre text"><code langs=""><div class="secondary-code-label " title="Output">Output</div>0: H
1: e
2: l
3: l
4: o
5: ,
6:
7: 世
10: 界
length of 'Hello, 世界':  13
</code></pre>
<p>Как видите, длина превышает количество проходов диапазона строки.</p>

<p>Вы не всегда будете использовать строки UTF-8, но теперь вы понимаете, почему они относятся к типу rune, а не <code>int32</code>.</p>

<h2 id="Декларирование-типов-данных-для-переменных">Декларирование типов данных для переменных</h2>

<p>Вы узнали о разных типах данных примитивов, и теперь мы перейдем к назначению этих типов для переменных в Go.</p>

<p>В Go мы можем определять переменные с помощью ключевого слова <code>var</code>, за которым идут имя переменной и желаемый тип данных.</p>

<p>В следующем примере мы декларируем переменную с именем <code>pi</code> типа <code>float64</code>.</p>

<p>В первую очередь декларируется ключевое слово <code>var</code>:</p>
<pre class="code-pre "><code class="code-highlight language-go"><span class="highlight">var</span> pi float64
</code></pre>
<p>Далее идет имя переменной <code>pi</code>:</p>
<pre class="code-pre "><code class="code-highlight language-go">var <span class="highlight">pi</span> float64
</code></pre>
<p>Последним идет тип данных <code>float64</code>:</p>
<pre class="code-pre "><code class="code-highlight language-go">var pi <span class="highlight">float64</span>
</code></pre>
<p>При желании мы можем задать начальное значение, например, <code>3.14</code>:</p>
<pre class="code-pre "><code class="code-highlight language-go">var pi float64 = <span class="highlight">3.14</span>
</code></pre>
<p>Go — это язык <em>статических типов</em>. Использование статических типов означает, что каждое выражение в программе проверяется во время компиляции. Также это означает, что тип данных привязан к переменной, как в динамически связанных языках тип данных привязан к значению.</p>

<p>Например, в Go тип декларируется при декларировании переменной:</p>
<pre class="code-pre "><code class="code-highlight language-go">var pi float64 = 3.14
var week int = 7
</code></pre>
<p>Каждая из этих переменных может соответствовать отдельному типу данных, если вы декларировали их по разному.</p>

<p>Этим Go отличается от таких языков как PHP, где тип данных привязывается к значению:</p>
<pre class="code-pre "><code class="code-highlight language-php">$s = "sammy";         // $s is automatically a string
$s = 123;             // $s is automatically an integer
</code></pre>
<p>В предыдущем блоке кода первая переменная <code>$s</code> является строкой, поскольку ей присвоено значение <code>"sammy"</code>, а вторая являетя целым числом, поскольку ей присвоено значение <code>123</code>.</p>

<p>Теперь рассмотрим более сложные типы данных — массивы.</p>

<h2 id="Массивы">Массивы</h2>

<p><em>Массив</em> представляет собой упорядоченную последовательность элементов. Вместимость массива определяется во время создания. После определения размера массива его нельзя изменить. Поскольку массив имеет статичный размер, память для него выделяется только один раз. Это делает массивы менее гибкими, но повышает производительность вашей программы. Поэтому массивы обычно используются при оптимизации программ. <em>Срезы</em>, о которых мы поговорим позднее, являются более гибкими и соответствуют общепринятой концепции массивов, применяемой в других языках.</p>

<p>Массивы определяются посредством декларирования размера массива и типа данных с определением значений внутри фигурных скобок <code>{ }</code>.</p>

<p>Массив строк должен выглядеть следующим образом:</p>
<pre class="code-pre "><code class="code-highlight language-go">[3]string{"blue coral", "staghorn coral", "pillar coral"}
</code></pre>
<p>Мы можем сохранить массив в переменной и распечатать его:</p>
<pre class="code-pre "><code class="code-highlight language-go">coral := [3]string{"blue coral", "staghorn coral", "pillar coral"}
fmt.Println(coral)
</code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>[blue coral staghorn coral pillar coral]
</code></pre>
<p>Как мы уже говорили, срезы похожи на массивы, но при этом более гибкие. Рассмотрим следующий мутируемый тип данных.</p>

<h2 id="Срезы">Срезы</h2>

<p><em>Срезы</em> — это упорядоченная последовательность элементов, длина которых может изменяться. Размер срезов может увеличиваться динамически. Если при добавлении в срез новых элементов в срезе оказывается недостаточно памяти, он запрашивает в системе дополнительную память по мере необходимости. Поскольку срез можно расширить для добавления дополнительных элементов, они используются чаще, чем массивы.</p>

<p>Срезы определяются посредством декларирования типа данных, которому предшествуют открывающая и закрывающая квадратные скобки <code>[]</code>, а значения указываются в фигурных скобках <code>{ }</code>.</p>

<p>Срез целых чисел выглядит следующим образом:</p>
<pre class="code-pre "><code class="code-highlight language-go">[]int{-3, -2, -1, 0, 1, 2, 3}
</code></pre>
<p>Срез чисел с плавающей точкой выглядит следующим образом:</p>
<pre class="code-pre "><code class="code-highlight language-go">[]float64{3.14, 9.23, 111.11, 312.12, 1.05}
</code></pre>
<p>Срез строк выглядит следующим образом:</p>
<pre class="code-pre "><code class="code-highlight language-go">[]string{"shark", "cuttlefish", "squid", "mantis shrimp"}
</code></pre>
<p>Определим срез строк как <code>seaCreatures</code>:</p>
<pre class="code-pre "><code class="code-highlight language-go">seaCreatures := []string{"shark", "cuttlefish", "squid", "mantis shrimp"}
</code></pre>
<p>Мы можем распечатать его посредством вызова переменной:</p>
<pre class="code-pre "><code class="code-highlight language-go">fmt.Println(seaCreatures)
</code></pre>
<p>Выводимые результаты будут выглядеть точно так, как созданный нами список:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>[shark cuttlefish squid mantis shrimp]
</code></pre>
<p>Мы можем использовать ключевое слово <code>append</code> для добавления элементов в срез. Следующая команда добавляет значение строки <code>seahorse</code> в срез:</p>
<pre class="code-pre "><code class="code-highlight language-go">seaCreatures = append(seaCreatures, "seahorse")
</code></pre>
<p>Вы можете проверить его добавление посредством вывода значений:</p>
<pre class="code-pre "><code class="code-highlight language-go">fmt.Println(seaCreatures)
</code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>[shark cuttlefish squid mantis shrimp seahorse]
</code></pre>
<p>Как видите, если вам требуется управление неизвестным количеством элементов, срез будет более гибким, чем массив.</p>

<h2 id="Карты">Карты</h2>

<p><em>Карта</em> — это встроенный в Go тип хэша или словаря. Карты используют пары <em>ключей</em> и <em>значений</em> для хранения данных. Это полезно в программировании для быстрого просмотра значений по индексу или (в данном случае) по ключу. Например, вам может потребоваться карта пользователей с индексацией по идентификатору пользователя. Ключ может быть идентификатором пользователя, а объект пользователя будет значением. Карта создается с помощью ключевого слова <code>map</code> с типом данных ключа в квадратных скобках <code>[ ]</code>, за которым идут пары значение и ключ в фигурных скобках.</p>
<pre class="code-pre plain"><code langs="">map[<span class="highlight">key</span>]<span class="highlight">value</span>{}
</code></pre>
<p>Карты обычно используются для хранения связанных данных, в том числе информации из идентификаторов, и выглядят следующим образом:</p>
<pre class="code-pre "><code class="code-highlight language-go">map[string]string{"name": "Sammy", "animal": "shark", "color": "blue", "location": "ocean"}
</code></pre>
<p>Обратите внимание, что помимо фигурных скобок карта содержит двоеточия. Слова слева от двоеточий являются ключами. Ключи могут относится к любому *comparable *типу в Go. Сравнимые типы — это типы примитивов, в том числе <code>строки</code>, <code>целы</code>е числа и т. д. Тип примитива определяется языком, а не составляется посредством сочетания других типов. Хотя допускается использование определяемых пользователем типов, во избежание ошибок программирования их лучше оставлять простыми. В словаре выше содержатся ключи: <code>name</code>, <code>animal</code>, <code>color</code> и <code>location</code>.</p>

<p>Слова справа от двоеточий являются значениями. Значения могут состоять из любого типа данных. Значения в словаре выше: <code>Sammy</code>, <code>shark</code>, <code>blue</code> и <code>ocean</code>.</p>

<p>Давайте сохраним карту внутри переменной и выведем ее:</p>
<pre class="code-pre "><code class="code-highlight language-go">sammy := map[string]string{"name": "Sammy", "animal": "shark", "color": "blue", "location": "ocean"}
fmt.Println(sammy)
</code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>map[animal:shark color:blue location:ocean name:Sammy]
</code></pre>
<p>Если мы хотим изолировать цвет Sammy, мы можем использовать вызов <code>sammy["color"]</code>. Распечатаем результат:</p>
<pre class="code-pre "><code class="code-highlight language-go">fmt.Println(sammy["color"])
</code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>blue
</code></pre>
<p>Поскольку карты предоставляют пары ключ-значение для хранения данных, они могут стать важным элементом вашей программы Go.</p>

<h2 id="Заключение">Заключение</h2>

<p>Теперь вы должны лучше понимать основные типы данных, доступные для использования в Go. Каждый из этих типов данных важен при разработке проектов на языке Go.</p>

<p>Когда вы разберетесь с доступными типами данных в Go, вы также можете изучить <a href="https://www.digitalocean.com/community/tutorials/how-to-convert-data-types-in-go">конвертацию типов данных</a>, чтобы иметь возможность изменять типы данных в зависимости от ситуации.</p>
