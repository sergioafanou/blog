---
layout: post
title: Como Proteger Serviços Privados do Kubernetes por meio de um Login do GitHub com oauth2_proxy
network: digitalocean
date: November 14, 2019 at 06:57PM
url: https://www.digitalocean.com/community/tutorials/como-proteger-servicos-privados-do-kubernetes-por-meio-de-um-login-do-github-com-oauth2_proxy-pt
image: https://assets.digitalocean.com/articles/doks_private_oauth/W0VBgjC.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="introdução">Introdução</h3>

<p>O Kubernetes <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/">ingress</a> facilita a exposição de web services para a internet. Quando se trata de serviços privados, no entanto, você provavelmente desejará limitar quem pode acessá-los. O <a href="https://pusher.github.io/oauth2_proxy/">oauth2_proxy</a> pode servir como uma barreira entre a Internet pública e os serviços privados. O oauth2_proxy é um servidor e proxy reverso que fornece autenticação usando diferentes provedores, como o GitHub, e valida os usuários pelo seu endereço de email ou outras propriedades.</p>

<p>Neste tutorial, você usará o oauth2_proxy com o GitHub para proteger seus serviços. Quando terminar, você terá um sistema de autorização semelhante ao do diagrama a seguir:</p>

<p><img src="https://assets.digitalocean.com/articles/doks_private_oauth/W0VBgjC.png" alt="A diagram of a request flow end-result"></p>

<h2 id="pré-requisitos">Pré-requisitos</h2>

<p>Para concluir este tutorial, você precisará de:</p>

<ul>
<li>Um cluster Kubernetes com dois web services em execução com Nginx Ingress  e Let&rsquo;s Encrypt. Este tutorial baseia-se no tutorial <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-an-nginx-ingress-with-cert-manager-on-digitalocean-kubernetes">How to Set Up an Nginx Ingress with Cert-Manager on DigitalOcean Kubernetes</a>. Certifique-se de segui-lo até o final, a fim de concluir este tutorial. </li>
<li>Um conta no <a href="https://github.com">GitHub</a>.</li>
<li>Python instalado em sua máquina local. Se você não o tiver instalado, siga as <a href="https://www.digitalocean.com/community/tags/python?type=tutorials#install-and-configure-python">instruções de instalação do seu sistema operacional</a>. </li>
</ul>

<h2 id="passo-1-—-configurando-seus-domínios">Passo 1 — Configurando seus Domínios</h2>

<p>Após seguir o tutorial indicado na seção Pré-requisitos, você terá dois web services em execução no cluster: <code>echo1</code> e <code>echo2</code>. Você também terá um ingress que mapeia <code>echo1.<span class="highlight">seu_domínio</span></code> e <code>echo2.<span class="highlight">seu_domínio</span></code> aos seus serviços correspondentes.</p>

<p>Neste tutorial, usaremos as seguintes convenções:</p>

<ul>
<li>Todos os serviços privados se enquadram no subdomínio  <code>.int.<span class="highlight">seu_domínio</span></code>, como <code>service.int.<span class="highlight">seu_domínio</span></code>. O agrupamento de serviços privados em um subdomínio é ideal porque o cookie de autenticação será compartilhado por todos os subdomínios <code>*.int.<span class="highlight">seu_domínio</span></code></li>
<li>O portal de login será exibido em <code>auth.int.<span class="highlight">seu_domínio</span></code>.</li>
</ul>

<p><span class='note'><strong>Nota:</strong> Certifique-se de substituir <code><span class="highlight">seu_domínio</span></code> pelo seu próprio nome de domínio onde quer que ele apareça neste tutorial.<br></span></p>

<p>Para começar, atualize a definição atual do ingress para mover os serviços <code>echo1</code> e <code>echo2</code> em <code>.int.<span class="highlight">seu_domínio</span></code>. Abra <code>echo_ingress.yaml</code> em seu editor de textos para poder alterar os domínios:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano echo_ingress.yaml
</li></ul></code></pre>
<p>Renomeie todas as instâncias de <code>echo1.<span class="highlight">seu_domínio</span></code> para <code>echo1.int.<span class="highlight">seu_domínio</span></code>, e substitua todas as instâncias de <code>echo2.<span class="highlight">seu_domínio</span></code> com <code>echo2.<span class="highlight">int.seu_domínio</span></code>:</p>
<div class="code-label " title="echo_ingress.yaml">echo_ingress.yaml</div><pre class="code-pre "><code langs="">apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: echo-ingress
  annotations:  
    kubernetes.io/ingress.class: nginx
    certmanager.k8s.io/cluster-issuer: letsencrypt-prod
spec:
  tls:
  - hosts:
    - echo1.<span class="highlight">int.seu_domínio</span>
    - echo2.<span class="highlight">int.seu_domínio</span>
    secretName: letsencrypt-prod
  rules:
  - host: echo1.<span class="highlight">int.seu_domínio</span>
    http:
      paths:
      - backend:
          serviceName: echo1
          servicePort: 80
  - host: echo2.<span class="highlight">int.seu_domínio</span>
    http:
      paths:
      - backend:
          serviceName: echo2
          servicePort: 80
</code></pre>
<p>Salve o arquivo e aplique as alterações:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f echo_ingress.yaml
</li></ul></code></pre>
<p>Isso atualizará os certificados TLS para seus serviços <code>echo1</code> e<code>echo2</code> também.</p>

<p>Agora atualize sua configuração de DNS para refletir as alterações que você fez. Primeiro, procure o endereço IP de seu ingress Nginx executando o seguinte comando para imprimir seus detalhes:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get svc --namespace=ingress-nginx
</li></ul></code></pre>
<p>Você verá o endereço IP abaixo de <code>EXTERNAL-IP</code> na saída:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME            TYPE           CLUSTER-IP      EXTERNAL-IP       PORT(S)                      AGE
ingress-nginx   LoadBalancer   <span class="highlight">10.245.247.67</span>   <span class="highlight">203.0.113.0</span>   80:32486/TCP,443:32096/TCP   20h
</code></pre>
<p>Copie o endereço IP externo para a sua área de transferência. Navegue até o seu serviço de gerenciamento de DNS e localize os registros <strong>A</strong> para <code>echo1-2.<span class="highlight">seu_domínio</span></code> para apontar para esse endereço IP externo. Se você estiver usando a DigitalOcean para gerenciar seus registros DNS, veja <a href="https://www.digitalocean.com/docs/networking/dns/how-to/manage-records/">How to Manage DNS Records</a> para instruções. </p>

<p>Delete os registros para <code>echo1</code> e <code>echo2</code>. Adicione um novo registro <code>A</code> para o hostname <code>*.int.<span class="highlight">seu_domínio</span></code> e o aponte para o endereço IP externo do ingress.</p>

<p>Agora, qualquer solicitação para qualquer subdomínio em <code>*.int.<span class="highlight">seu_domínio</span></code> será roteada para o ingress Nginx, para que você possa usar esses subdomínios no seu cluster.</p>

<p>Em seguida, você irá configurar o GitHub como seu provedor de login.</p>

<h2 id="passo-2-—-criando-uma-aplicação-github-oauth">Passo 2 — Criando uma Aplicação GitHub OAuth</h2>

<p>O oauth2_proxy suporta vários provedores de login. Neste tutorial, você usará o provedor GitHub. Para começar, crie uma nova aplicação GitHub OAuth.</p>

<p>Na <a href="https://github.com/settings/developers">guia OAuth Apps da página de configurações do desenvolvedor</a> da sua conta, clique no botão <strong>New OAuth App</strong>.</p>

<p>Os campos <strong>Application name</strong> e <strong>Homepage URL</strong> podem ser qualquer coisa que você quiser. No campo <strong>Authorization callback URL</strong>, digite <code>https://auth.int.<span class="highlight">seu_domínio</span>/oauth2/callback</code>.</p>

<p>Depois de registrar a aplicação, você receberá um Client ID e um Secret. Tome nota dos dois, pois você precisará deles no próximo passo.</p>

<p>Agora que você criou uma aplicação GitHub OAuth, você pode instalar e configurar o oauth2_proxy.</p>

<h2 id="passo-3-–-configurando-o-portal-de-login">Passo 3 – Configurando o Portal de Login</h2>

<p>Você usará o Helm para instalar o oauth2<em>proxy no cluster. Primeiro, você criará um secret do Kubernetes para armazenar o Client ID e o Secret da aplicação GitHub, bem como um secret de criptografia para os cookies do navegador definidos pelo oauth2</em>proxy.</p>

<p>Execute o seguinte comando para gerar um secret de cookie seguro:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">python -c 'import os,base64; print base64.b64encode(os.urandom(16))'
</li></ul></code></pre>
<p>Copie o resultado para sua área de transferência.</p>

<p>Em seguida, crie o secret do Kubernetes, substituindo os valores destacados pelo seu secret de cookie, seu ID de cliente GitHub e sua chave secreta do GitHub:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl -n default create secret generic oauth2-proxy-creds \
</li><li class="line" prefix="$">--from-literal=cookie-secret=<span class="highlight">SEU_COOKIE_SECRET</span> \
</li><li class="line" prefix="$">--from-literal=client-id=<span class="highlight">SEU_GITHUB_CLIENT_ID</span> \
</li><li class="line" prefix="$">--from-literal=client-secret=<span class="highlight">SEU_GITHUB_SECRET</span>
</li></ul></code></pre>
<p>Você verá a seguinte saída:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>secret/oauth2-proxy-creds created
</code></pre>
<p>Em seguida, crie um novo arquivo chamado <code>oauth2-proxy-config.yaml</code> que conterá a configuração para o <code>oauth2_proxy</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano oauth2-proxy-config.yaml
</li></ul></code></pre>
<p>Os valores que você definir neste arquivo substituirão os valores padrão do  Helm. Adicione o seguinte código ao arquivo:</p>
<div class="code-label " title="oauth2-proxy-config.yaml">oauth2-proxy-config.yaml</div><pre class="code-pre yaml"><code langs="">config:
  existingSecret: oauth2-proxy-creds

extraArgs:
  whitelist-domain: .int.<span class="highlight">seu_domínio</span>
  cookie-domain: .int.<span class="highlight">seu_domínio</span>
  provider: github

authenticatedEmailsFile:
  enabled: true
  restricted_access: |-
    <span class="highlight">permitido@user1.com</span>
    <span class="highlight">permitido@user2.com</span>

ingress:
  enabled: true
  path: /
  hosts:
    - auth.int.<span class="highlight">seu_domínio</span>
  annotations:
    kubernetes.io/ingress.class: nginx
    certmanager.k8s.io/cluster-issuer: letsencrypt-prod
  tls:
    - secretName: oauth2-proxy-https-cert
      hosts:
        - auth.int.<span class="highlight">seu_domínio</span>
</code></pre>
<p>Este código faz o seguinte:</p>

<ol>
<li>Instrui o oauth2_proxy a usar o secret que você criou.</li>
<li>Define o nome do domínio e o tipo de provedor.</li>
<li>Define uma lista de endereços de email permitidos. Se uma conta do GitHub estiver associada a um desses endereços de e-mail, será permitido o acesso aos serviços privados.</li>
<li>Configura o ingress que servirá o portal de login em <code>auth.int.<span class="highlight">seu_domínio</span></code> com um certificado TLS da Let&rsquo;s Encrypt.</li>
</ol>

<p>Agora que você tem o secret e o arquivo de configuração prontos, você pode instalar o <code>oauth2_proxy</code>. Execute o seguinte comando:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">helm repo update \
</li><li class="line" prefix="$">&amp;&amp; helm upgrade oauth2-proxy --install stable/oauth2-proxy \
</li><li class="line" prefix="$">--reuse-values \
</li><li class="line" prefix="$">--values oauth2-proxy-config.yaml
</li></ul></code></pre>
<p>Pode levar alguns minutos para que o certificado Let&rsquo;s Encrypt seja emitido e instalado.</p>

<p>Para testar se o deploy foi bem-sucedido, navegue até <code>https://auth.int.<span class="highlight">seu_domínio</span></code>. Você verá uma página que solicita que você efetue login no GitHub.</p>

<p>Com oauth2_proxy configurado e em execução, tudo o que falta é exigir autenticação nos seus serviços.</p>

<h2 id="passo-4-—-protegendo-os-serviços-privados">Passo 4 — Protegendo os Serviços Privados</h2>

<p>Para proteger um serviço, configure seu Nginx ingress para forçar a autenticação via oauth2_proxy. O Nginx e o nginx-ingress suportam essa configuração nativamente, portanto, você só precisa adicionar algumas anotações à definição do ingress.</p>

<p>Vamos proteger os serviços <code>echo1</code> e <code>echo2</code> que você configurou no tutorial de pré-requisito. Abra <code>echo_ingress.yaml</code> em seu editor:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano echo_ingress.yaml
</li></ul></code></pre>
<p>Adicione essas duas anotações adicionais ao arquivo para exigir autenticação:</p>
<div class="code-label " title="echo_ingress.yaml">echo_ingress.yaml</div><pre class="code-pre "><code langs="">   annotations:
     kubernetes.io/ingress.class: nginx
     certmanager.k8s.io/cluster-issuer: letsencrypt-prod
     <span class="highlight">nginx.ingress.kubernetes.io/auth-url: "https://auth.int.seu_domínio/oauth2/auth"</span>
     <span class="highlight">nginx.ingress.kubernetes.io/auth-signin: "https://auth.int.seu_domínio/oauth2/start?rd=https%3A%2F%2F$host$request_uri"</span>
</code></pre>
<p>Salve o arquivo e aplique as alterações:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f echo_ingress.yaml
</li></ul></code></pre>
<p>Agora, quando você navega até <code>https://echo1.int.<span class="highlight">seu_domínio</span></code>, você será solicitado a fazer login usando o GitHub para acessá-lo. Após fazer o login com uma conta válida, você será redirecionado de volta ao serviço <code>echo1</code>. O mesmo vale para <code>echo2</code>.</p>

<h2 id="conclusão">Conclusão</h2>

<p>Neste tutorial, você configurou o oauth2_proxy no seu cluster Kubernetes e protegeu um serviço privado atrás de um login do GitHub. Para qualquer outro serviço que você precise proteger, basta seguir as instruções descritas no Passo 4.</p>

<p>O oauth2_proxy suporta muitos provedores diferentes, além do GitHub. Para saber mais sobre diferentes provedores, consulte <a href="https://pusher.github.io/oauth2_proxy/auth-configuration">a documentação oficial</a>.</p>

<p>Além disso, existem muitos parâmetros de configuração que você pode precisar ajustar, embora os padrões adotados sejam adequados à maioria das necessidades. Para uma lista de parâmetros, consulte <a href="https://github.com/helm/charts/tree/master/stable/oauth2-proxy">a documentação do Helm charts</a> e <a href="https://pusher.github.io/oauth2_proxy/configuration">a documentação do oauth2_proxy</a>.</p>
