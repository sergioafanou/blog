---
layout: post
title: Using ldflags to Set Version Information for Go Applications
network: digitalocean
date: October 22, 2019 at 08:13PM
url: https://www.digitalocean.com/community/tutorials/using-ldflags-to-set-version-information-for-go-applications
image: http://ifttt.com/images/no_image_card.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="introduction">Introduction</h3>

<p>When deploying applications into a production environment, building binaries with version information and other metadata will improve your monitoring, logging, and debugging processes by adding identifying information to help track your builds over time. This version information can often include highly dynamic data, such as build time, the machine or user building the binary, the <a href="https://www.atlassian.com/git/tutorials/what-is-version-control">Version Control System (VCS)</a> commit ID it was built against, and more. Because these values are constantly changing, coding this data directly into the source code and modifying it before every new build is tedious and prone to error: Source files can move around and <a href="https://www.digitalocean.com/community/tutorials/how-to-use-variables-and-constants-in-go">variables/constants</a> may switch files throughout development, breaking the build process.</p>

<p>One way to solve this in Go is to use <code>-ldflags</code> with the <code>go build</code> command to insert dynamic information into the binary at build time, without the need for source code modification. In this flag, <code>ld</code> stands for <a href="https://en.wikipedia.org/wiki/Linker_(computing)"><em>linker</em></a>, the program that links together the different pieces of the compiled source code into the final binary. <code>ldflags</code>, then, stands for <em>linker flags</em>. It is called this because it passes a flag to the underlying Go toolchain linker, <a href="https://golang.org/cmd/link"><code>cmd/link</code></a>, that allows you to change the values of imported packages at build time from the command line.</p>

<p>In this tutorial, you will use <code>-ldflags</code> to change the value of variables at build time and introduce your own dynamic information into a binary, using a sample application that prints version information to the screen.</p>

<h2 id="prerequisites">Prerequisites</h2>

<p>To follow the example in this article, you will need:</p>

<ul>
<li>A Go workspace set up by following <a href="https://www.digitalocean.com/community/tutorial_series/how-to-install-and-set-up-a-local-programming-environment-for-go">How To Install Go and Set Up a Local Programming Environment</a>.</li>
</ul>

<h2 id="building-your-sample-application">Building Your Sample Application</h2>

<p>Before you can use <code>ldflags</code> to introduce dynamic data, you first need an application to insert the information into. In this step, you will make this application, which will at this stage only print static versioning information. Let&rsquo;s create that application now.</p>

<p>In your <code>src</code> directory, make a directory named after your application. This tutorial will use the application name <code><span class="highlight">app</span></code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir <span class="highlight">app</span>
</li></ul></code></pre>
<p>Change your working directory to this folder:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd <span class="highlight">app</span>
</li></ul></code></pre>
<p>Next, using the text editor of your choice, create the entry point of your program, <code>main.go</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano main.go
</li></ul></code></pre>
<p>Now, make your application print out version information by adding the following contents:</p>
<div class="code-label " title="app/main.go">app/main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import (
    "fmt"
)

var Version = "development"

func main() {
    fmt.Println("Version:\t", Version)
}
</code></pre>
<p>Inside of the <code>main()</code> function, you declared the <code>Version</code> variable, then printed the <a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-working-with-strings-in-go">string</a> <code>Version:</code>, followed by a tab character, <code>\t</code>, and then the declared variable.</p>

<p>At this point, the variable <code>Version</code> is defined as <code>development</code>, which will be the default version for this app. Later on, you will change this value to be an official version number, arranged according to <a href="https://semver.org/">semantic versioning format</a>.</p>

<p>Save and exit the file. Once this is done, build and run the application to confirm that it prints the correct version:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go build
</li><li class="line" prefix="$">./<span class="highlight">app</span>
</li></ul></code></pre>
<p>You will see the following output:</p>
<pre class="code-pre command"><code langs=""><div class="secondary-code-label " title="Output">Output</div><ul class="prefixed"><li class="line" prefix="$">Version:     development
</li></ul></code></pre>
<p>You now have an application that prints default version information, but you do not yet have a way to pass in current version information at build time. In the next step, you will use <code>-ldflags</code> and <code>go build</code> to solve this problem.</p>

<h2 id="using-ldflags-with-go-build">Using <code>ldflags</code> with <code>go build</code></h2>

<p>As mentioned before, <code>ldflags</code> stands for <em>linker flags</em>, and is used to pass in flags to the underlying linker in the Go toolchain. This works according to the following syntax:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go build -ldflags="-<span class="highlight">flag</span>"
</li></ul></code></pre>
<p>In this example, we passed in <code>flag</code> to the underlying <code>go tool link</code> command that runs as a part of <code>go build</code>. This command uses double quotes around the contents passed to <code>ldflags</code> to avoid breaking characters in it, or characters that the command line might interpret as something other than what we want. From here, you could pass in <a href="https://golang.org/cmd/link/">many different <code>link</code> flags</a>. For the purposes of this tutorial, we will use the <code>-X</code> flag to write information into the variable at link time, followed by the <a href="https://www.digitalocean.com/community/tutorials/importing-packages-in-go">package</a> path to the variable and its new value:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go build -ldflags="-X '<span class="highlight">package_path</span>.<span class="highlight">variable_name</span>=<span class="highlight">new_value</span>'"
</li></ul></code></pre>
<p>Inside the quotes, there is now the <code>-X</code> option and a <a href="https://www.digitalocean.com/community/tutorials/understanding-maps-in-go#keys-and-values">key-value pair</a> that represents the variable to be changed and its new value. The <code>.</code> character separates the package path and the variable name, and single quotes are used to avoid breaking characters in the key-value pair.</p>

<p>To replace the <code>Version</code> variable in your example application, use the syntax in the last command block to pass in a new value and build the new binary:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go build -ldflags="-X 'main.Version=v1.0.0'"
</li></ul></code></pre>
<p>In this command, <code>main</code> is the package path of the <code>Version</code> variable, since this variable is in the <code>main.go</code> file. <code>Version</code> is the variable that you are writing to, and <code>v1.0.0</code> is the new value.</p>

<p>In order to use <code>ldflags</code>, the value you want to change must exist and be a package level variable of type <code>string</code>. This variable can be either exported or unexported. The value cannot be a <code>const</code> or have its value set by the result of a function call. Fortunately, <code>Version</code> fits all of these requirements: It was already declared as a variable in the <code>main.go</code> file, and the current value (<code>development</code>) and the desired value (<code>v1.0.0</code>) are both strings.</p>

<p>Once your new <code><span class="highlight">app</span></code> binary is built, run the application:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">./<span class="highlight">app</span>
</li></ul></code></pre>
<p>You will receive the following output:</p>
<pre class="code-pre command"><code langs=""><div class="secondary-code-label " title="Output">Output</div><ul class="prefixed"><li class="line" prefix="$">Version:     <span class="highlight">v1.0.0</span>
</li></ul></code></pre>
<p>Using <code>-ldflags</code>, you have succesfully changed the <code>Version</code> variable from <code>development</code> to <code>v1.0.0</code>.</p>

<p>You have now modified a <code>string</code> variable inside of a simple application at build time. Using <code>ldflags</code>, you can embed version details, licensing information, and more into a binary ready for distribution, using only the command line. </p>

<p>In this example, the variable you changed was in the <code>main</code> program, reducing the difficulty of determining the path name. But sometimes the path to these variables is more complicated to find. In the next step, you will write values to variables in sub-packages to demonstrate the best way to determine more complex package paths.</p>

<h2 id="targeting-sub-package-variables">Targeting Sub-Package Variables</h2>

<p>In the last section, you manipulated the <code>Version</code> variable, which was at the top-level package of the application. But this is not always the case. Often it is more practical to place these variables in another package, since <code>main</code> is not an importable package. To simulate this in your example application, you will create a new sub-package, <code><span class="highlight">app</span>/build</code>, that will store information about the time the binary was built and the name of the user that issued the build command.</p>

<p>To add a new sub-package, first add a new directory to your project named <code>build</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir -p build
</li></ul></code></pre>
<p>Then create a new file named <code>build.go</code> to hold the new variables:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano build/build.go
</li></ul></code></pre>
<p>In your text editor, add new variables for <code>Time</code> and <code>User</code>:</p>
<div class="code-label " title="app/build/build.go">app/build/build.go</div><pre class="code-pre "><code class="code-highlight language-go">package build

var Time string

var User string
</code></pre>
<p>The <code>Time</code> variable will hold a string representation of the time when the binary was built. The <code>User</code> variable will hold the name of the user who built the binary. Since these two variables will always have values, you don&rsquo;t need to initialize these variables with default values like you did for <code>Version</code>.</p>

<p>Save and exit the file.</p>

<p>Next, open <code>main.go</code> to add these variables to your application:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano main.go
</li></ul></code></pre>
<p>Inside of <code>main.go</code>, add the following highlighted lines:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code langs="">package main

import (
    <span class="highlight">"app/build"</span>
    "fmt"
)

var Version = "development"

func main() {
    fmt.Println("Version:\t", Version)
    <span class="highlight">fmt.Println("build.Time:\t", build.Time)</span>
    <span class="highlight">fmt.Println("build.User:\t", build.User)</span>
}
</code></pre>
<p>In these lines, you first imported the <code><span class="highlight">app</span>/build</code> package, then printed <code>build.Time</code> and <code>build.User</code> in the same way you printed <code>Version</code>.</p>

<p>Save the file, then exit from your text editor.</p>

<p>Next, to target these variables with <code>ldflags</code>, you could use the import path <code><span class="highlight">app</span>/build</code> followed by <code>.User</code> or <code>.Time</code>, since you already know the import path. However, to simulate a more complex situation in which the path to the variable is not evident, let&rsquo;s instead use the <code>nm</code> command in the Go tool chain.</p>

<p>The <code>go tool nm</code> command will output the <em>symbols</em> involved in a given executable, object file, or archive. In this case, a symbol refers to an object in the code, such as a defined or imported variable or function. By generating a symbol table with <code>nm</code> and using <code>grep</code> to search for a variable, you can quickly find information about its path.</p>

<p><span class='note'><strong>Note:</strong> The <code>nm</code> command will not help you find the path of your variable if the package name has any non-<a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a> characters, or a <code>"</code> or <code>%</code> character, as that is a limitation of the tool itself.<br></span></p>

<p>To use this command, first build the binary for <code><span class="highlight">app</span></code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go build
</li></ul></code></pre>
<p>Now that <code><span class="highlight">app</span></code> is built, point the <code>nm</code> tool at it and search through the output:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go tool nm ./<span class="highlight">app</span> | grep <span class="highlight">app</span>
</li></ul></code></pre>
<p>When run, the <code>nm</code> tool will output a lot of data. Because of this, the preceding command used <code>|</code> to pipe the output to the <code>grep</code> command, which then searched for terms that had the top-level <code><span class="highlight">app</span></code> in the title.</p>

<p>You will receive output similar to this:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>  <span class="highlight">55d2c0 D app/build.Time</span>
  <span class="highlight">55d2d0 D app/build.User</span>
  4069a0 T runtime.appendIntStr
  462580 T strconv.appendEscapedRune
. . .
</code></pre>
<p>In this case, the first two lines of the result set contain the paths to the two variables you are looking for: <code><span class="highlight">app</span>/build.Time</code> and <code><span class="highlight">app</span>/build.User</code>.</p>

<p>Now that you know the paths, build the application again, this time changing <code>Version</code>, <code>User</code>, and <code>Time</code> at build time. To do this, pass multiple <code>-X</code> flags to <code>-ldflags</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go build -v -ldflags="-X 'main.Version=v1.0.0' -X 'app/build.User=$(id -u -n)' -X 'app/build.Time=$(date)'"
</li></ul></code></pre>
<p>Here you passed in the <code>id -u -n</code> Bash command to list the current user, and the <code>date</code> command to list the current date.</p>

<p>Once the executable is built, run the program:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">./<span class="highlight">app</span>
</li></ul></code></pre>
<p>This command, when run on a Unix system, will generate similar output to the following:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Version:     v1.0.0
build.Time:  <span class="highlight">Fri Oct  4 19:49:19 UTC 2019</span>
build.User:  <span class="highlight">sammy</span>
</code></pre>
<p>Now you have a binary that contains versioning and build information that can provide vital assistance in production when resolving issues.</p>

<h2 id="conclusion">Conclusion</h2>

<p>This tutorial showed how, when applied correctly, <code>ldflags</code> can be a powerful tool for injecting valuable information into binaries at build time. This way, you can control feature flags, environment information, versioning information, and more without introducing changes to your source code. By adding <code>ldflags</code> to your current build workflow you can maximize the benefits of Go&rsquo;s self-contained binary distribution format.</p>

<p>If you would like to learn more about the Go programming language, check out our full <a href="https://www.digitalocean.com/community/tutorial_series/how-to-code-in-go">How To Code in Go series</a>. If you are looking for more solutions for version control, try our <a href="https://www.digitalocean.com/community/tutorials/how-to-use-git-a-reference-guide">How To Use Git</a> reference guide.</p>
