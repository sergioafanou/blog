---
layout: post
title: Использование переменных и констант в Go
network: digitalocean
date: January 24, 2020 at 04:36AM
url: https://www.digitalocean.com/community/tutorials/how-to-use-variables-and-constants-in-go-ru
image: https://assets.digitalocean.com/articles/go_variables/variable1.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<p><em>Переменные</em> — это важная концепция программирования, которую необходимо освоить. Это символы, обозначающие определенные значения, используемые в программе.</p>

<p>В этом обучающем руководстве мы расскажем об основах работы с переменными и лучших практиках их использования в создаваемых вами программах Go.</p>

<h2 id="Что-такое-переменные">Что такое переменные</h2>

<p>С технической точки зрения переменная назначает место хранения значения, связанного с символическим именем или идентификатором. Имя переменной используется компьютерной программой, чтобы ссылаться на это сохраненное значение.</p>

<p>Переменную можно представить как ярлык с названием, прикрепляемый к значению.</p>

<p><img src="https://assets.digitalocean.com/articles/go_variables/variable1.png" alt="Переменные в Go"></p>

<p>Допустим, у нас есть число <code>1032049348</code>, и мы хотим сохранить его в переменной, а не вводить его каждый раз, когда оно потребуется. Для этого мы можем использовать запоминающееся имя, например переменную <code>i</code>. Для сохранения значения в переменной мы используем следующий синтаксис:</p>
<pre class="code-pre "><code class="code-highlight language-go">i := 1032049348
</code></pre>
<p>Эту переменную можно представить как ярлык, прикрепленный к значению.</p>

<p><img src="https://assets.digitalocean.com/articles/go_variables/variable2.png" alt="Пример переменной в Go"></p>

<p>На ярлыке указано название переменной <code>i</code>, и он прикреплен к значению переменной <code>1032049348</code>.</p>

<p>Фраза <code>i := 1032049348</code> представляет собой оператор декларации и присвоения, состоящий из нескольких частей:</p>

<ul>
<li>имя переменной (<code>i</code>)</li>
<li>короткая декларация переменной (<code>:=</code>)</li>
<li>значение, привязываемое к имени переменной (<code>1032049348</code>)</li>
<li>тип данных, подразумеваемый Go (<code>int</code>)</li>
</ul>

<p>В следующем разделе мы покажем, как явно задать тип.</p>

<p>Вместе эти компоненты составляют выражение, задающее переменную <code>i</code> как значение целого числа <code>1032049348</code>.</p>

<p>Когда мы задаем для переменной значение, мы <em>инициализируем</em> или создаем эту переменную. После этого мы можем сразу начать использовать переменную вместо значения.</p>

<p>Когда мы зададим для <code>i</code> значение <code>1032049348</code>, мы сможем использовать <code>i</code> вместо целого числа, так что давайте распечатаем эту переменную:</p>
<pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

func main() {
    i := 1032049348
    fmt.Println(i)
}
</code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>1032049348
</code></pre>
<p>С помощью переменных мы сможем быстро и легко выполнять математические операции. С <code>i := 1032049348</code> мы можем выполнить вычитание целочисленного значения <code>813</code>, используя следующий синтаксис:</p>
<pre class="code-pre "><code class="code-highlight language-go">fmt.Println(i - 813)
</code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>1032048535
</code></pre>
<p>В данном примере Go выполняет математические операции, вычитая 813 из переменной <code>i</code> для возврата суммы <code>1032048535</code>.</p>

<p>С математической точки зрения переменные можно задать равными результату математического уравнения. Также вы можете сложить два числа и сохранить значение суммы в форме переменной <code>x</code>:</p>
<pre class="code-pre "><code class="code-highlight language-go">x := 76 + 145
</code></pre>
<p>Возможно вы заметили, что этот пример напоминает алгебру. Мы используем буквы и другие символы как представление чисел и количеств в формулах и уравнениях. Точно так же мы используем переменные как символические обозначения значений типа данных. Для использования правильного синтаксиса Go необходимо убедиться, что переменная находится с левой стороны любых уравнений.</p>

<p>Распечатаем значение <code>x</code>:</p>
<pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

func main() {
    x := 76 + 145
    fmt.Println(x)
}
</code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>221
</code></pre>
<p>Go выводит значение <code>221</code>, поскольку переменная <code>x</code> была задана равной сумме чисел <code>76</code> и <code>145</code>.</p>

<p>Переменные могут представлять любой тип данных, а не только целые числа:</p>
<pre class="code-pre "><code class="code-highlight language-go">s := "Hello, World!"
f := 45.06
b := 5 &gt; 9 // A Boolean value will return either true or false
array := [4]string{"item_1", "item_2", "item_3", "item_4"}
slice := []string{"one", "two", "three"}
m := map[string]string{"letter": "g", "number": "seven", "symbol": "&amp;"}
</code></pre>
<p>При печати любой из этих переменных Go возвращает эквивалент соответствующей переменной. Используем выражение присвоения для строкового типа данных <code>slice</code>:</p>
<pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

func main() {
    slice := []string{"one", "two", "three"}
    fmt.Println(slice)
}
</code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>[one two three]
</code></pre>
<p>Мы назначим значение <code>[]string{"one", "two", "three"}</code> переменной <code>slice</code>, а затем используем функцию <code>fmt.Println</code> для вывода этого значения посредством вызова <code>slice</code>.</p>

<p>Переменные выделяют небольшую область памяти компьютера, которая принимает заданные значения, ассоциируемые с этой областью.</p>

<h2 id="Декларирование-переменных">Декларирование переменных</h2>

<p>В Go имеется несколько способов декларирования переменных, а иногда может существовать несколько способов декларирования одних и тех же переменных и значений.</p>

<p>Мы можем декларировать переменную <code>i</code> типа данных <code>int</code> без инициализации. Это означает, что мы декларируем пространство для размещения значения, но не задаем начальное значение:</p>
<pre class="code-pre "><code class="code-highlight language-go">var i int
</code></pre>
<p>Так мы создали декларированную переменную <code>i</code> типа данных <code>int</code>.</p>

<p>Мы можем инициализировать значение с помощью оператора равенства (<code>=),</code> как в предыдущем примере:</p>
<pre class="code-pre "><code class="code-highlight language-go">var i int = 1
</code></pre>
<p>Обе эти формы декларирования называются в Go <em>длинной декларацией переменной</em>.</p>

<p>Также мы можем использовать <em>короткую декларацию переменной</em>:</p>
<pre class="code-pre "><code class="code-highlight language-go">i := 1
</code></pre>
<p>В данном случае у нас имеются переменная <code>i</code> и тип данных <code>int</code>. Когда мы не указываем тип данных, Go подразумевает тип данных.</p>

<p>В связи с наличием трех способов декларирования переменных сообщество Go приняло следующие правила:</p>

<ul>
<li><p>Использовать длинную форму <code>var i int</code> только если переменная не инициализируется.</p></li>
<li><p>Использовать короткую форму <code>i := 1</code> при декларировании и инициализации.</p></li>
<li><p>Если вы не хотите, чтобы Go использовал подразумеваемый тип данных, но хотите использовать короткую декларацию переменной, вы можете заключить значение в желаемый тип, используя следующий синтаксис:</p></li>
</ul>
<pre class="code-pre "><code class="code-highlight language-go">i := int64(1)
</code></pre>
<p>Использование длинной формы декларации переменной при инициализации значений не является общепринятым в Go:</p>
<pre class="code-pre "><code class="code-highlight language-go">var i int = 1
</code></pre>
<p>Будет полезно следовать стандартной практике декларирования переменных, применяемой сообществом Go, чтобы другие пользователи могли легко читать ваши программы.</p>

<h2 id="Нулевые-значения">Нулевые значения</h2>

<p>Все встроенные типы имеют нулевые значения. Любую выделенную переменную можно использовать, даже если ей никогда не назначалось значение. Мы видим нулевые значения следующих типов:</p>
<pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

func main() {
    var a int
    var b string
    var c float64
    var d bool

    fmt.Printf("var a %T = %+v\n", a, a)
    fmt.Printf("var b %T = %q\n", b, b)
    fmt.Printf("var c %T = %+v\n", c, c)
    fmt.Printf("var d %T = %+v\n\n", d, d)
}
</code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>var a int =  0
var b string = ""
var c float64 = 0
var d bool = false
</code></pre>
<p>Мы использовали оператор <code>%T</code> в выражении <code>fmt.Printf</code>. Он предписывает функции вывести <code>тип данных</code> для переменной.</p>

<p>Поскольку в Go все значения имеют <code>нулевое</code> значение, у нас не может быть <code>неопределенных</code> значений, как в некоторых других языках. Например, в некоторых языках <a href="https://www.digitalocean.com/community/tutorials/understanding-data-types-in-go#booleans"><code>булево выражение</code></a> может иметь значение <code>undefined</code>, <code>true</code> или <code>false</code>, то есть переменная может иметь <code>три</code> состояния. В Go булево выражение не может иметь более <code>двух</code> состояний.</p>

<h2 id="Присвоение-имен-переменным-правила-и-стиль">Присвоение имен переменным: правила и стиль</h2>

<p>Присвоение имен переменных отличается гибкостью, однако необходимо помнить некоторые правила:</p>

<ul>
<li>Имена переменных могут состоять только из одного слова (без пробелов).</li>
<li>Имена переменных могут состоять только из букв, цифр и символов подчеркивания (<code>_</code>).</li>
<li>Имена переменных не могут начинаться с цифр.</li>
</ul>

<p>Следуя этим правилам, рассмотрим допустимые и недопустимые имена переменных:</p>

<table><thead>
<tr>
<th>Допустимо</th>
<th>Недопустимо</th>
<th>Причина недопустимости</th>
</tr>
</thead><tbody>
<tr>
<td><code>userName</code></td>
<td><code>user-name</code></td>
<td>Дефисы не разрешены</td>
</tr>
<tr>
<td><code>name4</code></td>
<td><code>4name</code></td>
<td>Не могут начинаться с цифры</td>
</tr>
<tr>
<td><code>user</code></td>
<td><code>$user</code></td>
<td>Не могут содержать символы</td>
</tr>
<tr>
<td><code>userName</code></td>
<td><code>user name</code></td>
<td>Не могут состоять из нескольких слов</td>
</tr>
</tbody></table>

<p>Также при присвоении имен переменным следует помнить, что в этих именах учитывается регистр. Имена <code>userName</code>, <code>USERNAME</code>, <code>UserName</code> и <code>uSERnAME</code> представляют совершенно разные переменные. Лучше всего избегать использования сходных имен переменных в программе, чтобы и вы, и ваши нынешние и будущие коллеги по разработке, могли понимать систему переменных.</p>

<p>В переменных учитывается регистр, однако регистр первой буквы имени переменной в Go имеет особое значение. Если имя переменной начинается с заглавной буквы, это означает, что данная переменная доступна за пределами пакета, где она была декларирована (<code>экспортируемая</code> переменная). Если имя переменной начинается со строчной буквы, она будет доступна только в том пакете, где она декларирована.</p>
<pre class="code-pre "><code class="code-highlight language-go">var Email string
var password string
</code></pre>
<p><code>Email</code> начинается с заглавной буквы и доступна в других пакетах, а <code>password</code> начинается со строчной буквы и доступна только в пакете, где она декларирована.</p>

<p>В Go часто используются очень короткие имена переменных. Если в качестве имени переменной можно использовать <code>userName</code> и <code>user</code>, согласно правилам будет правильно использовать вариант <code>user</code>.</p>

<p>Состав также имеет значение для краткости имени переменной. Как правило, чем меньше область существования переменной, тем короче имя переменной:</p>
<pre class="code-pre "><code class="code-highlight language-go">names := []string{"Mary", "John", "Bob", "Anna"}
for i, n := range names {
    fmt.Printf("index: %d = %q\n", i, n)
}
</code></pre>
<p>Мы используем переменную <code>names</code> в большей области, поэтому ей обычно присваивается более значимое имя, чтобы его было проще запомнить. Однако мы используем переменные <code>i</code> и <code>n</code> в следующей строчке кода, и не используем их после этого вообще. Это не помешает читать код и определять использование переменных или определять их значение.</p>

<p>Добавим несколько замечаний о стиле переменных. В состоящих из нескольких слов именах используется формат <code>MixedCaps</code> или <code>mixedCaps</code>, а не символы подчеркивания.</p>

<table><thead>
<tr>
<th>Стандартный стиль</th>
<th>Нестандартный стиль</th>
<th>Почему нестандартный</th>
</tr>
</thead><tbody>
<tr>
<td><code>userName</code></td>
<td><code>user_name</code></td>
<td>Символ подчеркивания нестандартный</td>
</tr>
<tr>
<td><code>i</code></td>
<td><code>index</code></td>
<td><code>i</code> предпочтительнее <code>index</code>, поскольку он короче</td>
</tr>
<tr>
<td><code>serveHttp</code></td>
<td><code>serveHttp</code></td>
<td>Аббревиатуры следует писать с заглавной буквы</td>
</tr>
</tbody></table>

<p>Для стиля очень важна согласованность, а также использование единого стиля всеми членами команды.</p>

<h2 id="Изменение-назначения-переменных">Изменение назначения переменных</h2>

<p>Как подразумевает слово «переменная», мы можем легко изменять переменные Go. Это означает, что мы можем связать другое значение с ранее назначенной переменной посредством переназначения. Возможность переназначения полезна, поскольку в ходе выполнения программы нам может понадобиться принимать генерируемые пользователем значения в уже инициализированных переменных. Также нам может потребоваться изменить назначение на что-то, что уже было определено ранее.</p>

<p>Знать о возможности переназначения переменных полезно при работе над большой программой, которую написал кто-то еще, и в которой неясно, какие переменные уже определены.</p>

<p>Присвоим значение <code>76</code> переменной <code>i</code> типа <code>int</code>, а затем назначим ей новое значение <code>42</code>:</p>
<pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

func main() {
    i := 76
    fmt.Println(i)

    i = 42
    fmt.Println(i)
}
</code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>76
42
</code></pre>
<p>В этом примере показано, что мы можем сначала назначить переменной <code>i</code> значение целого числа, а затем переназначить переменную <code>i</code>, назначив ей значение <code>42</code>.</p>

<p><span class='note'><strong>Примечание:</strong> при декларировании <strong>и</strong> инициализации переменных можно использовать оператор <code>:=</code>, однако если вы просто хотите изменить значение уже декларированной переменной, вам нужно использовать простой оператор равенства (<code>=</code>).<br></span></p>

<p>Поскольку язык Go <code>предусматривает определение типов данных</code>, мы не можем назначить один тип другому. Например, мы не можем назначить значение <code>"Sammy"</code> для переменной типа <code>int:</code></p>
<pre class="code-pre "><code class="code-highlight language-go">i := 72
i = "Sammy"
</code></pre>
<p>Попытка назначения разных типов друг другу вызовет ошибку при компиляции:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>cannot use "Sammy" (type string) as type int in assignment
</code></pre>
<p>Go не позволяет использовать имя переменной несколько раз:</p>
<pre class="code-pre "><code class="code-highlight language-go">var s string
var s string
</code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>s redeclared in this block
</code></pre>
<p>Если мы попытаемся использовать краткое декларирование переменной несколько раз для одного и того же имени переменной, мы также получим ошибку компиляции. Это может произойти случайно, поэтому важно понять, что означает сообщение об ошибке:</p>
<pre class="code-pre "><code class="code-highlight language-go">i := 5
i := 10
</code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>no new variables on left side of :=
</code></pre>
<p>Как и при декларировании переменных, присвоение переменным понятных имен повысит удобство чтения программы для вас и других разработчиков.</p>

<h2 id="Назначение-нескольких-параметров">Назначение нескольких параметров</h2>

<p>Go также позволяет присваивать несколько значений нескольким переменным в одной строке. Эти значения могут иметь разные типы данных:</p>
<pre class="code-pre "><code class="code-highlight language-go">j, k, l := "shark", 2.05, 15
fmt.Println(j)
fmt.Println(k)
fmt.Println(l)
</code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>shark
2.05
15
</code></pre>
<p>В этом примере переменной <code>j</code> присвоено строковое значение <code>"shark"</code>, переменной <code>k</code> присвоено значение с плавающей точкой <code>2.05</code>, а переменной <code>l</code> присвоено целочисленное значение <code>15</code>.</p>

<p>Такой подход с назначением нескольким переменным нескольких значений в одной строке позволяет сократить количество строк в программном коде. При этом важно не нарушать читаемость при уменьшении количества строк кода.</p>

<h2 id="Глобальные-и-локальные-переменные">Глобальные и локальные переменные</h2>

<p>При использовании переменных в программе важно учитывать <em>область действия переменной</em>. Область действия переменной означает конкретные места, откуда она доступна в коде определенной программы. Не все переменные доступны из всех частей программы. Некоторые переменные глобальные, а некоторые — локальные.</p>

<p>Глобальные переменные существуют вне функций. Локальные переменные существуют внутри функций.</p>

<p>Давайте посмотрим на глобальные и локальные переменные в действии:</p>
<pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"


var g = "global"

func printLocal() {
    l := "local"
    fmt.Println(l)
}

func main() {
    printLocal()
    fmt.Println(g)
}
</code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>local
global
</code></pre>
<p>Здесь мы используем <code>var g = "global"</code> для создания глобальной переменной вне функции. Затем мы определяем функцию <code>printLocal()</code>. Внутри функции назначается и выводится локальная переменная <code>l</code>. Программа завершает работу вызовом <code>printLocal()</code> и выводом локальной переменной <code>g</code>.</p>

<p>Поскольку <code>g</code> — глобальная переменная, мы можем ссылаться на нее в <code>printLocal()</code>. Для этого изменим предыдущую программу:</p>
<pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"


var g = "global"

func printLocal() {
    l := "local"
    fmt.Println(l)
    fmt.Println(g)
}

func main() {
    printLocal()
    fmt.Println(g)
}
</code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>local
global
global
</code></pre>
<p>Для начала мы декларируем глобальную переменную <code>g</code>, <code>var g = "global"</code>. В функции <code>main</code> мы вызываем функцию <code>printLocal</code>, которая декларирует локальную переменную <code>l</code> и выводит ее с помощью <code>fmt.Println(l)</code>. Затем <code>printLocal</code> выводит глобальную переменную <code>g</code>, <code>fmt.Println(g)</code>. Хотя переменная <code>g</code> не была определена внутри <code>printLocal</code>, она была доступна, поскольку декларировалась в глобальной области действия. В заключение функция <code>main</code> выводит <code>g</code>.</p>

<p>Теперь попробуем вызвать локальную переменную вне функции:</p>
<pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

var g = "global"

func printLocal() {
    l := "local"
    fmt.Println(l)
}

func main() {
    fmt.Println(l)
}

</code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>undefined: l
</code></pre>
<p>Локальную переменную нельзя использовать вне функции, в которой она назначена. Если мы попытаемся это сделать, при попытке компиляции будет выведено сообщение об ошибке <code>undefined</code>.</p>

<p>Давайте посмотрим на другой пример, где мы используем одинаковое имя для глобальной и локальной переменной:</p>
<pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

var num1 = 5

func printNumbers() {
    num1 := 10
    num2 := 7  

    fmt.Println(num1)
    fmt.Println(num2)
}

func main() {
    printNumbers()
    fmt.Println(num1)
}
</code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>10
7
5
</code></pre>
<p>В этой программе мы декларировали переменную <code>num1</code> дважды. Во первых, мы декларировали <code>num1</code> в глобальной области, <code>var num1 = 5</code>, а затем в локальной области функции <code>printNumbers</code>, <code>num1 := 10</code>. При выводе <code>num1</code> из программы <code>main</code> мы получаем значение <code>5</code>. Это связано с тем, что программа <code>main</code> видит только определенные глобальные переменные. Однако, когда мы выводим <code>num1</code> из функции <code>printNumbers</code>, она видит локальную декларацию и выводит значение <code>10</code>. Хотя <code>printNumbers</code> создает новую переменную с именем <code>num1</code> и ей присваивается значение <code>10</code>, это не влияет на глобальный экземпляр <code>num1</code> со значением <code>5</code>.</p>

<p>При работе с переменными также нужно учитывать, каким частям программы потребуется доступ к каждой переменной, и соответственно с этим использовать глобальные или локальные переменные. В программах Go вы видите, что локальные переменные встречаются чаще.</p>

<h2 id="Константы">Константы</h2>

<p>Константы похожи на переменные, однако они не могут быть изменены после декларирования. Константы полезны для определения значений, которые будут использоваться в программе многократно, но которые не должны быть изменяемыми.</p>

<p>Например, если мы хотим декларировать налоговую ставку для интернет-магазина, мы можем использовать константу и рассчитывать налог в разных частях нашей программы. Если в будущем ставка налога изменится, нам нужно будет изменить это значение только в одном месте в программе. Если бы мы использовали переменную, существовала бы вероятность случайного изменения значения в программе, что привело бы к неверному расчету.</p>

<p>Мы можем использовать следующий синтаксис для декларирования константы:</p>
<pre class="code-pre "><code class="code-highlight language-go">const shark = "Sammy"
fmt.Println(shark)
</code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Sammy
</code></pre>
<p>Если мы попытаемся изменить константу после декларирования, при компиляции возникнет ошибка:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>cannot assign to shark
</code></pre>
<p>Константы могут быть <code>нетипированными</code>. Это может быть полезно при работе с числами, например, с целочисленными данными. Если константа <code>нетипированная</code>, она явно конвертируется, а с <code>типированными</code> константами этого не происходит. Посмотрим, как мы можем использовать константы:</p>
<pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

const (
    year     = 365
    leapYear = int32(366)
)

func main() {
    hours := 24
    minutes := int32(60)
    fmt.Println(hours * year)    
    fmt.Println(minutes * year)   
    fmt.Println(minutes * leapYear)
}
</code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>8760
21900
21960
</code></pre>
<p>Если вы декларируете константу с типом, это будет точный тип. Здесь, если мы декларируем константу <code>leapYear</code>, мы определяем ее как тип данных <code>int32</code>. Это <code>типированная</code> константа, то есть она может работать только с типами данных <code>int32</code>. Декларируемая нами константа <code>year</code> не имеет типа, и поэтому считается <code>нетипированной</code>. Поэтому вы сможете использовать ее с любым типом целочисленных данных.</p>

<p>При определении <code>hours</code> <em>подразумевался</em> тип <code>int</code>, поскольку мы явно не присвоили тип, <code>hours := 24</code>. При декларировании <code>minutes</code> мы явно определили тип <code>int32</code>, <code>minutes := int32(60)</code>.</p>

<p>Теперь внимательно изучим каждый расчет и определим, почему он работает:</p>
<pre class="code-pre "><code class="code-highlight language-go">hours * year
</code></pre>
<p>В данном случае <code>hours</code> имеет тип <code>int</code>, а <code>years</code> — <em>нетипированная</em> величина. При компиляции программы явно выполняется конвертация <code>years</code> в <code>int</code>, благодаря чему операция умножения успешно выполняется.</p>
<pre class="code-pre "><code class="code-highlight language-go">minutes * year
</code></pre>
<p>В данном случае <code>minutes</code> имеет тип <code>int32</code>, а <code>year</code> — <em>нетипированная</em> величина. При компиляции программы явно выполняется конвертация <code>years</code> в <code>int32</code>, благодаря чему операция умножения успешно выполняется.</p>
<pre class="code-pre "><code class="code-highlight language-go">minutes * leapYear
</code></pre>
<p>В данном случае <code>minutes</code> имеет тип <code>int32</code>, а <code>leapYear</code> — <em>типированная</em> константа <code>int32</code>. Здесь компилятору не нужно ничего делать, поскольку обе переменные уже относятся к одному типу.</p>

<p>Если мы попытаемся выполнить умножение двух типированных <code>типов</code>, которые не совместимы друг с другом, компиляция не будет выполнена:</p>
<pre class="code-pre "><code class="code-highlight language-go">fmt.Println(hours * leapYear)
</code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>invalid operation: hours * leapYear (mismatched types int and int32)
</code></pre>
<p>В данном случае <code>hours</code> подразумевается как <code>int</code>, а <code>leapYear</code> явно декларируется как <code>int32</code>. Поскольку Go — типированный язык, <code>int</code> и <code>int32</code> несовместимы в математических операциях. Для их умножения потребуется <a href="https://www.digitalocean.com/community/tutorials/how-to-convert-data-types-in-go#converting-number-types">конвертировать один из них в тип <code>int32</code> или <code>int</code></a>.</p>

<h2 id="Заключение">Заключение</h2>

<p>В этом обучающем модуле мы рассмотрели несколько распространенных примеров использования переменных в Go. Переменные — важный элемент программирования. Это символы, заменяющие значения типа данных, используемого нами в программе.</p>
