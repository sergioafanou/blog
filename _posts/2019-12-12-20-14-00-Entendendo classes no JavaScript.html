---
layout: post
title: Entendendo classes no JavaScript
network: digitalocean
date: December 12, 2019 at 08:14PM
url: https://www.digitalocean.com/community/tutorials/understanding-classes-in-javascript-pt
image: http://ifttt.com/images/no_image_card.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="introdução">Introdução</h3>

<p>O JavaScript é uma linguagem baseada em protótipo, e cada objeto no JavaScript tem uma propriedade interna escondida chamada <code>[[Prototype]]</code>, que pode ser usada para estender as propriedades e métodos de objetos. Você pode ler mais sobre protótipos no nosso tutorial <a href="https://www.digitalocean.com/community/tutorials/understanding-prototypes-and-inheritance-in-javascript">Entendendo protótipos e herança no JavaScript</a>.</p>

<p>Até recentemente, os desenvolvedores criativos usavam <a href="https://www.digitalocean.com/community/tutorials/understanding-prototypes-and-inheritance-in-javascript#constructor-functions">funções de construção</a> para imitar um padrão de design orientado a objeto no JavaScript. A especificação de linguagem ECMAScript 2015, frequentemente chamada de ES6, introduziu classes na linguagem JavaScript. As classes no JavaScript não oferecem, de fato, funcionalidades adicionais e são muitas vezes descritas como provedoras de &ldquo;açúcar sintático&rdquo; em relação a protótipos e herança, sendo que estes oferecem uma sintaxe mais limpa e mais elegante. Uma vez que outras linguagens de programação usam classes, a sintaxe de classe no JavaScript torna a coisa mais simples para que desenvolvedores consigam transitar entre linguagens.</p>

<h2 id="classes-são-funções">Classes são funções</h2>

<p>Uma classe do JavaScript é um tipo de função. As classes são declaradas com a palavra-chave <code>class</code>. Vamos usar a sintaxe de expressão de função para inicializar uma função e a sintaxe de expressão de classe para inicializar uma classe.</p>
<pre class="code-pre  second-environment"><code class="code-highlight language-js">// Initializing a function with a function expression
const x = function() {}
</code></pre><pre class="code-pre  fourth-environment"><code class="code-highlight language-js">// Initializing a class with a class expression
const y = class {}
</code></pre>
<p>Podemos acessar o <code>[[Prototype]]</code> de um objeto usando o método <a href="https://www.digitalocean.com/community/tutorials/understanding-prototypes-and-inheritance-in-javascript#javascript-prototypes"><code>Object.getPrototypeOf()</code></a>. Vamos usar isso para testar a <strong>função</strong> vazia que criamos.</p>
<pre class="code-pre  second-environment"><code class="code-highlight language-js">Object.getPrototypeOf(x);
</code></pre><pre class="code-pre  second-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>ƒ () { [native code] }
</code></pre>
<p>Também podemos usar esse método na <strong>classe</strong> que acabamos de criar.</p>
<pre class="code-pre  fourth-environment"><code class="code-highlight language-js">Object.getPrototypeOf(y);
</code></pre><pre class="code-pre  fourth-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>ƒ () { [native code] }
</code></pre>
<p>Ambos os código declarados com <code>function</code> e <code>class</code> retornam uma função <code>[[Prototype]]</code>. Com protótipos, qualquer função pode se tornar uma instância de construção usando a palavra-chave <code>new</code>.</p>
<pre class="code-pre  second-environment"><code class="code-highlight language-js">const x = function() {}

// Initialize a constructor from a function
const constructorFromFunction = new x();

console.log(constructorFromFunction);
</code></pre><pre class="code-pre  second-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>x {}
constructor: ƒ ()
</code></pre>
<p>Isso também se aplica às classes.</p>
<pre class="code-pre  fourth-environment"><code class="code-highlight language-js">const y = class {}

// Initialize a constructor from a class
const constructorFromClass = new y();

console.log(constructorFromClass);
</code></pre><pre class="code-pre  fourth-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>y {}
constructor: class
</code></pre>
<p>Estes exemplos de construtores de protótipo estão aparentemente vazios, mas podemos ver que sob a sintaxe, ambos os métodos estão alcançando o mesmo resultado final.</p>

<h2 id="definindo-uma-classe">Definindo uma classe</h2>

<p>No <a href="https://www.digitalocean.com/community/tutorials/understanding-prototypes-and-inheritance-in-javascript#constructor-functions">tutorial de protótipos e herança</a>, criamos um exemplo baseado na criação de personagens em um jogo RPG baseado em texto. Vamos continuar com esse exemplo para atualizar a sintaxe de funções para classes.</p>

<p>Uma <strong>função de construção</strong> é inicializada com um número de parâmetros que seriam atribuídos como propriedades de <code>this</code>, referindo-se à função em si. A primeira letra do identificador seria maiúscula por convenção.</p>
<div class="code-label " title="constructor.js">constructor.js</div><pre class="code-pre  second-environment"><code class="code-highlight language-js">// Initializing a constructor function
function Hero(name, level) {
    this.name = name;
    this.level = level;
}
</code></pre>
<p>Quando traduzimos isso para a sintaxe <strong>classe</strong> mostrada abaixo, vemos que ela está estruturada de maneira similar.</p>
<div class="code-label " title="class.js">class.js</div><pre class="code-pre  fourth-environment"><code class="code-highlight language-js">// Initializing a class definition
class Hero {
    constructor(name, level) {
        this.name = name;
        this.level = level;
    }
}
</code></pre>
<p>Sabemos que uma função de construção é destinada a ser um projeto de objeto pela primeira letra do inicializador ser maiúscula (o que é opcional) e através da familiaridade com a sintaxe. A palavra-chave <code>class</code> comunica de maneira mais simples o objetivo da nossa função.</p>

<p>A única diferença na sintaxe de inicialização é usar a palavra-chave <code>class</code> ao invés de <code>function</code>, e atribuir as propriedades dentro de um método <code>constructor()</code>.</p>

<h2 id="definindo-métodos">Definindo métodos</h2>

<p>Uma prática comum com funções de construção é atribuir métodos diretamente ao <code>prototype</code> ao invés da inicialização, como visto no método <code>greet()</code> abaixo.</p>
<div class="code-label " title="constructor.js">constructor.js</div><pre class="code-pre  second-environment"><code class="code-highlight language-js">function Hero(name, level) {
    this.name = name;
    this.level = level;
}

// Adding a method to the constructor
Hero.prototype.greet = function() {
    return `${this.name} says hello.`;
}
</code></pre>
<p>Com classes, esta sintaxe é simplificada e o método pode ser adicionado diretamente à classe. Ao usar a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions">forma abreviada da definição do método</a> introduzida como sendo ES6, definir um método é um processo ainda mais conciso.</p>
<div class="code-label " title="class.js">class.js</div><pre class="code-pre  fourth-environment"><code class="code-highlight language-js">class Hero {
    constructor(name, level) {
        this.name = name;
        this.level = level;
    }

    // Adding a method to the constructor
    greet() {
        return `${this.name} says hello.`;
    }
}
</code></pre>
<p>Vamos ver essas propriedades e métodos em ação. Criaremos uma nova instância <code>Hero</code> usando a palavra-chave <code>new</code> e atribuiremos alguns valores.</p>
<pre class="code-pre  fourth-environment"><code class="code-highlight language-js">const hero1 = new Hero('Varg', 1);
</code></pre>
<p>Se imprimirmos mais informações sobre nosso novo objeto com <code>console.log(hero1)</code>, podemos ver mais detalhes sobre o que está acontecendo com a inicialização da classe.</p>
<pre class="code-pre  fourth-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>Hero {name: "Varg", level: 1}
__proto__:
  ▶ constructor: class Hero
  ▶ greet: ƒ greet()
</code></pre>
<p>Podemos ver no resultado que as funções <code>constructor()</code> e <code>greet()</code> foram aplicadas ao <code>__proto__</code>, ou <code>[[Prototype]]</code> do <code>hero1</code>, e não diretamente como um método no objeto <code>hero1</code>. Embora isso seja claro ao criar funções de construção, não é óbvio ao criar classes. As classes permitem uma sintaxe mais simples e sucinta, mas sacrifica um pouco de clareza no processo.</p>

<h2 id="estendendo-uma-classe">Estendendo uma classe</h2>

<p>Uma característica vantajosa de funções de construção e classes é que elas podem ser estendidas para novos projetos de objeto baseados no pai. Isso impede a repetição de código para objetos semelhantes, mas precisa de algumas características adicionais ou mais específicas.</p>

<p>Novas funções de construção podem ser criadas a partir do pai usando o método <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call"><code>call()</code></a>. No exemplo abaixo, vamos criar uma classe de personagens mais específica chamada <code>Mage</code> e atribuir as propriedades de <code>Hero</code> a ela usando o <code>call()</code>, assim como adicionar uma propriedade adicional.</p>
<div class="code-label " title="constructor.js">constructor.js</div><pre class="code-pre  second-environment"><code class="code-highlight language-js">// Creating a new constructor from the parent
function Mage(name, level, spell) {
    // Chain constructor with call
    Hero.call(this, name, level);

    this.spell = spell;
}
</code></pre>
<p>Neste ponto, podemos criar uma nova instância de <code>Mage</code> usando as mesmas propriedades que o <code>Hero</code> assim como uma nova que adicionamos.</p>
<pre class="code-pre  second-environment"><code class="code-highlight language-js">const hero2 = new Mage('Lejon', 2, 'Magic Missile');
</code></pre>
<p>Ao enviar <code>hero2</code> para o console, podemos ver que criamos um novo <code>Mage</code> baseado no construtor.</p>
<pre class="code-pre  second-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>Mage {name: "Lejon", level: 2, spell: "Magic Missile"}
__proto__:
    ▶ constructor: ƒ Mage(name, level, spell)
</code></pre>
<p>Com classes ES6, a palavra-chave <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super"><code>super</code></a> é usada no lugar de <code>call</code> para acessar as funções do pai. Vamos usar <code>extends</code> para nos referir à classe pai.</p>
<div class="code-label " title="class.js">class.js</div><pre class="code-pre  fourth-environment"><code class="code-highlight language-js">// Creating a new class from the parent
class Mage extends Hero {
    constructor(name, level, spell) {
        // Chain constructor with super
        super(name, level);

        // Add a new property
        this.spell = spell;
    }
}
</code></pre>
<p>Agora, podemos criar uma nova instância <code>Mage</code> da mesma maneira.</p>
<pre class="code-pre  fourth-environment"><code class="code-highlight language-js">const hero2 = new Mage('Lejon', 2, 'Magic Missile');
</code></pre>
<p>Vamos imprimir <code>hero2</code> para o console e visualizar o resultado.</p>
<pre class="code-pre  fourth-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>Mage {name: "Lejon", level: 2, spell: "Magic Missile"}
__proto__: Hero
    ▶ constructor: class Mage
</code></pre>
<p>O resultado é quase exatamente o mesmo, exceto que na construção de classes o <code>[[Prototype]]</code> está ligado ao pai, neste caso, <code>Hero</code>.</p>

<p>Abaixo está uma comparação lado a lado do processo inteiro de inicialização, adição de métodos e herança de uma função de construção e uma classe.</p>
<div class="code-label " title="constructor.js">constructor.js</div><pre class="code-pre  second-environment"><code class="code-highlight language-js">function Hero(name, level) {
    this.name = name;
    this.level = level;
}

// Adding a method to the constructor
Hero.prototype.greet = function() {
    return `${this.name} says hello.`;
}

// Creating a new constructor from the parent
function Mage(name, level, spell) {
    // Chain constructor with call
    Hero.call(this, name, level);

    this.spell = spell;
}
</code></pre><div class="code-label " title="class.js">class.js</div><pre class="code-pre  fourth-environment"><code class="code-highlight language-js">// Initializing a class
class Hero {
    constructor(name, level) {
        this.name = name;
        this.level = level;
    }

    // Adding a method to the constructor
    greet() {
        return `${this.name} says hello.`;
    }
}

// Creating a new class from the parent
class Mage extends Hero {
    constructor(name, level, spell) {
        // Chain constructor with super
        super(name, level);

        // Add a new property
        this.spell = spell;
    }
}
</code></pre>
<p>Embora a sintaxe seja bastante diferente, o resultado fundamental é quase idêntico entre ambos os métodos. As classes dão-nos uma maneira mais concisa de criar plantas de objetos e as funções de construção descrevem com maior precisão o que está acontecendo nas entrelinhas.</p>

<h2 id="conclusão">Conclusão</h2>

<p>Neste tutorial, aprendemos sobre as semelhanças e diferenças entre funções de construção e classes ES6 do JavaScript. Ambas classes e funções de construção imitam um modelo de herança orientado a objeto para JavaScript, que é uma linguagem de herança baseada em protótipo.</p>

<p>Compreender a herança prototípica é fundamental para ser um desenvolvedor eficaz do JavaScript. Estar familiarizado com classes é extremamente útil, já que as bibliotecas populares do JavaScript como a <a href="https://reactjs.org/">React</a> fazem uso frequente da sintaxe <code>class</code>.</p>
