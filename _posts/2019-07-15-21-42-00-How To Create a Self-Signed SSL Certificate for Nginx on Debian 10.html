---
layout: post
title: How To Create a Self-Signed SSL Certificate for Nginx on Debian 10
network: digitalocean
date: July 15, 2019 at 09:42PM
url: https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-nginx-on-debian-10
image: https://assets.digitalocean.com/articles/nginx_ssl_1604/self_signed_warning.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="introduction">Introduction</h3>

<p><em>TLS</em>, or transport layer security, and its predecessor <em>SSL</em>, which stands for secure sockets layer, are web protocols used to wrap normal traffic in a protected, encrypted wrapper.</p>

<p>Using this technology, servers can send traffic safely between the server and clients without the possibility of the messages being intercepted by outside parties. The certificate system also assists users in verifying the identity of the sites that they are connecting with.</p>

<p>In this guide, we will show you how to set up a self-signed SSL certificate for use with an Nginx web server on a Debian 10 server.</p>

<span class='note'><p>
<strong>Note:</strong> A self-signed certificate will encrypt communication between your server and any clients. However, because it is not signed by any of the trusted certificate authorities included with web browsers, users cannot use the certificate to validate the identity of your server automatically.</p>

<p>A self-signed certificate may be appropriate if you do not have a domain name associated with your server and for instances where the encrypted web interface is not user-facing. If you <em>do</em> have a domain name, in many cases it is better to use a CA-signed certificate. To learn how to set up a free trusted certificate with the Let's Encrypt project, consult <a href="https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-debian-10">How to Secure Nginx with Let’s Encrypt on Debian 10</a>.<br></p></span>

<h2 id="prerequisites">Prerequisites</h2>

<ul>
<li>One Debian 10 server, a non-root user with <code>sudo</code> privileges, and an active firewall. To set these things up, follow the <a href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-debian-10">initial server setup for Debian 10</a> tutorial.</li>
<li>Nginx installed on your server, following <a href="https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-debian-10">How to Install Nginx on Debian 10</a>.</li>
</ul>

<h2 id="step-1-—-creating-the-ssl-certificate">Step 1 — Creating the SSL Certificate</h2>

<p>TLS/SSL works by using a combination of a public certificate and a private key. The SSL key is kept secret on the server and is used to encrypt content sent to clients. The SSL certificate is publicly shared with anyone requesting the content. It can be used to decrypt the content signed by the associated SSL key.</p>

<p>We can create a self-signed key and certificate pair with OpenSSL in a single command:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/nginx-selfsigned.key -out /etc/ssl/certs/nginx-selfsigned.crt
</li></ul></code></pre>
<p>You will be asked a series of questions. Before we go over that, let's take a look at what is happening in the command we are issuing:</p>

<ul>
<li><strong>openssl</strong>: This is the basic command line tool for creating and managing OpenSSL certificates, keys, and other files.</li>
<li><strong>req</strong>: This subcommand specifies that we want to use X.509 certificate signing request (CSR) management. The "X.509" is a public key infrastructure standard that SSL and TLS adheres to for its key and certificate management. We want to create a new X.509 cert, so we are using this subcommand.</li>
<li><strong>-x509</strong>: This further modifies the previous subcommand by telling the utility that we want to make a self-signed certificate instead of generating a certificate signing request, as would normally happen.</li>
<li><strong>-nodes</strong>: This tells OpenSSL to skip the option to secure our certificate with a passphrase. We need Nginx to be able to read the file without user intervention when the server starts up. A passphrase would prevent this from happening because we would have to enter it after every restart.</li>
<li><strong>-days 365</strong>: This option sets the length of time that the certificate will be considered valid. We set it for one year here.</li>
<li><strong>-newkey rsa:2048</strong>: This specifies that we want to generate a new certificate and a new key at the same time. We did not create the key that is required to sign the certificate in a previous step, so we need to create it along with the certificate. The <code>rsa:2048</code> portion tells it to make an RSA key that is 2048 bits long.</li>
<li><strong>-keyout</strong>: This line tells OpenSSL where to place the generated private key file that we are creating.</li>
<li><strong>-out</strong>: This tells OpenSSL where to place the certificate that we are creating.</li>
</ul>

<p>As we stated above, these options will create both a key file and a certificate. We will be asked a few questions about our server in order to embed the information correctly in the certificate.</p>

<p>Fill out the prompts appropriately. <strong>The most important line is the one that requests the <code>Common Name (e.g. server FQDN or YOUR name)</code>. You need to enter the domain name associated with your server or your server's public IP address.</strong></p>

<p>The entirety of the prompts will look something like this:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Country Name (2 letter code) [AU]:<span class="highlight">US</span>
State or Province Name (full name) [Some-State]:<span class="highlight">New York</span>
Locality Name (eg, city) []:<span class="highlight">New York City</span>
Organization Name (eg, company) [Internet Widgits Pty Ltd]:<span class="highlight">Bouncy Castles, Inc.</span>
Organizational Unit Name (eg, section) []:<span class="highlight">Ministry of Water Slides</span>
Common Name (e.g. server FQDN or YOUR name) []:<span class="highlight">your_domain_or_server_IP_address</span>
Email Address []:<span class="highlight">admin@your_domain.com</span>
</code></pre>
<p>Both of the files you created will be placed in the appropriate subdirectories of the <code>/etc/ssl</code> directory.</p>

<p>While we are using OpenSSL, we should also create a strong Diffie-Hellman group, which is used in negotiating <a href="https://en.wikipedia.org/wiki/Forward_secrecy">Perfect Forward Secrecy</a> with clients.</p>

<p>We can do this by typing:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo openssl dhparam -out /etc/nginx/dhparam.pem 4096
</li></ul></code></pre>
<p>This will take a while, but when it's done you will have a strong DH group at <code>/etc/nginx/dhparam.pem</code> that you can use in your configuration.</p>

<h2 id="step-2-—-configuring-nginx-to-use-ssl">Step 2 — Configuring Nginx to Use SSL</h2>

<p>We have created our key and certificate files under the <code>/etc/ssl</code> directory. Now we just need to modify our Nginx configuration to take advantage of these.</p>

<p>We will make a few adjustments to our configuration.</p>

<ol>
<li> We will create a configuration snippet containing our SSL key and certificate file locations.</li>
<li> We will create a configuration snippet containing strong SSL settings that can be used with any certificates in the future.</li>
<li> We will adjust our Nginx server blocks to handle SSL requests and use the two snippets above.</li>
</ol>

<p>This method of configuring Nginx will allow us to keep clean server blocks and put common configuration segments into reusable modules.</p>

<h3 id="creating-a-configuration-snippet-pointing-to-the-ssl-key-and-certificate">Creating a Configuration Snippet Pointing to the SSL Key and Certificate</h3>

<p>First, let's create a new Nginx configuration snippet in the <code>/etc/nginx/snippets</code> directory.</p>

<p>To properly distinguish the purpose of this file, let's call it <code>self-signed.conf</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nano /etc/nginx/snippets/self-signed.conf
</li></ul></code></pre>
<p>Within this file, we need to set the <code>ssl_certificate</code> directive to our certificate file and the <code>ssl_certificate_key</code> to the associated key. Add the following lines to the file:</p>
<div class="code-label " title="/etc/nginx/snippets/self-signed.conf">/etc/nginx/snippets/self-signed.conf</div><pre class="code-pre "><code langs="">ssl_certificate /etc/ssl/certs/nginx-selfsigned.crt;
ssl_certificate_key /etc/ssl/private/nginx-selfsigned.key;
</code></pre>
<p>When you've added those lines, save and close the file.</p>

<h3 id="creating-a-configuration-snippet-with-strong-encryption-settings">Creating a Configuration Snippet with Strong Encryption Settings</h3>

<p>Next, we will create another snippet that will define some SSL settings. This will set Nginx up with a strong SSL cipher suite and enable some advanced features that will help keep our server secure.</p>

<p>The parameters we will set can be reused in future Nginx configurations, so we will give the file a generic name:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nano /etc/nginx/snippets/ssl-params.conf
</li></ul></code></pre>
<p>To set up Nginx SSL securely, we will be using the recommendations by Remy van Elst on the <a href="https://cipherli.st"><strong>Cipherli.st</strong></a> site. This site is designed to provide easy-to-consume encryption settings for popular software.</p>

<span class='note'><p>
<strong>Note:</strong> The suggested settings on the <strong>Cipherli.st</strong> site offer strong security. Sometimes this comes at the cost of greater client compatibility. If you need to support older clients, there is an alternative list that you can access by clicking the link on the page labeled <strong>Yes, give me a ciphersuite that works with legacy / old software.</strong> That list can be substituted for the items below.</p>

<p>The choice of which config you use will depend largely on what you need to support. They both will provide great security.<br></p></span>

<p>For our purposes, we can copy the provided settings in their entirety. We just need to make a few small modifications.</p>

<p>First, we will add our preferred DNS resolver for upstream requests. We will use Google's for this guide.</p>

<p>Second, we will comment out the line that sets the strict transport security header. Before uncommenting this line, you should take take a moment to read up on <a href="https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security">HTTP Strict Transport Security, or HSTS</a>, and specifically its <a href="https://hstspreload.org/">"preload" functionality</a>. Preloading HSTS provides increased security, but can have far-reaching consequences if accidentally enabled or enabled incorrectly.</p>

<p>Copy the following into your <code>ssl-params.conf</code> snippet file:</p>
<div class="code-label " title="/etc/nginx/snippets/ssl-params.conf">/etc/nginx/snippets/ssl-params.conf</div><pre class="code-pre "><code langs="">ssl_protocols TLSv1.2;
ssl_prefer_server_ciphers on;
ssl_dhparam /etc/nginx/dhparam.pem;
ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384;
ssl_ecdh_curve secp384r1; # Requires nginx &gt;= 1.1.0
ssl_session_timeout  10m;
ssl_session_cache shared:SSL:10m;
ssl_session_tickets off; # Requires nginx &gt;= 1.5.9
ssl_stapling on; # Requires nginx &gt;= 1.3.7
ssl_stapling_verify on; # Requires nginx =&gt; 1.3.7
resolver 8.8.8.8 8.8.4.4 valid=300s;
resolver_timeout 5s;
# Disable strict transport security for now. You can uncomment the following
# line if you understand the implications.
# add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload";
add_header X-Frame-Options DENY;
add_header X-Content-Type-Options nosniff;
add_header X-XSS-Protection "1; mode=block";
</code></pre>
<p>Because we are using a self-signed certificate, SSL stapling will not be used. Nginx will output a warning but continue to operate correctly.</p>

<p>Save and close the file when you are finished.</p>

<h3 id="adjusting-the-nginx-configuration-to-use-ssl">Adjusting the Nginx Configuration to Use SSL</h3>

<p>Now that we have our snippets, we can adjust our Nginx configuration to enable SSL.</p>

<p>We will assume in this guide that you are using a custom server block configuration file in the <code>/etc/nginx/sites-available</code> directory, as outlined in <a href="https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-debian-10#step-5-%E2%80%93-setting-up-server-blocks">Step 5</a> of the prerequisite tutorial on installing Nginx. We will use <code>/etc/nginx/sites-available/<span class="highlight">your_domain</span></code> for this example. Substitute your configuration filename/domain name as needed.</p>

<p>Before we go any further, let's back up our current configuration file:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo cp /etc/nginx/sites-available/<span class="highlight">your_domain</span> /etc/nginx/sites-available/<span class="highlight">your_domain</span>.bak
</li></ul></code></pre>
<p>Now, open the configuration file to make adjustments:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nano /etc/nginx/sites-available/<span class="highlight">your_domain</span>
</li></ul></code></pre>
<p>If you followed the prerequisites, your server block will look like this:</p>
<div class="code-label " title="/etc/nginx/sites-available/your_domain">/etc/nginx/sites-available/your_domain</div><pre class="code-pre "><code langs="">server {
    listen 80;
    listen [::]:80;

    root /var/www/<span class="highlight">your_domain</span>/html;
    index index.html index.htm index.nginx-debian.html;

    server_name <span class="highlight">your_domain</span> www.<span class="highlight">your_domain</span>;

    location / {
            try_files $uri $uri/ =404;
    }

}
</code></pre>
<p>Your file may be in a different order, and instead of the <code>root</code> and <code>index</code> directives you may have some <code>location</code>, <code>proxy_pass</code>, or other custom configuration statements. This is ok, as we only need to update the <code>listen</code> directives and include our SSL snippets. We will modify this existing server block to serve SSL traffic on port <code>443</code>, and then create a new server block to respond on port <code>80</code> and automatically redirect traffic to port <code>443</code>.</p>

<p><span class='note'><strong>Note:</strong> We will use a 302 redirect until we have verified that everything is working properly. Afterwards, we can change this to a permanent 301 redirect.<br></span></p>

<p>In your existing configuration file, update the two <code>listen</code> statements to use port <code>443</code> and SSL, and then include the two snippet files we created in previous steps:</p>
<div class="code-label " title="/etc/nginx/sites-available/your_domain">/etc/nginx/sites-available/your_domain</div><pre class="code-pre "><code langs="">server {
    listen <span class="highlight">443 ssl</span>;
    listen [::]:<span class="highlight">443 ssl</span>;
    <span class="highlight">include snippets/self-signed.conf;</span>
    <span class="highlight">include snippets/ssl-params.conf;</span>

    root /var/www/<span class="highlight">your_domain</span>/html;
    index index.html index.htm index.nginx-debian.html;

    server_name <span class="highlight">your_domain</span> www.<span class="highlight">your_domain</span>;

    . . .
}
</code></pre>
<p>Next, paste a second server block into the configuration file, after the closing bracket (<code>}</code>) of the first block:</p>
<div class="code-label " title="/etc/nginx/sites-available/your_domain">/etc/nginx/sites-available/your_domain</div><pre class="code-pre "><code langs="">. . .
server {
    listen 80;
    listen [::]:80;

    server_name <span class="highlight">your_domain</span> www.<span class="highlight">your_domain</span>;

    return 302 https://$server_name$request_uri;
}
</code></pre>
<p>This is a bare-bones configuration that listens on port <code>80</code> and performs the redirect to HTTPS. Save and close the file when you are finished editing.</p>

<h2 id="step-3-—-adjusting-the-firewall">Step 3 — Adjusting the Firewall</h2>

<p>If you have the <code>ufw</code> firewall enabled, as recommended by the prerequisite guides, you'll need to adjust the settings to allow for SSL traffic. Luckily, Nginx registers a few profiles with <code>ufw</code> upon installation.</p>

<p>We can see the available profiles by typing:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo ufw app list
</li></ul></code></pre>
<p>You should see a list like this:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Available applications:
. . .
  Nginx Full
  Nginx HTTP
  Nginx HTTPS
. . .
</code></pre>
<p>You can see the current setting by typing:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo ufw status
</li></ul></code></pre>
<p>If you followed the prerequisites, it will look like this, meaning that only HTTP traffic is allowed to the web server:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Status: active

To                         Action      From
--                         ------      ----
OpenSSH                    ALLOW       Anywhere
Nginx HTTP                 ALLOW       Anywhere
OpenSSH (v6)               ALLOW       Anywhere (v6)
Nginx HTTP (v6)            ALLOW       Anywhere (v6)
</code></pre>
<p>To additionally let in HTTPS traffic, we can allow the "Nginx Full" profile and then delete the redundant "Nginx HTTP" profile allowance:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo ufw allow 'Nginx Full'
</li><li class="line" prefix="$">sudo ufw delete allow 'Nginx HTTP'
</li></ul></code></pre>
<p>Your status should now look like this:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo ufw status
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Status: active

To                         Action      From
--                         ------      ----
OpenSSH                    ALLOW       Anywhere
Nginx Full                 ALLOW       Anywhere
OpenSSH (v6)               ALLOW       Anywhere (v6)
Nginx Full (v6)            ALLOW       Anywhere (v6)
</code></pre>
<p>With our firewall configured properly, we can move on to testing our Nginx configuration.</p>

<h2 id="step-4-—-enabling-the-changes-in-nginx">Step 4 — Enabling the Changes in Nginx</h2>

<p>Now that we've made our changes and adjusted our firewall, we can restart Nginx to implement our new changes.</p>

<p>First, we should check to make sure that there are no syntax errors in our files. We can do this by typing:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nginx -t
</li></ul></code></pre>
<p>If everything is successful, you will get a result that looks like this:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>nginx: [warn] "ssl_stapling" ignored, issuer certificate not found for certificate "/etc/ssl/certs/nginx-selfsigned.crt"
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful
</code></pre>
<p>Note the warning in the beginning. As discussed earlier, this particular setting throws a warning since our self-signed certificate can't use SSL stapling. This is expected and our server can still encrypt connections correctly.</p>

<p>If your output matches the above, your configuration file has no syntax errors. We can safely restart Nginx to implement our changes:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl restart nginx
</li></ul></code></pre>
<p>With our Nginx configuration tested, we can move on to testing our setup.</p>

<h2 id="step-5-—-testing-encryption">Step 5 — Testing Encryption</h2>

<p>We're now ready to test our SSL server.</p>

<p>Open your web browser and type <code>https://</code> followed by your server's domain name or IP into the address bar:</p>
<pre class="code-pre "><code langs="">https://<span class="highlight">your_domain_or_server_IP</span>
</code></pre>
<p>Because the certificate we created isn't signed by one of your browser's trusted certificate authorities, you will likely see a scary looking warning like the one below (the following appears when using Google Chrome) :</p>

<p><img src="https://assets.digitalocean.com/articles/nginx_ssl_1604/self_signed_warning.png" alt="Nginx self-signed cert warning"></p>

<p>This is expected and normal. We are only interested in the encryption aspect of our certificate, not the third party validation of our host's authenticity. Click "ADVANCED" and then the link provided to proceed to your host:</p>

<p><img src="https://assets.digitalocean.com/articles/nginx_ssl_1604/warning_override.png" alt="Nginx self-signed override"></p>

<p>You should be taken to your site. If you look in the browser address bar, you will see a lock with an "x" over it. In this case, this just means that the certificate cannot be validated. It is still encrypting your connection.</p>

<p>If you configured Nginx with two server blocks, automatically redirecting HTTP content to HTTPS, you can also check whether the redirect functions correctly:</p>
<pre class="code-pre "><code langs="">http://<span class="highlight">server_domain_or_IP</span>
</code></pre>
<p>If this results in the same icon, this means that your redirect worked correctly.</p>

<h2 id="step-6-—-changing-to-a-permanent-redirect">Step 6 — Changing to a Permanent Redirect</h2>

<p>If your redirect worked correctly and you are sure you want to allow only encrypted traffic, you should modify the Nginx configuration to make the redirect permanent.</p>

<p>Open your server block configuration file again:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nano /etc/nginx/sites-available/&lt;^&gt;your_domain^&gt;
</li></ul></code></pre>
<p>Find the <code>return 302</code> and change it to <code>return 301</code>:</p>
<div class="code-label " title="/etc/nginx/sites-available/your_domain">/etc/nginx/sites-available/your_domain</div><pre class="code-pre "><code langs="">    return <span class="highlight">301</span> https://$server_name$request_uri;
</code></pre>
<p>Save and close the file.</p>

<p>Check your configuration for syntax errors:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nginx -t
</li></ul></code></pre>
<p>When you're ready, restart Nginx to make the redirect permanent:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl restart nginx
</li></ul></code></pre>
<h2 id="conclusion">Conclusion</h2>

<p>You have configured your Nginx server to use strong encryption for client connections. This will allow you serve requests securely, and will prevent outside parties from reading your traffic.</p>
