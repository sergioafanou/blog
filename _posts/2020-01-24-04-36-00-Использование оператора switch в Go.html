---
layout: post
title: Использование оператора switch в Go
network: digitalocean
date: January 24, 2020 at 04:36AM
url: https://www.digitalocean.com/community/tutorials/how-to-write-switch-statements-in-go-ru
image: http://ifttt.com/images/no_image_card.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="Введение">Введение</h3>

<p><a href="https://www.digitalocean.com/community/tutorials/how-to-write-conditional-statements-in-go">Условные выражения</a> дают программистам возможность предписывать программам производить определенные действия, если условие выполняется, и другое действие, если условие не выполняется. Нам часто нужно сравнивать определенную <a href="https://www.digitalocean.com/community/tutorials/how-to-use-variables-and-constants-in-go#understanding-variables">переменную</a> с разными возможными значениями и выполнять разные действия для разных результатов. Это можно реализовать, используя только <a href="https://www.digitalocean.com/community/tutorials/how-to-write-conditional-statements-in-go#if-statements">операторы <code>if</code></a>. Однако написание программного обеспечения предусматривает необходимость не только делать так, чтобы все работало, но и показывать свои намерения себе и другим разработчикам. <code>switch</code> — это альтернативный условный оператор, с помощью которого удобно показывать действия программ Go в ситуациях с разными возможными вариантами.</p>

<p>Все, что можно написать с помощью оператора switch, можно написать и с помощью операторов <code>if</code>. В этом обучающем руководстве мы рассмотрим несколько примеров того, что может делать оператор switch, как оно может заменить операторы <code>if</code>, и в каких случаях его лучше применять.</p>

<h2 id="Структура-оператора-switch">Структура оператора switch</h2>

<p>Оператор switch обычно используются для описания действий, которые выполняет программа, когда переменная принимает определенные значения. В следующем примере показано, как добиться этого с помощью выражений <code>if</code>:</p>
<pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

func main() {
    flavors := []string{"chocolate", "vanilla", "strawberry", "banana"}

    for _, flav := range flavors {
        if flav == "strawberry" {
            fmt.Println(flav, "is my favorite!")
            continue
        }

        if flav == "vanilla" {
            fmt.Println(flav, "is great!")
            continue
        }

        if flav == "chocolate" {
            fmt.Println(flav, "is great!")
            continue
        }

        fmt.Println("I've never tried", flav, "before")
    }
}
</code></pre>
<p>Результат будет выглядеть следующим образом:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>chocolate is great!
vanilla is great!
strawberry is my favorite!
I've never tried banana before
</code></pre>
<p>В <code>main</code> мы определяем <a href="https://www.digitalocean.com/community/tutorials/understanding-data-types-in-go#slices">срез</a> вкусов мороженого. Затем мы используем <a href="https://www.digitalocean.com/community/tutorials/how-to-construct-for-loops-in-go"><code>цикл for</code></a> для итерации. Мы используем три оператора <code>if</code> для вывода разных сообщений, показывающих разные предпочитаемые вкусы мороженого. Каждый оператор <code>if</code> должен использовать оператор <code>continue</code> для остановки выполнения цикла <code>for</code>, чтобы последнее сообщение по умолчанию не выводилось для предпочитаемых вкусов мороженого.</p>

<p>При добавлении новых вкусов мороженого нам нужно добавлять операторы <code>if</code> для каждого нового случая. Для дублирующихся сообщений, как в случае с <code>"vanilla"</code> и <code>"chocolate"</code>, следует использовать дублирующиеся операторы <code>if</code>. Тем, кто будет читать наш код в будущем (в том числе и нам), будет сложнее понять код из-за большого количества повторяющихся операторов <code>if</code>, что затрудняет понимание их функции — сравнение переменной с разными значениями и выполнение разных действий. Кроме того, общее сообщение задается отдельно от условий и выглядит не связанным с ними. Оператор <code>switch</code> поможет нам лучше организовать эту логику.</p>

<p>Оператор <code>switch</code> начинается с ключевого слова <code>switch</code>, за которым идет переменная в базовой форме, для которой производится сравнение. Далее идет пара фигурных скобок (<code>{}</code>), в которых могут быть заключены разные <em>варианты</em>. Варианты описывают, какие действия должна выполнять программа Go, если переданная оператору switch переменная имеет значение, указанное в данном варианте. В следующем примере предыдущий пример конвертирован с использованием оператора <code>switch</code> вместо нескольких операторов <code>if</code>:</p>
<pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

func main() {
    flavors := []string{"chocolate", "vanilla", "strawberry", "banana"}

    for _, flav := range flavors {
        switch flav {
        case "strawberry":
            fmt.Println(flav, "is my favorite!")
        case "vanilla", "chocolate":
            fmt.Println(flav, "is great!")
        default:
            fmt.Println("I've never tried", flav, "before")
        }
    }
}
</code></pre>
<p>Результат выглядит так же:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>chocolate is great!
vanilla is great!
strawberry is my favorite!
I've never tried banana before
</code></pre>
<p>Мы снова определяем срез вкусов мороженого в программе <code>main</code> и используем выражение <code>range</code> для итерации вкусов. Однако в данном случае мы используем выражение <code>switch</code>, которое оценивает переменную <code>flav</code>. Мы используем два <code>выбирающих</code> предложения для указания предпочтений. Нам больше не требуются операторы <code>continue</code>, поскольку только один <code>вариант</code> выполняется оператором <code>switch</code>. Также мы сможем комбинировать дублирующуюся логику условий <code>"chocolate"</code> и <code>"vanilla"</code>, разделив их запятой в объявлении <code>варианта</code>. Вариант <code>default</code> используется как универсальный для всех случаев. Оно выполняется для всех вкусов, которые не включены в тело выражения <code>switch</code>. В данном случае для варианта <code>"banana"</code> будет использоваться программа <code>default</code> и будет выведено сообщение <code>I've never tried banana before</code>.</p>

<p>Упрощенная форма оператора <code>switch</code> используется в самом распространенном случае: при сравнении переменной с несколькими альтернативными значениями. Также она обеспечивает дополнительное удобство, если мы хотим выполнять одно и то же действие для нескольких разных значений и другое действие, если не выполняется ни одно из заданных условий. Для этого используется ключевое слово <code>default</code>.</p>

<p>Если упрощенная форма оператора <code>switch</code> слишком узкая, мы можем использовать более общую форму оператора <code>switch</code>.</p>

<h2 id="Общий-оператор-switch">Общий оператор switch</h2>

<p>Операторы <code>switch</code> полезны для группировки наборов более сложных условных операторов, чтобы показать их связь. Это чаще всего применяется при сравнении переменной с диапазоном переменных, а не с определенными значениями, как было показано в предыдущем примере. В следующем примере игра на отгадывание реализована с помощью операторов <code>if</code>, но ее можно улучшить с помощью оператора <code>switch</code>:</p>
<pre class="code-pre "><code class="code-highlight language-go">package main

import (
    "fmt"
    "math/rand"
    "time"
)

func main() {
    rand.Seed(time.Now().UnixNano())
    target := rand.Intn(100)

    for {
        var guess int
        fmt.Print("Enter a guess: ")
        _, err := fmt.Scanf("%d", &amp;guess)
        if err != nil {
            fmt.Println("Invalid guess: err:", err)
            continue
        }

        if guess &gt; target {
            fmt.Println("Too high!")
            continue
        }

        if guess &lt; target {
            fmt.Println("Too low!")
            continue
        }

        fmt.Println("You win!")
        break
    }
}
</code></pre>
<p>Результат зависит от случайного числа и от того, как хорошо вы играете в игру. Вот пример результатов одного игрового сеанса:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Enter a guess: 10
Too low!
Enter a guess: 15
Too low!
Enter a guess: 18
Too high!
Enter a guess: 17
You win!
</code></pre>
<p>Для нашей игры на отгадывание требуется случайное число для сравнения, и поэтому мы используем функцию <code>rand.Intn</code> из пакета <code>math/rand</code>. Чтобы убедиться в получении разных значений <code>target</code> при каждой игре мы используем <code>rand.Seed</code> для рандомизации генератора случайных чисел по текущему времени. Аргумент <code>100</code> для <code>rand.Intn</code> дает нам число в диапазоне 0–100. Затем мы используем цикл <code>for</code> для сбора предположений игрока.</p>

<p>Функция <code>fmt.Scanf</code> дает нам способ считывания вводимых пользователем данных в и сохранения в переменную по нашему выбору. Она использует глагол строки формата, конвертирующий вводимые пользователем данные в ожидаемый нами тип. Здесь <code>%d</code> означает, что мы ожидаем значение <code>int</code>, и мы передаем адрес переменной <code>guess</code>, чтобы у <code>fmt.Scanf</code> была возможность задать эту переменную. После <a href="https://www.digitalocean.com/community/tutorials/handling-errors-in-go">обработки всех ошибок парсинга</a> мы используем два оператора <code>if</code> для сравнения догадки пользователя со значением <code>target</code>. Возвращаемая <code>строка</code> вместе с <code>булевым значением</code> определяют, какое сообщение будет выведено игроку, и будет ли закрыта игра.</p>

<p>Эти операторы <code>if</code> скрывают тот факт, что все значения в диапазоне, с которым сравнивается переменная, связаны друг с другом. При этом сложно сразу определить, не пропустили ли мы какую-то часть диапазона. В следующем примере предыдущий пример модифицирован с использованием оператора <code>switch</code>:</p>
<pre class="code-pre "><code class="code-highlight language-go">package main

import (
    "fmt"
    "math/rand"
)

func main() {
    target := rand.Intn(100)

    for {
        var guess int
        fmt.Print("Enter a guess: ")
        _, err := fmt.Scanf("%d", &amp;guess)
        if err != nil {
            fmt.Println("Invalid guess: err:", err)
            continue
        }

        switch {
        case guess &gt; target:
            fmt.Println("Too high!")
        case guess &lt; target:
            fmt.Println("Too low!")
        default:
            fmt.Println("You win!")
            return
        }
    }
}
</code></pre>
<p>Результат выглядит примерно следующим образом:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Enter a guess: 25
Too low!
Enter a guess: 28
Too high!
Enter a guess: 27
You win!
</code></pre>
<p>В этой версии игры на отгадывание мы заменили блок операторов <code>if</code> на оператора <code>switch</code>. Мы пропускаем аргумент выражения для <code>switch</code>, поскольку мы используем <code>switch</code> только для объединения условий. Каждое <code>выбирающее</code> предложение содержит отдельное выражение сравнения <code>guess</code> и <code>target</code>. Как и в первом случае, когда мы заменили операторы <code>if</code> на оператор <code>switch</code>, нам больше не нужно использовать выражения <code>continue</code>, поскольку выполняется только одно <code>выбирающее предложение</code>. Наконец, выражение <code>default</code> отвечает за случай, когда <code>guess == target</code>, поскольку все остальные возможные варианты рассмотрены в двух других <code>выбирающих предложениях</code>.</p>

<p>В приведенных примерах выполнялось только одно выбирающее выражение. Иногда нужно объединить варианты поведения нескольких <code>выбирающих предложений</code>. Оператор <code>switch</code> имеет еще одно ключевое слово для этой цели.</p>

<h2 id="fallthrough">Fallthrough</h2>

<p>Иногда нам необходимо повторно использовать код, содержащийся в другом <code>выбирающем</code> предложении. В таких случаях можно указать Go запустить тело следующего <code>выбирающего</code> предложения, указанного с помощью ключевого слова <code>fallthrough</code>. В следующем примере мы изменяем предыдущий пример со вкусами мороженого, чтобы более точно отразить нашу любовь к клубничному мороженому:</p>
<pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

func main() {
    flavors := []string{"chocolate", "vanilla", "strawberry", "banana"}

    for _, flav := range flavors {
        switch flav {
        case "strawberry":
            fmt.Println(flav, "is my favorite!")
            fallthrough
        case "vanilla", "chocolate":
            fmt.Println(flav, "is great!")
        default:
            fmt.Println("I've never tried", flav, "before")
        }
    }
}
</code></pre>
<p>Результат будет выглядеть примерно так:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>chocolate is great!
vanilla is great!
strawberry is my favorite!
strawberry is great!
I've never tried banana before
</code></pre>
<p>Как мы уже видели, мы определяем срез <code>строк</code> для представления вкусов и используем цикл <code>for</code> для итерации. Здесь оператор <code>switch</code> повторяет использованный ранее, но в нем используется ключевое слово <code>fallthrough</code> в конце <code>выбирающего предложения</code> для варианта <code>"strawberry"</code>. Так Go запускает тело <code>case "strawberry":</code> и вначале выводит строку <code>strawberry is my favorite!</code>. При появлении <code>fallthrough</code> выполняется тело следующего <code>выбирающего предложения</code>. При этом будет выполнено тело выражения <code>case "vanilla", "chocolate":</code> и будет выведен текст <code>strawberry is great!</code>.</p>

<p>Ключевое слово <code>fallthrough</code> нечасто используется разработчиками на Go. Обычно повторное использование кода, реализуемое через ключевое слово <code>fallthrough</code>, лучше обеспечить посредством определения функции в общем коде. По этой причине использовать <code>fallthrough</code> не рекомендуется.</p>

<h2 id="Заключение">Заключение</h2>

<p>Оператор <code>switch</code> помогает нам передать другим разработчикам, читающим наш код, что сравниваемые значения в наборе как-то связаны друг с другом. Это упрощает добавление других вариантов поведения и позволяет правильно обрабатывать все  варианты, которые мы могли забыть благодаря использованию <code>default</code>. Когда вы в следующей раз будете писать код с несколькими оператора <code>if</code> для одной и той же переменной, попробуйте переписать его с помощью <code>switch</code>. Так вам будет проще переделать код, если в будущем потребуется добавить другие альтернативные значения.</p>

<p>Если вы хотите узнать больше о языке программирования Go, ознакомьтесь с нашей <a href="https://www.digitalocean.com/community/tutorial_series/how-to-code-in-go">серией статей о программировании на языке Go</a>.</p>
