---
layout: post
title: How To Set Up Flask with MongoDB and Docker
network: digitalocean
date: October 08, 2019 at 08:59PM
url: https://www.digitalocean.com/community/tutorials/how-to-set-up-flask-with-mongodb-and-docker
image: http://ifttt.com/images/no_image_card.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<p><em>The author selected the <a href="https://www.brightfunds.org/organizations/internet-archive">Internet Archive</a> to receive a donation as part of the <a href="https://do.co/w4do-cta">Write for DOnations</a> program.</em></p>

<h3 id="introduction">Introduction</h3>

<p>Developing web applications can become complex and time consuming when building and maintaining a number of different technologies. Considering lighter weight options designed to reduce complexity and time-to-production for your application can result in a more flexible and scalable solution. As a micro web framework built on <a href="https://www.python.org/">Python</a>, <a href="http://flask.pocoo.org/docs/1.0/">Flask</a> provides an extensible way for developers to grow their applications through extensions that can be integrated into projects. To continue the scalability of a developer&rsquo;s tech stack, <a href="https://www.mongodb.com/">MongoDB</a> is a NoSQL database is designed to scale and work with frequent changes. Developers can use <a href="https://docs.docker.com/">Docker</a> to simplify the process of packaging and deploying their applications.</p>

<p><a href="https://docs.docker.com/compose/">Docker Compose</a> has further simplified the development environment by allowing you to define your infrastructure, including your application services, network volumes, and bind mounts, in a single file. Using Docker Compose provides ease of use over running multiple <code>docker container run</code> commands. It allows you to define all your services in a single Compose file, and with a single command you create and start all the services from your configuration. This ensures that there is version control throughout your container infrastructure. Docker Compose uses a project name to isolate environments from each other, this allows you to run multiple environments on a single host.</p>

<p>In this tutorial you will build, package, and run your to-do web application with Flask, Nginx, and MongoDB inside of Docker <a href="https://www.docker.com/what-container">containers</a>. You will define the entire stack configuration in a <code>docker-compose.yml</code> file, along with configuration files for Python, MongoDB, and Nginx. Flask requires a web server to serve HTTP requests, so you will also use <a href="https://gunicorn.org/">Gunicorn</a>, which is a Python WSGI HTTP Server, to serve the application. Nginx acts as a reverse proxy server that forwards requests to Gunicorn for processing.</p>

<h2 id="prerequisites">Prerequisites</h2>

<p>To follow this tutorial, you will need the following:</p>

<ul>
<li>A non-root user with <code>sudo</code> privileges configured by following the steps in the <a href="https://www.digitalocean.com/community/tutorial_collections/16">Initial Server Setup</a> tutorial.</li>
<li>Docker installed with the instructions from Step 1 and Step 2 of <a href="https://www.digitalocean.com/community/tutorial_collections/39">How To Install and Use Docker</a>.</li>
<li>Docker Compose installed with the instructions from Step 1 of <a href="https://www.digitalocean.com/community/tutorial_collections/48">How To Install Docker Compose</a>.</li>
</ul>

<h2 id="step-1-—-writing-the-stack-configuration-in-docker-compose">Step 1 — Writing the Stack Configuration in Docker Compose</h2>

<p>Building your applications on Docker allows you to version infrastructure easily depending on configuration changes you make in Docker Compose. The infrastructure can be defined in a single file and built with a single command. In this step, you will set up the <code>docker-compose.yml</code> file to run your Flask application.</p>

<p>The <code>docker-compose.yml</code> file lets you define your application infrastructure as individual services. The services can be connected to each other and each can have a <em>volume</em> attached to it for persistent storage. Volumes are stored in a part of the host filesystem managed by Docker (<code>/var/lib/docker/volumes/</code> on Linux).</p>

<p>Volumes are the best way to persist data in Docker, as the data in the volumes can be exported or shared with other applications. For additional information about sharing data in Docker, you can refer to <a href="https://www.digitalocean.com/community/tutorials/how-to-share-data-between-the-docker-container-and-the-host">How To Share Data Between the Docker Container and the Host</a>.</p>

<p>To get started, create a directory for the application in the home directory on your server:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir flaskapp
</li></ul></code></pre>
<p>Move into the newly created directory:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd flaskapp
</li></ul></code></pre>
<p>Next, create the <code>docker-compose.yml</code> file:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano docker-compose.yml
</li></ul></code></pre>
<p>The <code>docker-compose.yml</code> file starts with a version number that identifies the <a href="https://docs.docker.com/compose/compose-file/">Docker Compose file version</a>. Docker Compose file version <code>3</code> targets Docker Engine version <code>1.13.0+</code>, which is a prerequisite for this setup. You will also add the <code>services</code> tag that you will define in the next step:</p>
<div class="code-label " title="docker-compose.yml">docker-compose.yml</div><pre class="code-pre yml"><code langs="">version: '3'
services:
</code></pre>
<p>You will now define <code>flask</code> as the first service in your <code>docker-compose.yml</code> file. Add the following code to define the Flask service:</p>
<div class="code-label " title="docker-compose.yml">docker-compose.yml</div><pre class="code-pre yml"><code langs="">. . .
  flask:
    build:
      context: app
      dockerfile: Dockerfile
    container_name: flask
    image: digitalocean.com/flask-python:3.6
    restart: unless-stopped
    environment:
      APP_ENV: "prod"
      APP_DEBUG: "False"
      APP_PORT: 5000
      MONGODB_DATABASE: flaskdb
      MONGODB_USERNAME: <span class="highlight">flaskuser</span>
      MONGODB_PASSWORD: <span class="highlight">your_mongodb_password</span>
      MONGODB_HOSTNAME: mongodb
    volumes:
      - appdata:/var/www
    depends_on:
      - mongodb
    networks:
      - frontend
      - backend
</code></pre>
<p>The <code>build</code> property defines the <code>context</code> of the build. In this case, the <code>app</code> folder that will contain the <code>Dockerfile</code>.</p>

<p>You use the <code>container_name</code> property to define a name for each container. The <code>image</code> property specifies the image name and what the Docker image will be tagged as. The <code>restart</code> property defines how the container should be restarted—in your case it is <code>unless-stopped</code>. This means your containers will only be stopped when the Docker Engine is stopped/restarted or when you explicitly stop the containers. The benefit of using the <code>unless-stopped</code> property is that the containers will start automatically once the Docker Engine is restarted or any error occurs.</p>

<p>The <code>environment</code> property contains the environment variables that are passed to the container. You need to provide a secure password for the environment variable <code>MONGODB_PASSWORD</code>. The <code>volumes</code> property defines the volumes the service is using. In your case the volume <code>appdata</code> is mounted inside the container at the <code>/var/www</code> directory. The <code>depends_on</code> property defines a service that Flask depends on to function properly. In this case, the <code>flask</code> service will depend on <code>mongodb</code> since the <code>mongodb</code> service acts as the database for your application. <code>depends_on</code> ensures that the <code>flask</code> service only runs if the <code>mongodb</code> service is running.</p>

<p>The <code>networks</code> property specifies <code>frontend</code> and <code>backend</code> as the networks the <code>flask</code> service will have access to.</p>

<p>With the <code>flask</code> service defined, you&rsquo;re ready to add the MongoDB configuration to the file. In this example, you will use the official <code>4.0.8</code> version <code>mongo</code> image. Add the following code to your <code>docker-compose.yml</code> file following the <code>flask service</code>:</p>
<div class="code-label " title="docker-compose.yml">docker-compose.yml</div><pre class="code-pre yml"><code langs="">. . .
  mongodb:
    image: mongo:4.0.8
    container_name: mongodb
    restart: unless-stopped
    command: mongod --auth
    environment:
      MONGO_INITDB_ROOT_USERNAME: <span class="highlight">mongodbuser</span>
      MONGO_INITDB_ROOT_PASSWORD: <span class="highlight">your_mongodb_root_password</span>
      MONGO_INITDB_DATABASE: flaskdb
      MONGODB_DATA_DIR: /data/db
      MONDODB_LOG_DIR: /dev/null
    volumes:
      - mongodbdata:/data/db
    networks:
      - backend
</code></pre>
<p>The <code>container_name</code> for this service is <code>mongodb</code> with a restart policy of <code>unless-stopped</code>. You use the <code>command</code> property to define the command that will be executed when the container is started. The command <code>mongod --auth</code> will disable logging into the MongoDB shell without credentials, which will secure MongoDB by requiring authentication.</p>

<p>The environment variables <code>MONGO_INITDB_ROOT_USERNAME</code> and <code>MONGO_INITDB_ROOT_PASSWORD</code> create a root user with the given credentials, so be sure to replace the placeholder with a strong password.</p>

<p>MongoDB stores its data in <code>/data/db</code> by default, therefore the data in the <code>/data/db</code> folder will be written to the named volume <code>mongodbdata</code> for persistence. As a result you won&rsquo;t lose your databases in the event of a restart. The <code>mongoDB</code> service does not expose any ports, so the service will only be accessible through the <code>backend</code> network.</p>

<p>Next, you will define the web server for your application. Add the following code to your <code>docker-compose.yml</code> file to configure Nginx:</p>
<div class="code-label " title="docker-compose.yml">docker-compose.yml</div><pre class="code-pre yml"><code langs="">. . .
  webserver:
    build:
      context: nginx
      dockerfile: Dockerfile
    image: digitalocean.com/webserver:latest
    container_name: webserver
    restart: unless-stopped
    environment:
      APP_ENV: "prod"
      APP_NAME: "webserver"
      APP_DEBUG: "false"
      SERVICE_NAME: "webserver"
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - nginxdata:/var/log/nginx
    depends_on:
      - flask
    networks:
      - frontend
</code></pre>
<p>Here you have defined the <code>context</code> of the <code>build</code>, which is the <code>nginx</code> folder containing the <code>Dockerfile</code>. With the <code>image</code> property, you specify the image used to tag and run the container. The <code>ports</code> property will configure the Nginx service to be publicly accessible through <code>:80</code> and <code>:443</code> and <code>volumes</code> mounts the <code>nginxdata</code> volume inside the container at <code>/var/log/nginx</code> directory.</p>

<p>You&rsquo;ve defined the service on which the web server service <code>depends_on</code> as <code>flask</code>. Finally the <code>networks</code> property defines the networks web server service will have access to the <code>frontend</code>.</p>

<p>Next, you will create <em>bridge networks</em> to allow the containers to communicate with each other. Append the following lines to the end of your file:</p>
<div class="code-label " title="docker-compose.yml">docker-compose.yml</div><pre class="code-pre yml"><code langs="">. . .
networks:
  frontend:
    driver: bridge
  backend:
    driver: bridge
</code></pre>
<p>You defined two networks—<code>frontend</code> and <code>backend</code>—for the services to connect to. The front-end services, such as Nginx, will connect to the <code>frontend</code> network since it needs to be publicly accessible. Back-end services, such as MongoDB, will connect to the <code>backend</code> network to prevent unauthorized access to the service.</p>

<p>Next, you will use volumes to persist the database, application, and configuration files. Since your application will use the databases and files, it is imperative to persist the changes made to them. The volumes are managed by Docker and stored on the filesystem. Add this code to the <code>docker-compose.yml</code> file to configure the volumes:</p>
<div class="code-label " title="docker-compose.yml">docker-compose.yml</div><pre class="code-pre yml"><code langs="">. . .
volumes:
  mongodbdata:
    driver: local
  appdata:
    driver: local
  nginxdata:
    driver: local
</code></pre>
<p>The <code>volumes</code> section declares the volumes that the application will use to persist data. Here you have defined the volumes <code>mongodbdata</code>, <code>appdata</code>, and <code>nginxdata</code> for persisting your MongoDB databases, Flask application data, and the Nginx web server logs, respectively. All of these volumes use a <code>local</code> driver to store the data locally. The volumes are used to persist this data so that data like your MongoDB databases and Nginx webserver logs could be lost once you restart the containers.</p>

<p>Your complete <code>docker-compose.yml</code> file will look like this:</p>
<div class="code-label " title="docker-compose.yml">docker-compose.yml</div><pre class="code-pre yml"><code langs="">version: '3'
services:

  flask:
    build:
      context: app
      dockerfile: Dockerfile
    container_name: flask
    image: digitalocean.com/flask-python:3.6
    restart: unless-stopped
    environment:
      APP_ENV: "prod"
      APP_DEBUG: "False"
      APP_PORT: 5000
      MONGODB_DATABASE: flaskdb
      MONGODB_USERNAME: <span class="highlight">flaskuser</span>
      MONGODB_PASSWORD: <span class="highlight">your_mongodb_password</span>
      MONGODB_HOSTNAME: mongodb
    volumes:
      - appdata:/var/www
    depends_on:
      - mongodb
    networks:
      - frontend
      - backend

  mongodb:
    image: mongo:4.0.8
    container_name: mongodb
    restart: unless-stopped
    command: mongod --auth
    environment:
      MONGO_INITDB_ROOT_USERNAME: <span class="highlight">mongodbuser</span>
      MONGO_INITDB_ROOT_PASSWORD: <span class="highlight">your_mongodb_root_password</span>
      MONGO_INITDB_DATABASE: flaskdb
      MONGODB_DATA_DIR: /data/db
      MONDODB_LOG_DIR: /dev/null
    volumes:
      - mongodbdata:/data/db
    networks:
      - backend

  webserver:
    build:
      context: nginx
      dockerfile: Dockerfile
    image: digitalocean.com/webserver:latest
    container_name: webserver
    restart: unless-stopped
    environment:
      APP_ENV: "prod"
      APP_NAME: "webserver"
      APP_DEBUG: "true"
      SERVICE_NAME: "webserver"
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - nginxdata:/var/log/nginx
    depends_on:
      - flask
    networks:
      - frontend

networks:
  frontend:
    driver: bridge
  backend:
    driver: bridge

volumes:
  mongodbdata:
    driver: local
  appdata:
    driver: local
  nginxdata:
    driver: local
</code></pre>
<p>Save the file and exit the editor after verifying your configuration.</p>

<p>You&rsquo;ve defined the Docker configuration for your entire application stack in the <code>docker-compose.yml</code> file. You will now move on to writing the Dockerfiles for Flask and the web server.</p>

<h2 id="step-2-—-writing-the-flask-and-web-server-dockerfiles">Step 2 — Writing the Flask and Web Server Dockerfiles</h2>

<p>With Docker, you can build containers to run your applications from a file called <em>Dockerfile</em>. The Dockerfile is a tool that enables you to create custom images that you can use to install the software required by your application and configure your containers based on your requirements. You can push the custom images you create to <a href="https://hub.docker.com/">Docker Hub</a> or any private registry.</p>

<p>In this step, you&rsquo;ll write the Dockerfiles for the Flask and web server services. To get started, create the <code>app</code> directory for your Flask application:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir app
</li></ul></code></pre>
<p>Next, create the <code>Dockerfile</code> for your Flask app in the <code>app</code> directory:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano app/Dockerfile
</li></ul></code></pre>
<p>Add the following code to the file to customize your Flask container:</p>
<div class="code-label " title="app/Dockerfile">app/Dockerfile</div><pre class="code-pre docker"><code langs="">FROM python:3.6.8-alpine3.9

LABEL MAINTAINER="<span class="highlight">FirstName LastName</span> <span class="highlight">&lt;example@domain.com&gt;</span>"

ENV GROUP_ID=1000 \
    USER_ID=1000

WORKDIR /var/www/
</code></pre>
<p>In this <code>Dockerfile</code>, you are creating an image on top of the <a href="https://hub.docker.com/_/python/"><code>3.6.8-alpine3.9</code> image</a> that is based on Alpine 3.9 with Python 3.6.8 pre-installed.</p>

<p>The <code>ENV</code> directive is used to define the environment variables for our group and user ID.<br>
<a href="http://refspecs.linux-foundation.org/LSB_5.0.0/LSB-Core-generic/LSB-Core-generic/usernames.html">Linux Standard Base (LSB)</a> specifies that <a href="https://www.debian.org/doc/debian-policy/ch-opersys.html#uid-and-gid-classes">UIDs and GIDs 0-99</a> are statically allocated by the system. <a href="https://www.debian.org/doc/debian-policy/ch-opersys.html#uid-and-gid-classes">UIDs 100-999</a> are supposed to be allocated dynamically for system users and groups. <a href="https://www.debian.org/doc/debian-policy/ch-opersys.html#uid-and-gid-classes">UIDs 1000-59999</a> are supposed to be dynamically allocated for user accounts. Keeping this in mind you can safely assign a UID and GID of <code>1000</code>, furthermore you can change the UID/GID by updating the <code>GROUP_ID</code> and <code>USER_ID</code> to match your requirements.</p>

<p>The <code>WORKDIR</code> directive defines the working directory for the container. Be sure to replace the <code>LABEL MAINTAINER</code> field with your name and email address.</p>

<p>Add the following code block to copy the Flask application into the container and install the necessary dependencies:</p>
<div class="code-label " title="app/Dockerfile">app/Dockerfile</div><pre class="code-pre docker"><code langs="">. . .
ADD ./requirements.txt /var/www/requirements.txt
RUN pip install -r requirements.txt
ADD . /var/www/
RUN pip install gunicorn
</code></pre>
<p>The following code will use the <code>ADD</code> directive to copy files from the local <code>app</code> directory to the <code>/var/www</code> directory on the container. Next, the Dockerfile will use the <code>RUN</code> directive to install Gunicorn and the packages specified in the <code>requirements.txt</code> file, which you will create later in the tutorial.</p>

<p>The following code block adds a new user and group and initializes the application:</p>
<div class="code-label " title="app/Dockerfile">app/Dockerfile</div><pre class="code-pre docker"><code langs="">. . .
RUN addgroup -g $GROUP_ID www
RUN adduser -D -u $USER_ID -G www www -s /bin/sh

USER www

EXPOSE 5000

CMD [ "gunicorn", "-w", "4", "--bind", "0.0.0.0:5000", "wsgi"]
</code></pre>
<p>By default, Docker containers run as the <strong>root</strong> user. The <strong>root</strong> user has access to everything in the system, so the implications of a security breach can be disastrous. To mitigate this security risk, this will create a new user and group that will only have access to the <code>/var/www</code> directory.</p>

<p>This code will first use the <code>addgroup</code> command to create a new group named <code>www</code>. The <code>-g</code> flag will set the group ID to the <code>ENV GROUP_ID=1000</code> variable that is defined earlier in the <code>Dockerfile</code>.</p>

<p>The <code>adduser -D -u $USER_ID -G www www -s /bin/sh</code> lines creates a <code>www</code> user with a user ID of <code>1000</code>, as defined by the <code>ENV</code> variable. The <code>-s</code> flag creates the user&rsquo;s home directory if it does not exist and sets the default login shell to <code>/bin/sh</code>. The <code>-G</code> flag is used to set the user&rsquo;s initial login group to <code>www</code>, which was created by the previous command.</p>

<p>The <code>USER</code> command defines that the programs run in the container will use the <code>www</code> user. Gunicorn will listen on <code>:5000</code>, so you will open this port with the <code>EXPOSE</code> command.</p>

<p>Finally, the <code>CMD [ "gunicorn", "-w", "4", "--bind", "0.0.0.0:5000", "wsgi"]</code> line runs the command to start the Gunicorn server with four workers listening on port <code>5000</code>. The number should generally be between 2–4 workers per core in the server, Gunicorn documentation recommends <a href="https://docs.gunicorn.org/en/stable/design.html#how-many-workers"><code>(2 x $num_cores) + 1</code></a> as the number of workers to start with.</p>

<p>Your completed <code>Dockerfile</code> will look like the following:</p>
<div class="code-label " title="app/Dockerfile">app/Dockerfile</div><pre class="code-pre docker"><code langs="">FROM python:3.6.8-alpine3.9

LABEL MAINTAINER="<span class="highlight">FirstName LastName</span> <span class="highlight">&lt;example@domain.com&gt;</span>"

ENV GROUP_ID=1000 \
    USER_ID=1000

WORKDIR /var/www/

ADD . /var/www/
RUN pip install -r requirements.txt
RUN pip install gunicorn

RUN addgroup -g $GROUP_ID www
RUN adduser -D -u $USER_ID -G www www -s /bin/sh

USER www

EXPOSE 5000

CMD [ "gunicorn", "-w", "4", "--bind", "0.0.0.0:5000", "wsgi"]
</code></pre>
<p>Save the file and exit the text editor.</p>

<p>Next, create a new directory to hold your Nginx configuration:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir nginx
</li></ul></code></pre>
<p>Then create the <code>Dockerfile</code> for your Nginx web server in the <code>nginx</code> directory:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano nginx/Dockerfile
</li></ul></code></pre>
<p>Add the following code to the file to create the Dockerfile that will build the image for your Nginx container:</p>
<div class="code-label " title="nginx/Dockerfile">nginx/Dockerfile</div><pre class="code-pre docker"><code langs="">FROM digitalocean.com/alpine:latest

LABEL MAINTAINER="<span class="highlight">FirstName LastName</span> <span class="highlight">&lt;example@domain.com&gt;</span>"

RUN apk --update add nginx &amp;&amp; \
    ln -sf /dev/stdout /var/log/nginx/access.log &amp;&amp; \
    ln -sf /dev/stderr /var/log/nginx/error.log &amp;&amp; \
    mkdir /etc/nginx/sites-enabled/ &amp;&amp; \
    mkdir -p /run/nginx &amp;&amp; \
    rm -rf /etc/nginx/conf.d/default.conf &amp;&amp; \
    rm -rf /var/cache/apk/*

COPY conf.d/app.conf /etc/nginx/conf.d/app.conf

EXPOSE 80 443
CMD ["nginx", "-g", "daemon off;"]
</code></pre>
<p>This Nginx <code>Dockerfile</code> uses an <code>alpine</code> base image, which is a tiny Linux distribution with a minimal attack surface built for security.</p>

<p>In the <code>RUN</code> directive you are installing <code>nginx</code> as well as creating symbolic links to publish the error and access logs to the standard error (<code>/dev/stderr</code>) and output (<code>/dev/stdout</code>). Publishing errors to standard error and output is a best practice since containers are ephemeral, doing this the logs are shipped to docker logs and from there you can forward your logs to a logging service like the Elastic stack for persistance. After this is done, commands are run to remove the <code>default.conf</code> and <code>/var/cache/apk/*</code> to reduce the size of the resulting image. Executing all of these commands in a single <code>RUN</code> decreases the number of layers in the image, which also reduces the size of the resulting image.</p>

<p>The <code>COPY</code> directive copies the <code>app.conf</code> web server configuration inside of the container. The <code>EXPOSE</code> directive ensures the containers listen on ports <code>:80</code> and <code>:443</code>, as your application will run on <code>:80</code> with <code>:443</code> as the secure port.</p>

<p>Finally, the <code>CMD</code> directive defines the command to start the Nginx server.</p>

<p>Save the file and exit the text editor.</p>

<p>Now that the <code>Dockerfile</code> is ready, you are ready to configure the Nginx reverse proxy to route traffic to the Flask application.</p>

<h2 id="step-3-—-configuring-the-nginx-reverse-proxy">Step 3 — Configuring the Nginx Reverse Proxy</h2>

<p>In this step, you will configure Nginx as a reverse proxy to forward requests to Gunicorn on <code>:5000</code>. A reverse proxy server is used to direct client requests to the appropriate back-end server. It provides an additional layer of abstraction and control to ensure the smooth flow of network traffic between clients and servers.</p>

<p>Get started by creating the <code>nginx/conf.d</code> directory:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir nginx/conf.d
</li></ul></code></pre>
<p>To configure Nginx, you need to create an <code>app.conf</code> file with the following configuration in the <code>nginx/conf.d/</code> folder. The <code>app.conf</code> file contains the configuration that the reverse proxy needs to forward the requests to Gunicorn.</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano nginx/conf.d/app.conf
</li></ul></code></pre>
<p>Put the following contents into the <code>app.conf</code> file:</p>
<div class="code-label " title="nginx/conf.d/app.conf">nginx/conf.d/app.conf</div><pre class="code-pre "><code class="code-highlight language-nginx">upstream app_server {
    server flask:5000;
}

server {
    listen 80;
    server_name _;
    error_log  /var/log/nginx/error.log;
    access_log /var/log/nginx/access.log;
    client_max_body_size 64M;

    location / {
        try_files $uri @proxy_to_app;
    }

    location @proxy_to_app {
        gzip_static on;

        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Host $http_host;
        proxy_buffering off;
        proxy_redirect off;
        proxy_pass http://app_server;
    }
}
</code></pre>
<p>This will first define the <a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html">upstream server</a>, which is commonly used to specify a web or app server for routing or load balancing.</p>

<p>Your upstream server, <code>app_server</code>, defines the server address with the <code>server</code> directive, which is identified by the container name <code>flask:5000</code>.</p>

<p>The configuration for the Nginx web server is defined in the <code>server</code> block. The <code>listen</code> directive defines the port number on which your server will listen for incoming requests. The <code>error_log</code> and <code>access_log</code> directives define the files for writing logs. The <code>proxy_pass</code> directive is used to set the upstream server for forwarding the requests to <code>http://<span class="highlight">app_server</span></code>.</p>

<p>Save and close the file.</p>

<p>With the Nginx web server configured, you can move on to creating the Flask to-do API.</p>

<h2 id="step-4-—-creating-the-flask-to-do-api">Step 4 — Creating the Flask To-do API</h2>

<p>Now that you&rsquo;ve built out your environment, you&rsquo;re ready to build your application. In this step, you will write a to-do API application that will save and display to-do notes sent in from a POST request.</p>

<p>Get started by creating the <code>requirements.txt</code> file in the <code>app</code> directory:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano app/requirements.txt
</li></ul></code></pre>
<p>This file is used to install the dependencies for your application. The implementation of this tutorial will use <a href="http://flask.pocoo.org/"><code>Flask</code></a>, <a href="https://flask-pymongo.readthedocs.io/en/latest/"><code>Flask-PyMongo</code></a>, and <a href="http://flask.pocoo.org/docs/1.0/reqcontext/"><code>requests</code></a>. Add the following to the <code>requirements.txt</code> file:</p>
<div class="code-label " title="app/requirements.txt">app/requirements.txt</div><pre class="code-pre plain"><code langs="">Flask==1.0.2
Flask-PyMongo==2.2.0
requests==2.20.1
</code></pre>
<p>Save the file and exit the editor after entering the requirements.</p>

<p>Next, create the <code>app.py</code> file to contain the Flask application code in the <code>app</code> directory:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano app/app.py
</li></ul></code></pre>
<p>In your new <code>app.py</code> file, enter in the code to import the dependencies:</p>
<div class="code-label " title="app/app.py">app/app.py</div><pre class="code-pre "><code class="code-highlight language-python">import os
from flask import Flask, request, jsonify
from flask_pymongo import PyMongo
</code></pre>
<p>The <code>os</code> package is used to import the environment variables. From the <code>flask</code> library you imported the <code>Flask</code>, <code>request</code>, and <code>jsonify</code> objects to instantiate the application, handle requests, and send JSON responses, respectively. From <code>flask_pymongo</code> you imported the <code>PyMongo</code> object to interact with the MongoDB.</p>

<p>Next, add the code needed to connect to MongoDB:</p>
<div class="code-label " title="app/app.py">app/app.py</div><pre class="code-pre "><code class="code-highlight language-python">. . .
application = Flask(__name__)

application.config["MONGO_URI"] = 'mongodb://' + os.environ['MONGODB_USERNAME'] + ':' + os.environ['MONGODB_PASSWORD'] + '@' + os.environ['MONGODB_HOSTNAME'] + ':27017/' + os.environ['MONGODB_DATABASE']

mongo = PyMongo(application)
db = mongo.db
</code></pre>
<p>The <code>Flask(__name__)</code> loads the application object into the <code>application</code> variable. Next, the code builds the MongoDB connection string from the environment variables using <code>os.environ</code>. Passing the <code>application</code> object in to the <code>PyMongo()</code> method will give you the <code>mongo</code> object, which in turn gives you the <code>db</code> object from <code>mongo.db</code>.</p>

<p>Now you will add the code to create an index message:</p>
<div class="code-label " title="app/app.py">app/app.py</div><pre class="code-pre "><code class="code-highlight language-python">. . .
@application.route('/')
def index():
    return jsonify(
        status=True,
        message='Welcome to the Dockerized Flask MongoDB app!'
    )
</code></pre>
<p>The <code>@application.route('/')</code> defines the <code>/</code> GET route of your API. Here your <code>index()</code> function returns a JSON string using the <code>jsonify</code> method.</p>

<p>Next, add the <code>/todo</code> route to list all to-do&rsquo;s:</p>
<div class="code-label " title="app/app.py">app/app.py</div><pre class="code-pre "><code class="code-highlight language-python">. . .
@application.route('/todo')
def todo():
    _todos = db.todo.find()

    item = {}
    data = []
    for todo in _todos:
        item = {
            'id': str(todo['_id']),
            'todo': todo['todo']
        }
        data.append(item)

    return jsonify(
        status=True,
        data=data
    )
</code></pre>
<p>The <code>@application.route('/todo')</code> defines the <code>/todo</code> GET route of your API, which returns the to-dos in the database. The <code>db.todo.find()</code> method returns all the to-dos in the database. Next, you iterate over the <code>_todos</code> to build an <code>item</code> that includes only the <code>id</code> and <code>todo</code> from the objects appending them to a <code>data</code> array and finally returns them as JSON.</p>

<p>Next, add the code for creating the to-do:</p>
<div class="code-label " title="app/app.py">app/app.py</div><pre class="code-pre "><code class="code-highlight language-python">. . .
@application.route('/todo', methods=['POST'])
def createTodo():
    data = request.get_json(force=True)
    item = {
        'todo': data['todo']
    }
    db.todo.insert_one(item)

    return jsonify(
        status=True,
        message='To-do saved successfully!'
    ), 201
</code></pre>
<p>The <code>@application.route('/todo')</code> defines the <code>/todo</code> POST route of your API, which creates a to-do note in the database. The <code>request.get_json(force=True)</code> gets the JSON that you post to the route, and <code>item</code> is used to build the JSON that will be saved in the to-do. The <code>db.todo.insert_one(item)</code> is used to insert one item into the database. After the to-do is saved in the database you return a JSON response with a status code of <code>201 CREATED</code>.</p>

<p>Now you add the code to run the application:</p>
<div class="code-label " title="app/app.py">app/app.py</div><pre class="code-pre "><code class="code-highlight language-python">. . .
if __name__ == "__main__":
    ENVIRONMENT_DEBUG = os.environ.get("APP_DEBUG", True)
    ENVIRONMENT_PORT = os.environ.get("APP_PORT", 5000)
    application.run(host='0.0.0.0', port=ENVIRONMENT_PORT, debug=ENVIRONMENT_DEBUG)
</code></pre>
<p>The condition <code>__name__ == "__main__"</code> is used to check if the global variable, <code>__name__</code>, in the module is the entry point to your program, is <code>"__main__"</code>, then run the application. If the <code>__name__</code> is equal to <code>"__main__"</code> then the code inside the <code>if</code> block will execute the app using this command <code>application.run(host='0.0.0.0', port=ENVIRONMENT_PORT, debug=ENVIRONMENT_DEBUG)</code>.</p>

<p>Next, we get the values for the <code>ENVIRONMENT_DEBUG</code> and <code>ENVIRONMENT_PORT</code> from the environment variables using <code>os.environ.get()</code>, using the key as the first parameter and default value as the second parameter. The <code>application.run()</code> sets the <code>host</code>, <code>port</code>, and <code>debug</code> values for the application.</p>

<p>The completed <code>app.py</code> file will look like this:</p>
<div class="code-label " title="app/app.py">app/app.py</div><pre class="code-pre "><code class="code-highlight language-python">import os
from flask import Flask, request, jsonify
from flask_pymongo import PyMongo

application = Flask(__name__)

application.config["MONGO_URI"] = 'mongodb://' + os.environ['MONGODB_USERNAME'] + ':' + os.environ['MONGODB_PASSWORD'] + '@' + os.environ['MONGODB_HOSTNAME'] + ':27017/' + os.environ['MONGODB_DATABASE']

mongo = PyMongo(application)
db = mongo.db

@application.route('/')
def index():
    return jsonify(
        status=True,
        message='Welcome to the Dockerized Flask MongoDB app!'
    )

@application.route('/todo')
def todo():
    _todos = db.todo.find()

    item = {}
    data = []
    for todo in _todos:
        item = {
            'id': str(todo['_id']),
            'todo': todo['todo']
        }
        data.append(item)

    return jsonify(
        status=True,
        data=data
    )

@application.route('/todo', methods=['POST'])
def createTodo():
    data = request.get_json(force=True)
    item = {
        'todo': data['todo']
    }
    db.todo.insert_one(item)

    return jsonify(
        status=True,
        message='To-do saved successfully!'
    ), 201

if __name__ == "__main__":
    ENVIRONMENT_DEBUG = os.environ.get("APP_DEBUG", True)
    ENVIRONMENT_PORT = os.environ.get("APP_PORT", 5000)
    application.run(host='0.0.0.0', port=ENVIRONMENT_PORT, debug=ENVIRONMENT_DEBUG)
</code></pre>
<p>Save the file and exit the editor.</p>

<p>Next, create the <code>wsgi.py</code> file in the <code>app</code> directory.</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano app/wsgi.py
</li></ul></code></pre>
<p>The <code>wsgi.py</code> file creates an application object (or callable) so that the server can use it. Each time a request comes, the server uses this application object to run the application&rsquo;s request handlers upon parsing the URL.</p>

<p>Put the following contents into the <code>wsgi.py</code> file, save the file, and exit the text editor:</p>
<div class="code-label " title="app/wsgi.py">app/wsgi.py</div><pre class="code-pre "><code class="code-highlight language-python">from app import application

if __name__ == "__main__":
  application.run()
</code></pre>
<p>This <code>wsgi.py</code> file imports the application object from the <code>app.py</code> file and creates an application object for the Gunicorn server.</p>

<p>The to-do app is now in place, so you&rsquo;re ready to start running the application in containers.</p>

<h2 id="step-5-—-building-and-running-the-containers">Step 5 — Building and Running the Containers</h2>

<p>Now that you have defined all of the services in your <code>docker-compose.yml</code> file and their configurations, you can start the containers.</p>

<p>Since the services are defined in a single file, you need to issue a single command to start the containers, create the volumes, and set up the networks. This command also builds the image for your Flask application and the Nginx web server. Run the following command to build the containers:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose up -d
</li></ul></code></pre>
<p>When running the command for the first time, it will download all of the necessary Docker images, which can take some time. Once the images are downloaded and stored in your local machine, <code>docker-compose</code> will create your containers. The <code>-d</code> flag daemonizes the process, which allows it to run as a background process.</p>

<p>Use the following command to list the running containers once the build process is complete:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker ps
</li></ul></code></pre>
<p>You will see output similar to the following:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>CONTAINER ID        IMAGE                           COMMAND                  CREATED             STATUS              PORTS                                      NAMES
f20e9a7fd2b9        digitalocean.com/webserver:latest   "nginx -g 'daemon of&hellip;"   2 weeks ago         Up 2 weeks          0.0.0.0:80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp   webserver
3d53ea054517        digitalocean.com/flask-python:3.6   "gunicorn -w 4 --bin&hellip;"   2 weeks ago         Up 2 weeks          5000/tcp                                   flask
96f5a91fc0db        mongo:4.0.8                     "docker-entrypoint.s&hellip;"   2 weeks ago         Up 2 weeks          27017/tcp                                  mongodb
</code></pre>
<p>The <code>CONTAINER ID</code> is a unique identifier that is used to access containers. The <code>IMAGE</code> defines the image name for the given container. The <code>NAMES</code> field is the service name under which containers are created, similar to <code>CONTAINER ID</code> these can be used to access containers. Finally, the <code>STATUS</code> provides information regarding the state of the container whether it&rsquo;s running, restarting, or stopped.</p>

<p>You&rsquo;ve used the <code>docker-compose</code> command to build your containers from your configuration files. In the next step, you will create a MongoDB user for your application.</p>

<h2 id="step-6-—-creating-a-user-for-your-mongodb-database">Step 6 — Creating a User for Your MongoDB Database</h2>

<p>By default, MongoDB allows users to log in without credentials and grants unlimited privileges. In this step, you will secure your MongoDB database by creating a dedicated user to access it.</p>

<p>To do this, you will need the root username and password that you set in the <code>docker-compose.yml</code> file environment variables <code>MONGO_INITDB_ROOT_USERNAME</code> and <code>MONGO_INITDB_ROOT_PASSWORD</code> for the <code>mongodb</code> service. In general, it&rsquo;s better to avoid using the root administrative account when interacting with the database. Instead, you will create a dedicated database user for your Flask application, as well as a new database that the Flask app will be allowed to access.</p>

<p>To create a new user, first start an interactive shell on the <code>mongodb</code> container:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker exec -it <span class="highlight">mongodb</span> bash
</li></ul></code></pre>
<p>You use the <code>docker exec</code> command in order to run a command inside a running container along with the <code>-it</code> flag to run an interactive shell inside the container.</p>

<p>Once inside the container, log in to the MongoDB <strong>root</strong> administrative account:</p>
<pre class="code-pre custom_prefix second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="root@96f5a91fc0db:/#">mongo -u <span class="highlight">mongodbuser</span> -p
</li></ul></code></pre>
<p>You will be prompted for the password that you entered as the value for the <code>MONGO_INITDB_ROOT_PASSWORD</code> variable in the <code>docker-compose.yml</code> file. The password can be changed by setting a new value for the <code>MONGO_INITDB_ROOT_PASSWORD</code> in the <code>mongodb</code> service, in which case you will have to re-run the <code>docker-compose up -d</code> command.</p>

<p>Run the <code>show dbs;</code> command to list all databases:</p>
<pre class="code-pre custom_prefix third-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="mongodb&gt;">show dbs;
</li></ul></code></pre>
<p>You will see the following output:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>admin    0.000GB
config   0.000GB
local    0.000GB
5 rows in set (0.00 sec)
</code></pre>
<p>The <code>admin</code> database is a special database that grants administrative permissions to users. If a user has read access to the <code>admin</code> database, they will have read and write permissions to all other databases. Since the output lists the <code>admin</code> database, the user has access to this database and can therefore read and write to all other databases.</p>

<p>Saving the first to-do note will automatically <a href="https://docs.mongodb.com/manual/core/databases-and-collections/#create-a-database">create the MongoDB database</a>. MongoDB allows you to switch to a database that does not exist using the <code>use <span class="highlight">database</span></code> command. It creates a database when a document is saved to a collection. Therefore the database is not created here; that will happen when you save your first to-do note in the database from the API. Execute the <code>use</code> command to switch to the <code><span class="highlight">flaskdb</span></code> database:</p>
<pre class="code-pre custom_prefix third-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="mongodb&gt;">use flaskdb
</li></ul></code></pre>
<p>Next, create a new user that will be allowed to access this database:</p>
<pre class="code-pre custom_prefix third-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="mongodb&gt;">db.createUser({user: '<span class="highlight">flaskuser</span>', pwd: '<span class="highlight">your password</span>', roles: [{role: 'readWrite', db: '<span class="highlight">flaskdb</span>'}]})
</li><li class="line" prefix="mongodb&gt;">exit
</li></ul></code></pre>
<p>This command creates a user named <span class="highlight"><strong>flaskuser</strong></span> with <code>readWrite</code> access to the <code>flaskdb</code> database. Be sure to use a secure password in the <code>pwd</code> field. The <code>user</code> and <code>pwd</code> here are the values you defined in the <code>docker-compose.yml</code> file under the environment variables section for the <code>flask</code> service.</p>

<p>Log in to the authenticated database with the following command:</p>
<pre class="code-pre command third-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mongo -u <span class="highlight">flaskuser</span> -p <span class="highlight">your password</span> --authenticationDatabase flaskdb
</li></ul></code></pre>
<p>Now that you have added the user, log out of the database.</p>
<pre class="code-pre custom_prefix third-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="mongodb&gt;">exit
</li></ul></code></pre>
<p>And finally, exit the container:</p>
<pre class="code-pre custom_prefix second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="root@96f5a91fc0db:/#">exit
</li></ul></code></pre>
<p>You&rsquo;ve now configured a dedicated database and user account for your Flask application. The database components are ready, so now you can move on to running the Flask to-do app.</p>

<h2 id="step-7-—-running-the-flask-to-do-app">Step 7 — Running the Flask To-do App</h2>

<p>Now that your services are configured and running, you can test your application by navigating to <code>http://<span class="highlight">your_server_ip</span></code> in a browser. Additionally, you can run <code>curl</code> to see the JSON response from Flask:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">curl -i http://<span class="highlight">your_server_ip</span>
</li></ul></code></pre>
<p>You will receive the following response:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>{"message":"Welcome to the Dockerized Flask MongoDB app!","status":true}
</code></pre>
<p>The configuration for the Flask application is passed to the application from the <code>docker-compose.yml</code> file. The configuration regarding the database connection is set using the <code>MONGODB_*</code> variables defined in the <code>environment</code> section of the <code>flask</code> service.</p>

<p>To test everything out, create a to-do note using the Flask API. You can do this with a <code>POST</code> curl request to the <code>/todo</code> route:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">curl -i -H "Content-Type: application/json" -X POST -d '{"todo": "Dockerize Flask application with MongoDB backend"}' http://<span class="highlight">your_server_ip</span>/todo
</li></ul></code></pre>
<p>This request results in a response with a status code of <code>201 CREATED</code> when the to-do item is saved to MongoDB:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>{"message":"To-do saved successfully!","status":true}
</code></pre>
<p>You can list all of the to-do notes from MongoDB with a GET request to the <code>/todo</code> route:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">curl -i <span class="highlight">http://your_server_ip/todo</span>
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>{"data":[{"id":"5c9fa25591cb7b000a180b60","todo":"Dockerize Flask application with MongoDB backend"}],"status":true}
</code></pre>
<p>With this, you have Dockerized a Flask API running a MongoDB backend with Nginx as a reverse proxy deployed to your servers. For a production environment you can use <code>sudo systemctl enable docker</code> to ensure your Docker service automatically starts at runtime. </p>

<h2 id="conclusion">Conclusion</h2>

<p>In this tutorial, you deployed a Flask application with Docker, MongoDB, Nginx, and Gunicorn. You now have a functioning modern stateless API application that can be scaled. Although you can achieve this result by using a command like <code>docker container run</code>, the <code>docker-compose.yml</code> simplifies your job as this stack can be put into version control and updated as necessary.</p>

<p>From here you can also take a look at our further <a href="https://www.digitalocean.com/community/tags/python-frameworks?type=tutorials">Python Framework tutorials</a>.</p>
