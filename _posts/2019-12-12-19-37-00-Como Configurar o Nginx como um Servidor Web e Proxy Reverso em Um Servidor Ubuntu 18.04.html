---
layout: post
title: Como Configurar o Nginx como um Servidor Web e Proxy Reverso em Um Servidor Ubuntu 18.04
network: digitalocean
date: December 12, 2019 at 07:37PM
url: https://www.digitalocean.com/community/tutorials/how-to-configure-nginx-as-a-web-server-and-reverse-proxy-for-apache-on-one-ubuntu-18-04-server-pt
image: https://assets.digitalocean.com/articles/nginx_apache_ubuntu_1804/qQcGNe8.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<p><em>O autor selecionou a <a href="https://www.brightfunds.org/organizations/electronic-frontier-foundation-inc">Fundação Electronic Frontier</a> para receber uma doação como parte do programa <a href="https://do.co/w4do-cta">Write for DOnations.</a></em></p>

<h3 id="introdução">Introdução</h3>

<p>O Apache e o Nginx são dois servidores Web populares, frequentemente usados com PHP. Pode ser útil executar ambos na mesma máquina virtual quando hospedar vários sites que tenham requisitos variados. A solução geral para executar dois servidores Web em um único sistema é ou usar endereços IP multiplos ou números de porta diferentes.</p>

<p>Servidores que têm tanto endereço IPv4 como IPv6 podem ser configurados para atender sites Apache em um protocolo e sites Nginx no outro, mas isso não é atualmente prático, uma vez que a adoção de IPv6 por ISPs ainda não está difundida. Ter um número de porta diferente, como <code>81</code> ou <code>8080</code> para o segundo servidor Web é outra solução, mas compartilhar URLs com números de porta (como <code>http://example.com:81</code>)  nem sempre é sensato ou ideal.</p>

<p>Neste tutorial você irá configurar o Nginx como tanto um servidor Web como um proxy reverso para o Apache – tudo em um único servidor.</p>

<p>Dependendo do aplicativo Web, alterações de código podem ser necessárias para manter o Apache ciente do proxy reverso, especialmente quando os sites SSL são configurados. Para evitar isso, você irá instalar um módulo Apache chamado <code>mod_rpaf</code> que reescreve certas variáveis de ambiente, para que pareça que o Apache está lidando diretamente com pedidos de clientes Web.</p>

<p>Vamos hospedar quatro nomes de domínios em um servidor. Dois serão atendidos pelo Nginx: <code>example.com</code> (o host virtual padrão) e <code>sample.org</code>. Os dois restantes, <code>foobar.net</code> e <code>test.io</code>, serão atentidos pelo Apache. Também vamos configurar o Apache para atender aplicativos PHP usando o PHP-FPM, que oferece melhor desempenho sobre o <code>mod_php</code>.</p>

<h2 id="pré-requisitos">Pré-requisitos</h2>

<p>Para completar este tutorial, você precisará do seguinte:</p>

<ul>
<li>Um servidor Ubuntu 18.04 novo configurado seguindo a <a href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04">Configuração Inicial de Servidor com Ubuntu 18.04</a>, com um usuário sudo não-root e um firewall.</li>
<li>Quatro nomes de domínio totalmente qualificados configurados para apontar ao endereço IP do seu servidor. Veja o Passo 3 de <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-host-name-with-digitalocean">Como Configurar um Nome de Host com o DigitalOcean</a>, como um exemplo de como fazer isso. Se você hospedar o DNS do seu domínio em outro lugar, você deve criar registros A apropriados lá.</li>
</ul>

<h2 id="passo-1-—-instalando-o-apache-e-o-php-fpm">Passo 1 — Instalando o Apache e o PHP-FPM</h2>

<p>Vamos começar instalando o Apache e o PHP-FPM.</p>

<p>Além do Apache e do PHP-FPM, também vamos instalar o módulo do Apache PHP FastCGI, <code>libapache2-mod-fastcgi</code>, para suportar aplicativos Web FastCGI.</p>

<p>Primeiramente, atualize sua lista de pacotes para garantir que você tenha os pacotes mais recentes.</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt update
</li></ul></code></pre>
<p>A seguir, instale os pacotes Apache e PHP-FPM:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt install apache2 php-fpm
</li></ul></code></pre>
<p>O módulo Apache FastCGI não está disponível no repositório do Ubuntu, então baixe-o do <a href="https://kernel.org">kernel.org</a> e instale-o usando o comando <code>dpkg</code>.</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">wget https://mirrors.edge.kernel.org/ubuntu/pool/multiverse/liba/libapache-mod-fastcgi/libapache2-mod-fastcgi_2.4.7~0910052141-1.2_amd64.deb
</li><li class="line" prefix="$">sudo dpkg -i libapache2-mod-fastcgi_2.4.7~0910052141-1.2_amd64.deb
</li></ul></code></pre>
<p>A seguir, vamos alterar a configuração padrão do Apache para usar o PHP-FPM.</p>

<h2 id="passo-2-—-configurando-o-apache-e-o-php-fpm">Passo 2 — Configurando o Apache e o PHP-FPM</h2>

<p>Neste passo, vamos alterar o número de porta do Apache para <code>8080</code> e configurá-lo para funcionar com o PHP-FPM usando o módulo <code>mod_fastcgi</code>. Renomeie o arquivo de configuração <code>ports.conf</code> do Apache:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo mv /etc/apache2/ports.conf /etc/apache2/ports.conf.default
</li></ul></code></pre>
<p>Crie um novo arquivo <code>ports.conf</code> com a porta definida para &ldquo;8080:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">echo "Listen <span class="highlight">8080</span>" | sudo tee /etc/apache2/ports.conf
</li></ul></code></pre>
<p><span class='note'><strong>Nota:</strong> servidores Web são geralmente definidos para ouvir no <code>127.0.0.1:8080</code> ao configurar um proxy reverso mas fazer isso definiria o valor da variável de ambiente do PHP <strong>SERVER_ADDR</strong> para o endereço IP do loopback ao invés do endereço IP público do servidor. Nosso objetivo é configurar o Apache de forma que seus sites não vejam um proxy reverso na frente dele. Então, vamos configurá-lo para escutar no <code>8080</code> em todos os endereços IP.<br></span></p>

<p>A seguir, vamos criar um arquivo de host virtual para o Apache. A diretiva neste arquivo será definida para atender sites apenas na porta <code>8080</code>.</p>

<p>Desabilite o host virtual padrão:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo a2dissite 000-default
</li></ul></code></pre>
<p>Então, crie um novo arquivo de host virtual, usando o site padrão existente:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo cp /etc/apache2/sites-available/000-default.conf /etc/apache2/sites-available/001-default.conf
</li></ul></code></pre>
<p>Agora abra o novo arquivo de configuração:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nano /etc/apache2/sites-available/001-default.conf
</li></ul></code></pre>
<p>Altere a porta de escuta para <code>8080</code>:</p>
<div class="code-label " title="/etc/apache2/sites-available/000-default.conf">/etc/apache2/sites-available/000-default.conf</div><pre class="code-pre "><code class="code-highlight language-apache">&lt;VirtualHost *:<span class="highlight">8080</span>&gt;
    ServerAdmin webmaster@localhost
    DocumentRoot /var/www/html
    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined
&lt;/VirtualHost&gt;
</code></pre>
<p>Salve o arquivo e ative o novo arquivo de configuração:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo a2ensite 001-default
</li></ul></code></pre>
<p>Então, recarregue o Apache:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl reload apache2
</li></ul></code></pre>
<p>Verifique se o Apache agora está escutando em <code>8080</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo netstat -tlpn
</li></ul></code></pre>
<p>O resultado deve se parecer com o exemplo a seguir, com <code>apache2</code> escutando em <code>8080</code>:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address     Foreign Address      State    PID/Program name
tcp        0      0 0.0.0.0:22        0.0.0.0:*            LISTEN   1086/sshd
<span class="highlight">tcp6       0      0 :::8080           :::*                 LISTEN   4678/apache2</span>
tcp6       0      0 :::22             :::*                 LISTEN   1086/sshd
</code></pre>
<p>Uma vez que você verifique que o Apache está escutando na porta correta, você pode configurar o suporte para o PHP e FastCGI.</p>

<h2 id="passo-3-—-configurando-o-apache-para-usar-o-mod_fastcgi">Passo 3 — Configurando o Apache para Usar o mod_fastcgi</h2>

<p>O Apache atende páginas PHP usando o <code>mod_php</code> por padrão, mas ele exige configuração adicional para funcionar com o PHP-FPM.</p>

<p><span class='note'><strong>Nota:</strong> Se você estiver testando este tutorial em uma instalação existente do LAMP com o mod_php, desative ela primeiro com <code>sudo a2dismod pp7.2</code>.<br></span></p>

<p>Vamos adicionar um bloco de configuração para o <code>mod_fastcgi</code> que depende do <code>mod_action</code>. <code>mod_action</code> é desativado por padrão, então primeiro precisamos habilitá-lo:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo a2enmod actions
</li></ul></code></pre>
<p>Renomeie o arquivo de configuração do FastCGI existente:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo mv /etc/apache2/mods-enabled/fastcgi.conf /etc/apache2/mods-enabled/fastcgi.conf.default
</li></ul></code></pre>
<p>Crie um novo arquivo de configuração:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nano /etc/apache2/mods-enabled/fastcgi.conf
</li></ul></code></pre>
<p>Adicione as diretivas a seguir ao arquivo para passar pedidos de arquivos <code>.php</code> ao socket UNIX do PHP-FPM:</p>
<div class="code-label " title="/etc/apache2/mods-enabled/fastcgi.conf">/etc/apache2/mods-enabled/fastcgi.conf</div><pre class="code-pre "><code class="code-highlight language-apache">&lt;IfModule mod_fastcgi.c&gt;
  AddHandler fastcgi-script .fcgi
  FastCgiIpcDir /var/lib/apache2/fastcgi
  AddType application/x-httpd-fastphp .php
  Action application/x-httpd-fastphp /php-fcgi
  Alias /php-fcgi /usr/lib/cgi-bin/php-fcgi
  FastCgiExternalServer /usr/lib/cgi-bin/php-fcgi -socket /run/php/php7.2-fpm.sock -pass-header Authorization
  &lt;Directory /usr/lib/cgi-bin&gt;
    Require all granted
  &lt;/Directory&gt;
&lt;/IfModule&gt;
</code></pre>
<p>Salve as alterações e faça um teste de configuração:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apachectl -t
</li></ul></code></pre>
<p>Recarregue o Apache se <strong>Syntax OK</strong> for exibido:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl reload apache2
</li></ul></code></pre>
<p>Se você ver o aviso <code>Could not reliably determine the server's fully qualified domain name, using 127.0.1.1. Set the 'ServerName' directive globally to suppress this message.</code>, você pode ignorá-lo de forma segura agora. Vamos configurar os nomes de servidor mais tarde.</p>

<p>Agora vamos garantir que podemos atender o PHP do Apache.</p>

<h2 id="passo-4-—-verificando-a-função-php">Passo 4 — Verificando a Função PHP</h2>

<p>Vamos garantir que o PHP funciona criando um arquivo <code>phpinfo()</code> e acessando-o de um navegador Web.</p>

<p>Crie o arquivo <code>/var/www/html/info.php</code> que contém uma chamada para a função <code>phpinfo</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">echo "&lt;?php phpinfo(); ?&gt;" | sudo tee /var/www/html/info.php
</li></ul></code></pre>
<p>Para ver o arquivo em um navegador, vá para <code>http://your_server_ip:8080/info.php. <span class="highlight"></span></code>Isso dará a você uma lista das configurações que o PHP está usando. Você verá um resultado similar a este:</p>

<p><img src="https://assets.digitalocean.com/articles/nginx_apache_ubuntu_1804/qQcGNe8.png" alt="phpinfo Server API"></p>

<p><img src="https://assets.digitalocean.com/articles/nginx_apache_ubuntu_1804/eBuDnVU.png" alt="phpinfo PHP Variables"></p>

<p>No topo da página, verifique se <strong>Server API</strong> exibe <strong>FPM/FastCGI</strong>. Cerca de dois terços da página abaixo, a seção <strong>PHP Variables</strong> irá dizer a você que <strong>SERVER_SOFTWARE</strong> é o Apache no Ubuntu. Estes confirmam que o <code>mod_fastcgi</code> está ativo e o Apache está usando o PHP-FPM para processar arquivos PHP.</p>

<h2 id="passo-5-—-criando-hosts-virtuais-para-o-apache">Passo 5 — Criando Hosts Virtuais para o Apache</h2>

<p>Vamos criar arquivos de host virtual do Apache para os domínios <code>foobar.net</code> e <code>test.io</code>. Para fazer isso, vamos primeiro criar diretórios root do documento para ambos os sites e colocar alguns arquivos padrão nesses diretórios para que possamos testar facilmente nossa configuração.</p>

<p>Primeiramente, crie os diretórios root do documento:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo mkdir -v /var/www/<span class="highlight">foobar.net</span> /var/www/<span class="highlight">test.io</span>
</li></ul></code></pre>
<p>Então, crie um arquivo <code>index</code> para cada site:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">echo "&lt;h1 style='color: green;'&gt;Foo Bar&lt;/h1&gt;" | sudo tee /var/www/<span class="highlight">foobar.net</span>/index.html
</li><li class="line" prefix="$">echo "&lt;h1 style='color: red;'&gt;Test IO&lt;/h1&gt;" | sudo tee /var/www/<span class="highlight">test.io</span>/index.html
</li></ul></code></pre>
<p>Então, crie um arquivo <code>phpinfo()</code> para cada site para que possamos testar se o PHP está configurado corretamente.</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">echo "&lt;?php phpinfo(); ?&gt;" | sudo tee /var/www/<span class="highlight">foobar.net</span>/info.php
</li><li class="line" prefix="$">echo "&lt;?php phpinfo(); ?&gt;" | sudo tee /var/www/<span class="highlight">test.io</span>/info.php
</li></ul></code></pre>
<p>Agora, crie o arquivo de host virtual para o domínio <code>foobar.net</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nano /etc/apache2/sites-available/foobar.net.conf
</li></ul></code></pre>
<p>Adicione o código a seguir ao arquivo para definir o host:</p>
<div class="code-label " title="/etc/apache2/sites-available/foobar.net.conf">/etc/apache2/sites-available/foobar.net.conf</div><pre class="code-pre "><code class="code-highlight language-apache">    &lt;VirtualHost *:8080&gt;
        ServerName <span class="highlight">foobar.net</span>
        ServerAlias www.<span class="highlight">foobar.net</span>
        DocumentRoot /var/www/<span class="highlight">foobar.net</span>
        &lt;Directory /var/www/<span class="highlight">foobar.net</span>&gt;
            AllowOverride All
        &lt;/Directory&gt;
    &lt;/VirtualHost&gt;
</code></pre>
<p>A linha <code>AllowOverride All</code> habilita o suporte do <code>.htaccess</code>.</p>

<p>Essas são apenas as diretivas mais básicas. Para um guia completo sobre a configuração de hosts virtuais no Apache, veja <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-apache-virtual-hosts-on-ubuntu-16-04">Como Configurar Hosts Virtuais do Apache no Ubuntu 16.04</a>.</p>

<p>Salve e feche o arquivo. Então, crie uma configuração similar para <code>test.io</code>. Primeiramente, crie o arquivo:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nano /etc/apache2/sites-available/test.io.conf
</li></ul></code></pre>
<p>Então, adicione a configuração ao arquivo:</p>
<div class="code-label " title="/etc/apache2/sites-available/test.io.conf">/etc/apache2/sites-available/test.io.conf</div><pre class="code-pre "><code class="code-highlight language-apache">    &lt;VirtualHost *:8080&gt;
        ServerName <span class="highlight">test.io</span>
        ServerAlias www.<span class="highlight">test.io</span>
        DocumentRoot /var/www/<span class="highlight">test.io</span>
        &lt;Directory /var/www/<span class="highlight">test.io</span>&gt;
            AllowOverride All
        &lt;/Directory&gt;
    &lt;/VirtualHost&gt;
</code></pre>
<p>Salve o arquivo e saia do editor.</p>

<p>Agora que ambos os hosts virtuais do Apache estão configurados, habilite os sites usando o comando <code>a2ensite</code>. Isso cria um link simbólico para o arquivo de host virtual no diretório <code>sites-enabled</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo a2ensite <span class="highlight">foobar.net</span>
</li><li class="line" prefix="$">sudo a2ensite <span class="highlight">test.io</span>
</li></ul></code></pre>
<p>Verifique o Apache quanto a erros de configuração novamente:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apachectl -t
</li></ul></code></pre>
<p>Você verá <strong>Syntax OK</strong> exibido se não houver erros. Se você ver outra coisa, reveja a configuração e tente novamente.</p>

<p>Recarregue o Apache para aplicar as alterações uma vez que sua configuração estiver livre de erros:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl reload apache2
</li></ul></code></pre>
<p>Para confirmar que os sites estão funcionando, abra <code>http://<span class="highlight">foobar.net</span>:8080</code> e <code>http://<span class="highlight">test.io</span>:8080</code> no seu navegador e verifique se cada site exibe seu arquivo <strong>index.html</strong>.</p>

<p>Você verá os resultados seguintes:</p>

<p><img src="https://assets.digitalocean.com/articles/nginx_apache_ubuntu_1804/2y1R8Zd.png" alt="foobar.net index page"></p>

<p><img src="https://assets.digitalocean.com/articles/nginx_apache_ubuntu_1804/wr1pzEj.png" alt="test.io index page"></p>

<p>Além disso, garanta que o PHP está funcionando acessando os arquivos <strong>info.php</strong> para cada site. Visite <code>http://<span class="highlight">foobar.net</span>:8080/info.php</code> e <code>http://<span class="highlight">test.io</span>:8080/info.php</code> no seu navegador.</p>

<p>Você verá a mesma lista de especificações de configuração do PHP em cada site como você viu no Passo 4.</p>

<p>Agora, temos dois sites hospedados no Apache na porta <code>8080</code>. Vamos configurar o Nginx a seguir.</p>

<h2 id="passo-6-—-instalando-e-configurando-o-nginx">Passo 6 — Instalando e Configurando o Nginx</h2>

<p>Neste passo, vamos instalar o Nginx e configurar os domínios <code>exemple.com</code> e <code>sample.org</code> como hosts virtuais do Nginx. Para um guia completo sobre a configuração de hosts virtuais no Nginx, veja <a href="https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-ubuntu-18-04#step-5-%E2%80%93-setting-up-server-blocks-(recommended)">Como Configurar Blocos de Servidor Nginx (Hosts Virtuais) no Ubuntu 18.04</a>.</p>

<p>Instale o Nginx usando o gerenciador de pacotes:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt install nginx
</li></ul></code></pre>
<p>Então, remova o symlink padrão do host virtual já que não vamos usá-lo mais:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo rm /etc/nginx/sites-enabled/default
</li></ul></code></pre>
<p>Vamos criar nosso próprio site padrão mais tarde (<code>exemple.com</code>).</p>

<p>Agora vamos criar hosts virtuais para o Nginx usando o mesmo procedimento que usamos para o Apache. Primeiramente, crie diretórios root de documento para ambos os sites:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo mkdir -v /usr/share/nginx/<span class="highlight">example.com</span> /usr/share/nginx/<span class="highlight">sample.org</span>
</li></ul></code></pre>
<p>Vamos manter os sites do Nginx em <code>/usr/share/nginx</code>, que é onde o Nginx os quer por padrão. Você pode colocá-los sob <code>/var/www/html</code> com os sites do Apache, mas essa separação pode ajudar a associar sites com o Nginx.</p>

<p>Como você fez com os hosts virtuais do Apache, crie arquivos <code>index</code> e <code>phpinfo()</code> para teste após a configuração estar completa:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">echo "&lt;h1 style='color: green;'&gt;Example.com&lt;/h1&gt;" | sudo tee /usr/share/nginx/<span class="highlight">example.com</span>/index.html
</li><li class="line" prefix="$">echo "&lt;h1 style='color: red;'&gt;Sample.org&lt;/h1&gt;" | sudo tee /usr/share/nginx/<span class="highlight">sample.org</span>/index.html
</li><li class="line" prefix="$">echo "&lt;?php phpinfo(); ?&gt;" | sudo tee /usr/share/nginx/<span class="highlight">example.com</span>/info.php
</li><li class="line" prefix="$">echo "&lt;?php phpinfo(); ?&gt;" | sudo tee /usr/share/nginx/<span class="highlight">sample.org</span>/info.php
</li></ul></code></pre>
<p>Agora, crie um arquivo de host virtual para o domínio <code>example.com</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nano /etc/nginx/sites-available/<span class="highlight">example.com</span>
</li></ul></code></pre>
<p>O Nginx chama por áreas do <code>server {. . .}</code> de um arquivo de configuração <strong>blocos de servidor</strong>. Crie um bloco de servidor para o host virtual primário, <code><span class="highlight">example.com</span></code>. A diretiva de configuração <code>default_server</code> torna padrão o host virtual que processa pedidos HTTP que não correspondam a nenhum outro host virtual.</p>
<div class="code-label " title="/etc/nginx/sites-available/example.com">/etc/nginx/sites-available/example.com</div><pre class="code-pre "><code class="code-highlight language-nginx">server {
    listen 80 default_server;

    root /usr/share/nginx/<span class="highlight">example.com</span>;
    index index.php index.html index.htm;

    server_name <span class="highlight">example.com www.example.com</span>;
    location / {
        try_files $uri $uri/ /index.php;
    }

    location ~ \.php$ {
        fastcgi_pass unix:/run/php/php7.2-fpm.sock;
        include snippets/fastcgi-php.conf;
    }
}
</code></pre>
<p>Salve e feche o arquivo. Agora, crie um arquivo de host virtual para o segundo domínio do Nginx, <code>sample.org</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nano etc/nginx/sites-available/<span class="highlight">sample.org</span>
</li></ul></code></pre>
<p>Adicione o que vem a seguir ao arquivo:</p>
<div class="code-label " title="/etc/nginx/sites-available/sample.org">/etc/nginx/sites-available/sample.org</div><pre class="code-pre "><code class="code-highlight language-nginx">server {
    root /usr/share/nginx/<span class="highlight">sample.org</span>;
    index index.php index.html index.htm;

    server_name <span class="highlight">sample.org www.sample.org</span>;
    location / {
        try_files $uri $uri/ /index.php;
    }

    location ~ \.php$ {
        fastcgi_pass unix:/run/php/php7.2-fpm.sock;
        include snippets/fastcgi-php.conf;
    }
}
</code></pre>
<p>Salve e feche o arquivo.</p>

<p>Então, habilite ambos os sites criando links simbólicos para o diretório <code>sites-enabled</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo ln -s /etc/nginx/sites-available/<span class="highlight">example.com</span> /etc/nginx/sites-enabled/<span class="highlight">example.com</span>
</li><li class="line" prefix="$">sudo ln -s /etc/nginx/sites-available/<span class="highlight">sample.org</span> /etc/nginx/sites-enabled/<span class="highlight">sample.org</span>
</li></ul></code></pre>
<p>Então, teste a configuração do Nginx para garantir que não existam problemas de configuração:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nginx -t
</li></ul></code></pre>
<p>Então, recarregue o Nginx se não houver erros:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl reload nginx
</li></ul></code></pre>
<p>Agora, acesse o arquivo <code>phpinfo()</code> de seus hosts virtuais do Nginx em um navegador Web visitando <code>http://example.com/info.php</code> e <code>http://sample.org/info.php</code>. Olhe sob as seções Variáveis PHP novamente.</p>

<p><img src="https://assets.digitalocean.com/articles/nginx_apache_ubuntu_1804/1FZeLUe.png" alt="Nginx PHP Variables"></p>

<p><strong>[&quot;SERVER_SOFTWARE&rdquo;]</strong> deve mostrar <code>nginx</code>, indicando que os arquivos foram diretamente atendidos pelo Nginx.<strong>[ &ldquo;DOCUMENT_ROOT&rdquo;]</strong> deve apontar para o diretório que você criou mais cedo neste passo para cada site do Nginx.</p>

<p>Até este ponto, instalamos o Nginx e criamos dois hosts virtuais. A seguir, vamos configurar o Nginx para pedidos de proxy destinados a domínios hospedados no Apache.</p>

<h2 id="passo-7-—-configurando-o-nginx-para-hosts-virtuais-do-apache">Passo 7 — Configurando o Nginx para Hosts Virtuais do Apache</h2>

<p>Vamos criar um host virtual adicional do Nginx com diferentes nomes de domínios nas diretivas <code>server_name</code>. Os pedidos para esses nomes de domínios serão enviadas por proxy para o Apache.</p>

<p>Crie um novo arquivo de host virtual do Nginx para transmitir pedidos ao Apache:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nano /etc/nginx/sites-available/<span class="highlight">apache</span>
</li></ul></code></pre>
<p>Adicione o seguinte bloco de código que especifica os nomes de ambos os domínios de host virtual do Apache e envia os pedidos por proxy ao Apache. Lembre-se de utilizar o endereço IP público em <code>proxy_pass</code>:</p>
<div class="code-label " title="/etc/nginx/sites-available/apache">/etc/nginx/sites-available/apache</div><pre class="code-pre "><code class="code-highlight language-nginx">server {
    listen 80;
    server_name <span class="highlight">foobar.net www.foobar.net test.io www.test.io</span>;

    location / {
        proxy_pass http://<span class="highlight">your_server_ip</span>:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
</code></pre>
<p>Salve o arquivo e habilite este novo host virtual criando um link simbólico:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo ln -s /etc/nginx/sites-available/apache /etc/nginx/sites-enabled/apache
</li></ul></code></pre>
<p>Teste a configuração para garantir que não haja erros:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nginx -t
</li></ul></code></pre>
<p>Se não houver erros, recarregue o Nginx:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl reload nginx
</li></ul></code></pre>
<p>Abra o navegador e acesse o URL <code>http://<span class="highlight">foobar.net</span>/info.php</code> no seu navegador. Role para a seção <strong>PHP Variables</strong> e verifique os valores exibidos.</p>

<p><img src="https://assets.digitalocean.com/articles/nginx_apache_ubuntu_1804/1XQi5kl.png" alt="phpinfo of Apache via Nginx"></p>

<p>As variáveis <strong>SERVER_SOFTWARE</strong> e <strong>DOCUMENT_ROOT</strong> confirmam que este pedido foi tratado por Apache. As variáveis <strong>HTTP_X_REAL_IP</strong> e <strong>HTTP_X_FORWARDED_FOR</strong> foram adicionadas pelo Nginx e devem mostrar o endereço IP público do computador que você está usando para acessar o URL.</p>

<p>Nós configuramos o Nginx com sucesso para pedidos de proxy para domínios específicos no Apache. A seguir, vamos configurar o Apache para definir a variável <code>REMOTE_ADDR</code> como se ele estivesse processando esses pedidos diretamente.</p>

<h2 id="passo-8-—-instalando-e-configurando-o-mod_rpaf">Passo 8 — Instalando e Configurando o mod_rpaf</h2>

<p>Neste passo, você irá instalar um módulo do Apache chamado <code>mod\_rpaf</code> que reescreve os valores do <strong>REMOTE_ADDR</strong>, <strong>HTTPS</strong> e <strong>HTTP_PORT</strong> baseado nos valores fornecidos por um proxy reverso. Sem este módulo, algumas aplicações PHP exigiriam alterações no código para funcionar perfeitamente sem estar por trás de um proxy. Este módulo está presente no repositório do Ubuntu como <code>libapache2-mod-rpaf</code> mas está desatualizado e não suporta certas diretivas de configuração. Ao invés disso, vamos instalá-lo da fonte.</p>

<p>Instale os pacotes necessários para construir o módulo:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt install unzip build-essential apache2-dev
</li></ul></code></pre>
<p>Faça download do lançamento estável mais recente do GitHub:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">wget https://github.com/gnif/mod_rpaf/archive/stable.zip
</li></ul></code></pre>
<p>Extraia o arquivo baixado:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">unzip stable.zip
</li></ul></code></pre>
<p>Mude para o novo diretório que contém os arquivos:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd mod_rpaf-stable
</li></ul></code></pre>
<p>Compile e instale o módulo:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">make
</li><li class="line" prefix="$">sudo make install
</li></ul></code></pre>
<p>A seguir, crie um arquivo no diretório <code>mods-available</code> que irá carregar o módulo <code>rpaf</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nano /etc/apache2/mods-available/rpaf.load
</li></ul></code></pre>
<p>Adicione o código a seguir ao arquivo para carregar o módulo:</p>
<div class="code-label " title="/etc/apache2/mods-available/rpaf.load">/etc/apache2/mods-available/rpaf.load</div><pre class="code-pre "><code class="code-highlight language-apache">LoadModule rpaf_module /usr/lib/apache2/modules/mod_rpaf.so
</code></pre>
<p>Salve o arquivo e saia do editor.</p>

<p>Crie outro arquivo neste diretório chamado <code>rpaf.conf</code> que irá conter as diretivas de configuração para o <code>mod_rpaf</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nano /etc/apache2/mods-available/rpaf.conf
</li></ul></code></pre>
<p>Adicione o bloco de código a seguir para configurar o <code>mod_rpaf</code>, certificando-se de especificar o endereço IP do seu servidor:</p>
<div class="code-label " title="/etc/apache2/mods-available/rpaf.conf">/etc/apache2/mods-available/rpaf.conf</div><pre class="code-pre "><code class="code-highlight language-apache">    &lt;IfModule mod_rpaf.c&gt;
        RPAF_Enable             On
        RPAF_Header             X-Real-Ip
        RPAF_ProxyIPs           <span class="highlight">your_server_ip</span> 
        RPAF_SetHostName        On
        RPAF_SetHTTPS           On
        RPAF_SetPort            On
    &lt;/IfModule&gt;
</code></pre>
<p>Aqui está uma descrição breve de cada diretiva. Veja o arquivo <a href="https://github.com/gnif/mod_rpaf/blob/stable/README.md#configuration-directives"><code>mod_rpaf</code> README</a> para mais informações.</p>

<ul>
<li>*<em>RPAF_Header *</em>- O cabeçalho a se usar para o endereço IP real do cliente.</li>
<li>*<em>RPAF_ProxyIPs *</em>- O IP do proxy para ajustar pedidos feitos pelo HTTP.</li>
<li>*<em>RPAF_SetHostName *</em>- Atualiza o nome vhost para que o <code>ServerName</code> e <code>ServerAlias</code> funcionem.</li>
<li><strong>RPAF_SetHTTPS</strong> - Define a variável ambiente <code>HTTPS</code> baseada no valor contido em <code>X-Forwarded-Proto</code>.</li>
<li><strong>RPAF_SetPort</strong> - Define a variável ambiente <code>SERVER_PORT</code>. Útil para quando o Apache está por trás de um proxy SSL.</li>
</ul>

<p>Salve o <code>rpaf.conf</code> e habilite o módulo:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo a2enmod rpaf
</li></ul></code></pre>
<p>Isso cria links simbólicos dos arquivos <code>rpaf.load</code> e <code>rpaf.conf</code> no diretório <code>mods-enabled</code>. Agora, faça um teste de configuração:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apachectl -t
</li></ul></code></pre>
<p>Recarregue o Apache se não houver erros:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl reload apache2
</li></ul></code></pre>
<p>Acesse as páginas do <code>phpinfo()</code> <code>http://<span class="highlight">foobar.net</span>/info.php</code> e <code>http://<span class="highlight">test.io</span>/info.php</code> no seu navegador e verifique a seção <strong>PHP Variables</strong>. A variável <strong>REMOTE_ADDR</strong> também será agora aquela do endereço IP público do seu computador local.</p>

<p>Agora vamos configurar a criptografia TLS/SSL para cada site.</p>

<h2 id="passo-9-—-configurando-websites-https-com-o-let-39-s-encrypt-opcional">Passo 9 — Configurando Websites HTTPS com o Let&rsquo;s Encrypt (Opcional)</h2>

<p>Neste passo, vamos configurar certificados TLS/SSL para ambos os domínios hospedados no Apache. Iremos obter os certificados através do <a href="https://letsencrypt.org">Let&rsquo;s Encrypt</a>. O Nginx suporta a terminação SSL então podemos configurar o SSL sem modificar arquivos de configuração do Apache. O módulo <code>mod_rpaf</code> garante que as variáveis ambiente necessárias estão definidas no Apache para fazer aplicativos funcionarem perfeitamente por trás de um proxy reverso SSL.</p>

<p>Primeiramente, vamos separar os blocos <code>server {...}</code> de ambos os domínios para que cada um deles possa ter seus próprios certificados SSL. Abra o arquivo <code>/etc/nginx/sites-available/apache</code> no seu editor:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nano /etc/nginx/sites-available/apache
</li></ul></code></pre>
<p>Modifique o arquivo para que ele se pareça com este, com <code>foobar.net</code> e <code>test.io</code> em seus próprios blocos <code>server</code>:</p>
<div class="code-label " title="/etc/nginx/sites-available/apache">/etc/nginx/sites-available/apache</div><pre class="code-pre "><code class="code-highlight language-nginx">    server {
        listen 80;
        server_name <span class="highlight">foobar.net www.foobar.net</span>;

        location / {
            proxy_pass http://<span class="highlight">your_server_ip</span>:8080;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
    server {
        listen 80;
        server_name <span class="highlight">test.io www.test.io</span>;

        location / {
            proxy_pass http://<span class="highlight">your_server_ip</span>:8080;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
</code></pre>
<p>Usaremos o <a href="https://certbot.eff.org">Certbot</a> para gerar nossos certificados TLS/SSL. O plug-in Nginx cuidará da reconfiguração do Nginx e recarregará a configuração sempre que necessário.</p>

<p>Primeiramente, adicione o repositório oficial do Certbot:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo add-apt-repository ppa:certbot/certbot
</li></ul></code></pre>
<p>Pressione <code>ENTER</code> quando solicitado para confirmar que você quer adicionar o novo repositório. Então, atualize a lista de pacotes para recolher informações do novo repositório:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt update
</li></ul></code></pre>
<p>Então, instale o pacote Nginx do Certbot com o <code>apt</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt install python-certbot-nginx
</li></ul></code></pre>
<p>Uma vez instalado, use o comando <code>certbot</code> para gerar os certificados para <code>foobar.net</code> e <code>www.foobar.net</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo certbot --nginx -d <span class="highlight">foobar.net</span> -d <span class="highlight">www.foobar.net</span>
</li></ul></code></pre>
<p>Este comando diz ao Certbot para usar o plug-in <code>nginx</code> usando <code>-d</code> para especificar os nomes para os quais gostaríamos que o certificado seja válido.</p>

<p>Se essa é a primeira vez que você executa o <code>certbot</code>, você será solicitado a informar um endereço de e-mail e concordar com os termos de serviço. Após fazer isso, o <code>certbot</code> se comunicará com o servidor da Let&rsquo;s Encrypt, executando posteriormente um desafio para verificar se você controla o domínio para o qual está solicitando um certificado.</p>

<p>Em seguida, o Certbot perguntará como você gostaria de definir suas configurações de HTTPS:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Please choose whether or not to redirect HTTP traffic to HTTPS, removing HTTP access.
-------------------------------------------------------------------------------
1: No redirect - Make no further changes to the webserver configuration.
2: Redirect - Make all requests redirect to secure HTTPS access. Choose this for
new sites, or if you're confident your site works on HTTPS. You can undo this
change by editing your web server's configuration.
-------------------------------------------------------------------------------
Select the appropriate number [1-2] then [enter] (press 'c' to cancel):
</code></pre>
<p>Selecione sua escolha e, então, pressione <code>ENTER</code>. A configuração será atualizada e o Nginx irá recarregar para recolher as novas configurações.</p>

<p>Agora, execute o comando para o segundo domínio:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo certbot --nginx -d <span class="highlight">test.io</span> -d <span class="highlight">www.test.io</span>
</li></ul></code></pre>
<p>Acesse um dos domínios do Apache no seu navegador usando o <code>https://</code> prefix; visite <code>https:<span class="highlight">//foobar.net</span>/info.php</code> e você verá isso:</p>

<p><img src="https://assets.digitalocean.com/articles/nginx_apache_ubuntu_1804/KK6AmWV.png" alt="phpinfo ssl"></p>

<p>Olhe na seção <strong>PHP Variables</strong>. A variável <strong>SERVER_PORT</strong> foi definida para <strong>443</strong> e <strong>HTTPS</strong> definida para <strong>on</strong>, como se o Apache fosse diretamente acessado pelo HTTPS. Com essas variáveis definidas, aplicativos PHP não precisam ser configurados especialmente para funcionar por trás de um proxy reverso.</p>

<p>Agora vamos desativar o acesso direto ao Apache.</p>

<h2 id="passo-10-—-bloqueando-o-acesso-direto-ao-apache-opcional">Passo 10 — Bloqueando o Acesso Direto ao Apache (Opcional)</h2>

<p>Uma vez que o Apache está escutando na porta <code>8080</code> no endereço IP público, ele é acessível por todos. Isso pode ser bloqueado utilizando o seguinte comando IPtables nas definições do seu firewall.</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo iptables -I INPUT -p tcp --dport 8080 ! -s <span class="highlight">your_server_ip</span> -j REJECT --reject-with tcp-reset
</li></ul></code></pre>
<p>Certifique-se de usar o endereço IP do seu servidor no lugar do exemplo em vermelho. Assim que a porta <code>8080</code> estiver bloqueada no seu firewall, teste se o Apache é inacessível por ela. Abra seu navegador Web e tente acessar um dos nomes de domínios do Apache na porta <code>8080</code>. Por exemplo: http://<span class="highlight">example.com</span>:8080</p>

<p>O navegador deve exibir uma mensagem de erro &ldquo;Incapaz de conectar&rdquo; ou &ldquo;Página não está disponível&rdquo;. Com a opção IPtables <code>tcp-reset</code> funcionando, um intruso não veria diferença entre a porta <code>8080</code> e uma porta que não tenha tenha qualquer serviço nela.</p>

<p><span class='note'><strong>Nota:</strong> as regras IPtables não sobrevivem a uma reinicialização do sistema por padrão. Existem várias maneiras de preservar as regras IPtables, mas a mais fácil é usando <code>iptables-persistent</code> no repositório do Ubuntu. Explore <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-using-iptables-on-ubuntu-14-04">este artigo</a> para aprender mais sobre como configurar o IPTables.<br></span></p>

<p>Agora, vamos configurar o Nginx para atender arquivos estáticos nos sites do Apache.</p>

<h2 id="passo-11-atendendo-arquivos-estáticos-usando-o-nginx-opcional">Passo 11 - Atendendo Arquivos Estáticos Usando o Nginx (Opcional)</h2>

<p>Quando os proxies do Nginx solicitam domínios do Apache, ele envia todos os pedidos de arquivo daquele domínio ao Apache. O Nginx é mais rápido que o Apache em atender arquivos estáticos como imagens, folhas de estilo e JavaScript. Então vamos configurar o arquivo <code>apache</code> de host virtual do Nginx para atender diretamente arquivos estáticos mas enviar pedidos PHP ao Apache.</p>

<p>Abra o arquivo <code>/etc/nginx/sites-available/apache</code> no seu editor:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nano /etc/nginx/sites-available/apache
</li></ul></code></pre>
<p>Você precisará adicionar dois blocos adicionais <code>location</code> em cada bloco do servidor, além de modificar seções <code>location</code> existentes. Além disso, você precisará dizer ao Nginx onde encontrar os arquivos estáticos para cada site.</p>

<p>Se você decidiu não usar os certificados SSL e TLS, modifique seu arquivo para que ele se pareça com este:</p>
<div class="code-label " title="/etc/nginx/sites-available/apache">/etc/nginx/sites-available/apache</div><pre class="code-pre "><code class="code-highlight language-nginx">server {
    listen 80;
    server_name <span class="highlight">test.io www.test.io</span>;
    root /var/www/<span class="highlight">test.io</span>;
    index index.php index.htm index.html;

    location / {
        try_files $uri $uri/ /index.php;
    }

    location ~ \.php$ {
        proxy_pass http://<span class="highlight">your_server_ip</span>:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location ~ /\.ht {
        deny all;
    }
}

server {
    listen 80;
    server_name <span class="highlight">foobar.net www.foobar.net</span>;
    root /var/www/<span class="highlight">foobar.net</span>;
    index index.php index.htm index.html;

    location / {
        try_files $uri $uri/ /index.php;
    }

    location ~ \.php$ {
        proxy_pass http://<span class="highlight">your_ip_address</span>:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location ~ /\.ht {
        deny all;
    }
}
</code></pre>
<p>Se também quiser que o HTTPS esteja disponível, use como alternativa a seguinte configuração:</p>
<div class="code-label " title="/etc/nginx/sites-available/apache">/etc/nginx/sites-available/apache</div><pre class="code-pre "><code class="code-highlight language-nginx">server {
    listen 80;
    server_name <span class="highlight">test.io www.test.io</span>;
    root /var/www/<span class="highlight">test.io</span>;
    index index.php index.htm index.html;

    location / {
        try_files $uri $uri/ /index.php;
    }

    location ~ \.php$ {
        proxy_pass http://<span class="highlight">your_server_ip</span>:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location ~ /\.ht {
        deny all;
    }

    listen 443 ssl;
    ssl_certificate /etc/letsencrypt/live/<span class="highlight">test.io</span>/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/<span class="highlight">test.io</span>/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
}

server {
    listen 80;
    server_name <span class="highlight">foobar.net www.foobar.net</span>;
    root /var/www/<span class="highlight">foobar.net</span>;
    index index.php index.htm index.html;

    location / {
        try_files $uri $uri/ /index.php;
    }

    location ~ \.php$ {
        proxy_pass http://<span class="highlight">your_ip_address</span>:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location ~ /\.ht {
        deny all;
    }

    listen 443 ssl;
    ssl_certificate /etc/letsencrypt/live/<span class="highlight">foobar.net</span>/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/<span class="highlight">foobar.net</span>/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
}
</code></pre>
<p>A diretiva <code>try_files</code> faz com que o Nginx procure arquivos na root do documento e atenda-os diretamente. Se o arquivo tem uma extensão <code>.php</code>, o pedido é passado para o Apache. Mesmo se o arquivo não for encontrado na root do documento, o pedido é passado para o Apache para que características do aplicativo como permalinks funcionem sem problemas.</p>

<p><span class='warning'><strong>Aviso:</strong> A diretiva <code>location ~ /\.ht</code> é muito importante; isso impede o Nginx de servir o conteúdo de arquivos de configuração do Apache como <code>.htaccess</code> e <code>.htpasswd</code> que contenham informações sensíveis.<br></span></p>

<p>Salve o arquivo e faça um teste de configuração:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nginx -t
</li></ul></code></pre>
<p>Recarregue o Nginx se o teste for bem sucedido:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo service nginx reload
</li></ul></code></pre>
<p>Para verificar se tudo está funcionando, você pode examinar os arquivos de registro do Apache em <code>/var/log/apache2</code> e ver os pedidos <code>GET</code> para os arquivos <code>info.php</code> do <code>test.io</code> e <code>foobar.net</code>. Use o comando <code>tail</code> para ver as últimas linhas do arquivo, e use o switch <code>-f</code> para verificar alterações no arquivo:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo tail -f /var/log/apache2/other_vhosts_access.log
</li></ul></code></pre>
<p>Agora, visite <code>http://test.io/info.php</code> no seu navegador e então veja o resultado do registro. Você verá que o Apache está efetivamente respondendo:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>    <span class="highlight">test.io:80 your_server_ip</span> - - [01/Jul/2016:18:18:34 -0400] "GET /info.php HTTP/1.0" 200 20414 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.111 Safari/537.36"
</code></pre>
<p>Então, visite a página <code>index.html</code> para cada site e você não verá qualquer registro do Apache. O Nginx está atendendo-os.</p>

<p>Quando terminar de observar o arquivo de registro, pressione <code>CTRL+C</code> para parar de acompanhá-lo.</p>

<p>Com essa configuração, o Apache não será capaz de restringir o acesso a arquivos estáticos. O controle de acesso para arquivos estáticos precisaria ser configurado no arquivo de host virtual <code>apache</code> do Nginx, mas isso está além do âmbito deste tutorial.</p>

<h2 id="conclusão">Conclusão</h2>

<p>Agora, você tem um servidor Ubuntu com o Nginx atendendo <code>example.com</code> e <code>sample.org</code>, junto com o Apache atendendo <code>foobar.net</code> e <code>test.io</code>. Embora o Nginx esteja agindo como um serviço de proxy reverso para o Apache, o serviço proxy do Nginx é transparente e as conexões com os domínios do Apache parecem ser atendidas diretamente pelo próprio Apache. Você pode usar este método para servir sites seguros e estáticos.</p>
