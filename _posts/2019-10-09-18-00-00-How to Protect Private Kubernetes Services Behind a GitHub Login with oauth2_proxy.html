---
layout: post
title: How to Protect Private Kubernetes Services Behind a GitHub Login with oauth2_proxy
network: digitalocean
date: October 09, 2019 at 06:00PM
url: https://www.digitalocean.com/community/tutorials/how-to-protect-private-kubernetes-services-behind-a-github-login-with-oauth2_proxy
image: https://assets.digitalocean.com/articles/doks_private_oauth/W0VBgjC.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="introduction">Introduction</h3>

<p>Kubernetes <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/">ingresses</a> make it easy to expose web services to the internet. When it comes to private services, however, you will likely want to limit who can access them. <a href="https://pusher.github.io/oauth2_proxy/">oauth2_proxy</a> can serve as a barrier between the public internet and private services. oauth2_proxy is a reverse proxy and server that provides authentication using different providers, such as GitHub, and validates users by their email address or other properties.</p>

<p>In this tutorial you&rsquo;ll use oauth2_proxy with GitHub to protect your services.  When you&rsquo;re done, you will have an authorization system that looks like the one in the following diagram:</p>

<p><img src="https://assets.digitalocean.com/articles/doks_private_oauth/W0VBgjC.png" alt="A diagram of a request flow end-result"></p>

<h2 id="prerequisites">Prerequisites</h2>

<p>To complete this tutorial, you&rsquo;ll need:</p>

<ul>
<li>A Kubernetes cluster with two web services running with an Nginx ingress and Let&rsquo;s Encrypt. This tutorial builds on <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-an-nginx-ingress-with-cert-manager-on-digitalocean-kubernetes">How to Set Up an Nginx Ingress with Cert-Manager on DigitalOcean Kubernetes</a>. Be sure to follow it to the very end in order to complete this tutorial.</li>
<li>A <a href="https://github.com">GitHub</a> account.</li>
<li>Python installed on your local machine. If you do not have it installed, follow the <a href="https://www.digitalocean.com/community/tags/python?type=tutorials#install-and-configure-python">installation instructions for your operating system</a>.</li>
</ul>

<h2 id="step-1-—-configuring-your-domains">Step 1 — Configuring Your Domains</h2>

<p>After following the tutorial linked in the Prerequisites section, you will have two web services running on your cluster: <code>echo1</code> and <code>echo2</code>. You will also have one ingress that maps <code>echo1.<span class="highlight">your_domain</span></code> and <code>echo2.<span class="highlight">your_domain</span></code> to their corresponding services.</p>

<p>In this tutorial, we will use the following conventions:</p>

<ul>
<li>All private services will fall under the <code>.int.<span class="highlight">your_domain</span></code> subdomain, like <code>service.int.<span class="highlight">your_domain</span></code>. Grouping private services under one subdomain is ideal because the authentication cookie will be shared across all <code>*.int.<span class="highlight">your_domain</span></code> subdomains.</li>
<li>The login portal will be served on <code>auth.int.<span class="highlight">your_domain</span></code>.</li>
</ul>

<p><span class='note'><strong>Note:</strong> Be sure to replace <code><span class="highlight">your_domain</span></code> with your own domain name wherever it appears in this tutorial.<br></span></p>

<p>To start, update the existing ingress definition to move the <code>echo1</code> and <code>echo2</code> services under <code>.int.<span class="highlight">your_domain</span></code>. Open <code>echo_ingress.yaml</code> in your text editor so you can change the domains:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano echo_ingress.yaml
</li></ul></code></pre>
<p>Rename all instances of <code>echo1.<span class="highlight">your_domain</span></code> to <code>echo1.int.<span class="highlight">your_domain</span></code>, and replace all instances of <code>echo2.<span class="highlight">your_domain</span></code> with <code>echo2.<span class="highlight">int.your_domain</span></code>:</p>
<div class="code-label " title="echo_ingress.yaml">echo_ingress.yaml</div><pre class="code-pre "><code langs="">apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: echo-ingress
  annotations:  
    kubernetes.io/ingress.class: nginx
    certmanager.k8s.io/cluster-issuer: letsencrypt-prod
spec:
  tls:
  - hosts:
    - echo1.<span class="highlight">int.your_domain</span>
    - echo2.<span class="highlight">int.your_domain</span>
    secretName: letsencrypt-prod
  rules:
  - host: echo1.<span class="highlight">int.your_domain</span>
    http:
      paths:
      - backend:
          serviceName: echo1
          servicePort: 80
  - host: echo2.<span class="highlight">int.your_domain</span>
    http:
      paths:
      - backend:
          serviceName: echo2
          servicePort: 80
</code></pre>
<p>Save the file and apply the changes:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f echo_ingress.yaml
</li></ul></code></pre>
<p>This will update the TLS certificates for your <code>echo1</code> and <code>echo2</code> services as well.</p>

<p>Now update your DNS configuration to reflect the changes you made. First, look up the IP address of your Nginx ingress by running the following command to print its details:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get svc --namespace=ingress-nginx
</li></ul></code></pre>
<p>You will see the IP address under <code>EXTERNAL-IP</code> in the output:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME            TYPE           CLUSTER-IP      EXTERNAL-IP       PORT(S)                      AGE
ingress-nginx   LoadBalancer   <span class="highlight">10.245.247.67</span>   <span class="highlight">203.0.113.0</span>   80:32486/TCP,443:32096/TCP   20h
</code></pre>
<p>Copy the external IP address to your clipboard. Browse to your DNS management service and locate the <strong>A</strong> records for <code>echo1-2.<span class="highlight">your_domain</span></code> to point to that external IP address. If you are using DigitalOcean to manage your DNS records, see <a href="https://www.digitalocean.com/docs/networking/dns/how-to/manage-records/">How to Manage DNS Records</a> for instructions.</p>

<p>Delete the records for <code>echo1</code> and <code>echo2</code>. Add a new <code>A</code> record for the hostname  <code>*.int.<span class="highlight">your_domain</span></code> and point it to the External IP address of the ingress.</p>

<p>Now any request to any subdomain under <code>*.int.<span class="highlight">your_domain</span></code> will be routed to the Nginx ingress, so you can use these subdomains within your cluster.</p>

<p>Next you&rsquo;ll configure GitHub as your login provider.</p>

<h2 id="step-2-—-creating-a-github-oauth-application">Step 2 — Creating a GitHub OAuth Application</h2>

<p>oauth2_proxy supports various login providers. In this tutorial, you will use the GitHub provider. To get started, create a new GitHub OAuth App. </p>

<p>In the <a href="https://github.com/settings/developers">OAuth Apps tab of the Developer settings</a> page of your account, click the <strong>New OAuth App</strong> button.</p>

<p>The <strong>Application name</strong> and <strong>Homepage URL</strong> fields can be anything you want. In the <strong>Authorization callback URL</strong> field, enter <code>https://auth.int.<span class="highlight">your_domain</span>/oauth2/callback</code>.</p>

<p>After registering the application, you will receive a Client ID and Secret. Note the two as you will need them in the next step.</p>

<p>Now that you&rsquo;ve created a GitHub OAuth application, you can install and configure oauth2_proxy.</p>

<h2 id="step-3-–-setting-up-the-login-portal">Step 3 – Setting Up the Login Portal</h2>

<p>You&rsquo;ll use Helm to install oauth2<em>proxy onto the cluster. First, you’ll create a Kubernetes secret to hold the GitHub application&rsquo;s Client ID and Secret, as well as an encryption secret for browser cookies set by oauth2</em>proxy.</p>

<p>Run the following command to generate a secure cookie secret:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">python -c 'import os,base64; print base64.b64encode(os.urandom(16))'
</li></ul></code></pre>
<p>Copy the result to your clipboard</p>

<p>Then, create the Kubernetes secret, substituting the highlighted values for your cookie secret, your GitHub client ID, and your GitHub secret key:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl -n default create secret generic oauth2-proxy-creds \
</li><li class="line" prefix="$">--from-literal=cookie-secret=<span class="highlight">YOUR_COOKIE_SECRET</span> \
</li><li class="line" prefix="$">--from-literal=client-id=<span class="highlight">YOUR_GITHUB_CLIENT_ID</span> \
</li><li class="line" prefix="$">--from-literal=client-secret=<span class="highlight">YOUR_GITHUB_SECRET</span>
</li></ul></code></pre>
<p>You&rsquo;ll see the following output:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>secret/oauth2-proxy-creds created
</code></pre>
<p>Next, create a new file named <code>oauth2-proxy-config.yaml</code> which will contain the configuration for <code>oauth2_proxy</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano oauth2-proxy-config.yaml
</li></ul></code></pre>
<p>The values you’ll set in this file will override the Helm chart&rsquo;s defaults. Add the following code to the file:</p>
<div class="code-label " title="oauth2-proxy-config.yaml">oauth2-proxy-config.yaml</div><pre class="code-pre yaml"><code langs="">config:
  existingSecret: oauth2-proxy-creds

extraArgs:
  whitelist-domain: .int.<span class="highlight">your_domain</span>
  cookie-domain: .int.<span class="highlight">your_domain</span>
  provider: github

authenticatedEmailsFile:
  enabled: true
  restricted_access: |-
    <span class="highlight">allowed@user1.com</span>
    <span class="highlight">allowed@user2.com</span>

ingress:
  enabled: true
  path: /
  hosts:
    - auth.int.<span class="highlight">your_domain</span>
  annotations:
    kubernetes.io/ingress.class: nginx
    certmanager.k8s.io/cluster-issuer: letsencrypt-prod
  tls:
    - secretName: oauth2-proxy-https-cert
      hosts:
        - auth.int.<span class="highlight">your_domain</span>
</code></pre>
<p>This code does the following:</p>

<ol>
<li>Instructs oauth2_proxy to use the secret you created.</li>
<li>Sets the domain name and provider type.</li>
<li>Sets a list of allowed email addresses. If a GitHub account is associated with one of these email addresses, it will be allowed access to the private services.</li>
<li>Configures the ingress that will serve the login portal on <code>auth.int.<span class="highlight">your_domain</span></code> with a TLS certificate from Let&rsquo;s Encrypt.</li>
</ol>

<p>Now that you have the secret and configuration file ready, you can install <code>oauth2_proxy</code>. Run the following command:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">helm repo update \
</li><li class="line" prefix="$">&amp;&amp; helm upgrade oauth2-proxy --install stable/oauth2-proxy \
</li><li class="line" prefix="$">--reuse-values \
</li><li class="line" prefix="$">--values oauth2-proxy-config.yaml
</li></ul></code></pre>
<p>It might take a few minutes for the Let&rsquo;s Encrypt certificate to be issued and installed.</p>

<p>To test that the deployment was successful, browse to <code>https://auth.int.<span class="highlight">your_domain</span></code>. You&rsquo;ll see a page that prompts you to log in with GitHub. </p>

<p>With oauth2_proxy set up and running, all that is left is to require authentication on your services.</p>

<h2 id="step-4-—-protecting-the-private-services">Step 4 — Protecting the Private Services</h2>

<p>In order to protect a service, configure its Nginx ingress to enforce authentication via oauth2_proxy. Nginx and nginx-ingress support this configuration natively, so you only need to add a couple of annotations to the ingress definition.</p>

<p>Let’s protect the <code>echo1</code> and <code>echo2</code> services that you set up in the prerequisite tutorial. Open <code>echo_ingress.yaml</code> in your editor:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano echo_ingress.yaml
</li></ul></code></pre>
<p>Add these two additional annotations to the file to require authentication:</p>
<div class="code-label " title="echo_ingress.yaml">echo_ingress.yaml</div><pre class="code-pre "><code langs="">   annotations:
     kubernetes.io/ingress.class: nginx
     certmanager.k8s.io/cluster-issuer: letsencrypt-prod
     <span class="highlight">nginx.ingress.kubernetes.io/auth-url: "https://auth.int.your_domain/oauth2/auth"</span>
     <span class="highlight">nginx.ingress.kubernetes.io/auth-signin: "https://auth.int.your_domain/oauth2/start?rd=https%3A%2F%2F$host$request_uri"</span>
</code></pre>
<p>Save the file and apply the changes:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f echo_ingress.yaml
</li></ul></code></pre>
<p>Now when you browse to <code>https://echo1.int.<span class="highlight">your_domain</span></code>, you will be asked to log in using GitHub in order to access it. After logging in with a valid account, you will be redirected back to the <code>echo1</code> service. The same is true for <code>echo2</code>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>In this tutorial, you set up oauth2_proxy on your Kubernetes cluster and protected a private service behind a GitHub login. For any other services you need to protect, simply follow the instructions outlined in Step 4.</p>

<p>oauth2_proxy supports many different providers other than GitHub. To learn more about different providers, see <a href="https://pusher.github.io/oauth2_proxy/auth-configuration">the official documentation</a>.</p>

<p>Additionally, there are many configuration parameters that you might need to adjust, although the defaults will suit most needs. For a list of parameters, see <a href="https://github.com/helm/charts/tree/master/stable/oauth2-proxy">the Helm chart&rsquo;s documentation</a> and <a href="https://pusher.github.io/oauth2_proxy/configuration">oauth2_proxy&rsquo;s documentation</a>.</p>
