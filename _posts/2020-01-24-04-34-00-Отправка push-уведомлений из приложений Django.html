---
layout: post
title: Отправка push-уведомлений из приложений Django
network: digitalocean
date: January 24, 2020 at 04:34AM
url: https://www.digitalocean.com/community/tutorials/how-to-send-web-push-notifications-from-django-applications-ru
image: https://assets.digitalocean.com/articles/django_push_18_04/web_push_final.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<p><em>Автор выбрал <a href="https://www.brightfunds.org/funds/open-internet-free-speech">фонд Open Internet/Free Speech</a> для получения пожертвования в рамках программы <a href="https://do.co/w4do-cta">Write for DOnations</a></em>.</p>

<h3 id="Введение">Введение</h3>

<p>Интернет постоянно меняется, и теперь он может получить функциональные возможности, которые ранее были доступны только непосредственно на мобильных устройствах. Появление в JavaScript инструмента <a href="https://developers.google.com/web/fundamentals/primers/service-workers/">service worker</a> дает вебу такие новые возможности, как выполнение фоновой синхронизации, кеширование оффлайн и отправка <a href="https://developer.mozilla.org/en/docs/Web/API/Push_API">push-уведомлений</a>.</p>

<p>Push-уведомления позволяют пользователям принимать новости от мобильных и веб-приложений. Также они позволяют пользователям поддерживать взаимодействие с существующими приложениями, используя персонализированные и релевантный контент.</p>

<p>В этом обучающем руководстве вы настроите приложение Django в Ubuntu 18.04, которое отправляет push-уведомления в случае любой активности, которая требует от пользователя посещения приложения. Для создания этих уведомлений вы будете использовать пакет <a href="https://github.com/safwanrahman/django-webpush">Django-Webpush</a> и должны будете настроить и зарегистрировать service worker для отображения уведомлений для клиента. Работающее приложение с уведомлениями будет выглядеть следующим образом:</p>

<p><img src="https://assets.digitalocean.com/articles/django_push_18_04/web_push_final.png" alt="Итоговый вид push-уведомления"></p>

<h2 id="Предварительные-требования">Предварительные требования</h2>

<p>Для прохождения этого обучающего руководства вам потребуется следующее:</p>

<ul>
<li>Сервер Ubuntu 18.04 с пользователем без прав root и активным брандмауэром. Вы можете воспользоваться указаниями из <a href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04">руководства по начальной настройке сервера</a> для получения дополнительной информации о создании сервера Ubuntu 18.04.</li>
<li><code>pip</code> и <code>venv</code>, установленные в соответствии с данными <a href="https://www.digitalocean.com/community/tutorials/how-to-install-the-django-web-framework-on-ubuntu-18-04#install-with-pip-in-a-virtual-environment">указаниями</a>.</li>
<li>Проект Django с именем <code><span class="highlight">djangopush</span></code>, созданный в домашней директории и настроенный в соответствии с указаниями <a href="https://www.digitalocean.com/community/tutorials/how-to-install-the-django-web-framework-on-ubuntu-18-04#creating-a-sample-project">руководства по созданию примера проекта Django в Ubuntu 18.04</a>. Обязательно <a href="https://www.digitalocean.com/community/tutorials/how-to-install-the-django-web-framework-on-ubuntu-18-04#modifying-allowed_hosts-in-the-django-settings">добавьте IP-адрес вашего сервера в директиву <code>ALLOWED_HOSTS</code></a> файла <code>settings.py</code>.</li>
</ul>

<h2 id="Шаг-1-—-Установка-django-webpush-и-получение-vapid-ключей">Шаг 1 — Установка Django-Webpush и получение VAPID ключей</h2>

<p>Django-Webpush — это пакет, позволяющий разработчикам интегрировать и отправлять push-уведомления в приложения Django. Мы будем использовать этот пакет для запуска и отправки push-уведомлений из нашего приложения. На этом шаге вы установите Django-Webpush и получите ключи <em>добровольной идентификации сервера приложения (Voluntary Application Server Identification, VAPID)</em>, которые необходимы для идентификации вашего сервера и обеспечения уникальности каждого запроса.</p>

<p>Вы обязательно должны находиться в директории проекта <code>~/<span class="highlight">djangopush</span></code>, которая была создана на этапе выполнения предварительных требований:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd ~/<span class="highlight">djangopush</span>
</li></ul></code></pre>
<p>Активируйте вашу виртуальную среду:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">source <span class="highlight">my_env</span>/bin/activate
</li></ul></code></pre>
<p>Обновите версию <code>pip</code> для гарантии ее актуальности:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">pip install --upgrade pip
</li></ul></code></pre>
<p>Установите Django-Webpush:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">pip install django-webpush
</li></ul></code></pre>
<p>После установки пакета добавьте его в список приложений в файле <code>settings.py</code>. Откройте файл <code>settings.py</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/djangopush/settings.py
</li></ul></code></pre>
<p>Добавьте <code>webpush</code> в список <code>INSTALLED_APPS</code>:</p>
<div class="code-label " title="~/djangopush/djangopush/settings.py">~/djangopush/djangopush/settings.py</div><pre class="code-pre "><code langs="">...

INSTALLED_APPS = [
    ...<span class="highlight">,</span>
   <span class="highlight"> 'webpush',</span>
]
...
</code></pre>
<p>Сохраните файл и закройте редактор.</p>

<p>Запустите <a href="https://docs.djangoproject.com/en/2.0/topics/migrations/">миграцию</a> в приложении для применения изменений, которые вы внесли в схему базы данных:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">python manage.py migrate
</li></ul></code></pre>
<p>Вывод будет выглядеть следующим образом при условии успешного выполнения миграции:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Operations to perform:
  Apply all migrations: admin, auth, contenttypes, sessions, webpush
Running migrations:
  Applying webpush.0001_initial... OK
</code></pre>
<p>Следующий шаг по настройке уведомлений — получение ключей VAPID. Эти ключи используются для идентификации сервера приложения и могут применяться для снижения секретности для URL-адресов подписки, поскольку они ограничивают подписку определенным сервером.</p>

<p>Чтобы получить ключи VAPID, перейдите к веб-приложению <a href="https://web-push-codelab.glitch.me/">wep-push-codelab</a>. Здесь вы получите автоматически сгенерированные ключи. Скопируйте закрытые и открытые ключи.</p>

<p>Далее создайте новую запись в файле <code>settings.py</code> для ваших данных о VAPID. Откройте файл:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/djangopush/settings.py
</li></ul></code></pre>
<p>Далее добавьте новую директиву с именем <code>WEBPUSH_SETTINGS</code> с публичными и частными VAPID ключами и ваш адрес электронной почты под <code>AUTH_PASSWORD_VALIDATORS:</code></p>
<div class="code-label " title="~/djangopush/djangopush/settings.py">~/djangopush/djangopush/settings.py</div><pre class="code-pre "><code class="code-highlight language-python">...

AUTH_PASSWORD_VALIDATORS = [
    ...
]

<span class="highlight">WEBPUSH_SETTINGS = {</span>
   <span class="highlight">"VAPID_PUBLIC_KEY": "your_vapid_public_key",</span>
   <span class="highlight">"VAPID_PRIVATE_KEY": "your_vapid_private_key",</span>
   <span class="highlight">"VAPID_ADMIN_EMAIL": "admin@example.com"</span>
<span class="highlight">}</span>

# Internationalization
# https://docs.djangoproject.com/en/2.0/topics/i18n/

...
</code></pre>
<p>Не забудьте заменить значения <code><span class="highlight">your_vapid_public_key</span></code>, <code><span class="highlight">your_vapid_private_key</span></code> и <code><span class="highlight">admin@example.com</span></code> на ваши данные. Ваш адрес электронной почты будет использоваться для отправки вам уведомлений при наличии проблем на сервере push-уведомлений.</p>

<p>Далее мы настроим представления, которые будут отображать домашнюю страницу приложения и запускать отправку push-уведомлений подписавшимся пользователям.</p>

<h2 id="Шаг-2-—-Настройка-представлений">Шаг 2 — Настройка представлений</h2>

<p>На этом шаге мы настроим базовое <a href="https://docs.djangoproject.com/en/2.1/topics/http/views/"><em>представление</em></a> <code>home</code> с <a href="https://docs.djangoproject.com/en/2.1/ref/request-response/#django.http.HttpRequest">объектом-ответом <code>HttpResponse</code></a> для нашей домашней страницы, а также представление <code>send_push</code>. Представления — это функции, которые будут возвращать для веб-запросов. Представление <code>send_push</code> будет использовать библиотеку Django-Webpush для отправки push-уведомлений, которые будут содержать данные, введенные пользователем на домашней странице.</p>

<p>Перейдите в папку <code>~/djangopush/djangopush</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">cd ~/djangopush/djangopush
</li></ul></code></pre>
<p>Запуск <code>ls</code> внутри папки будет отображать основные файлы проекта:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>/__init__.py
/settings.py
/urls.py
/wsgi.py
</code></pre>
<p>Файлы в этой папке генерируются автоматически утилитой <code>django-admin</code>, которую вы использовали для создания вашего проекта в предварительных требованиях. Файл <code>settings.py</code> содержит конфигурации для всего проекта, такие как установленные приложения и статичный корневой каталог. Файл <code>urls.py</code> содержит конфигурацию URL для проекта. Здесь вы будете настраивать маршруты согласно созданным вами представлениям.</p>

<p>Создайте в директории <code>~/djangopush/djangopush</code> с новый файл именем <code>views.py</code>, который будет хранить представления для вашего проекта:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/djangopush/views.py
</li></ul></code></pre>
<p>Первое представление, которое мы создадим, — это представление <code>home</code>, которое будет отображать домашнюю страницу, с которой пользователи смогут отправлять push-уведомления. Добавьте в файл следующий код:</p>
<div class="code-label " title="~/djangopush/djangopush/views.py">~/djangopush/djangopush/views.py</div><pre class="code-pre "><code class="code-highlight language-python">from django.http.response import HttpResponse
from django.views.decorators.http import require_GET

@require_GET
def home(request):
    return HttpResponse('&lt;h1&gt;Home Page&lt;h1&gt;')
</code></pre>
<p>Представление <code>home</code> оформляется с помощью декоратора <code>require_GET</code>, ограничивающего представление только для запросов GET. Как правило, представление возвращает ответ для каждого поступающего запроса. Это представление возвращает простой HTML тег в качестве ответа.</p>

<p>Далее мы создадим представление <code>send_push</code>, которое будет обрабатывать отправленные уведомления с помощью пакета <code>django-webpush</code>. Оно будет ограничено только запросами POST и будет выведено из-под защиты от <a href="https://docs.djangoproject.com/en/2.0/ref/csrf/">*межсайтовой подделки запроса *(CSRF)</a>. Это позволит протестировать представление с помощью <a href="https://www.getpostman.com/postman">Postman</a> или любой другой службы RESTful. Однако в реальном рабочем проекте вы должны удалить этот декоратор, чтобы защитить ваши представления от CSRF.</p>

<p>Чтобы создать представление <code>send_push</code>, нужно добавить следующие импорты, чтобы активировать ответы JSON и получить доступ к функции <code>send_user_notification</code> в библиотеке <code>webpush</code>:</p>
<div class="code-label " title="~/djangopush/djangopush/views.py">~/djangopush/djangopush/views.py</div><pre class="code-pre "><code class="code-highlight language-python">from django.http.response import <span class="highlight">JsonResponse</span>, HttpResponse
from django.views.decorators.http import require_GET, <span class="highlight">require_POST</span>
<span class="highlight">from django.shortcuts import get_object_or_404</span>
<span class="highlight">from django.contrib.auth.models import User</span>
<span class="highlight">from django.views.decorators.csrf import csrf_exempt</span>
<span class="highlight">from webpush import send_user_notification</span>
<span class="highlight">import json</span>
</code></pre>
<p>Далее добавьте декоратор <code>require_POST</code>, который будет использовать тело запроса, отправленного пользователем, для создания и отправки push-уведомления:</p>
<div class="code-label " title="~/djangopush/djangopush/views.py">~/djangopush/djangopush/views.py</div><pre class="code-pre "><code class="code-highlight language-python">@require_GET
def home(request):
    ...


@require_POST
@csrf_exempt
def send_push(request):
    try:
        body = request.body
        data = json.loads(body)

        if 'head' not in data or 'body' not in data or 'id' not in data:
            return JsonResponse(status=400, data={"message": "Invalid data format"})

        user_id = data['id']
        user = get_object_or_404(User, pk=user_id)
        payload = {'head': data['head'], 'body': data['body']}
        send_user_notification(user=user, payload=payload, ttl=1000)

        return JsonResponse(status=200, data={"message": "Web push successful"})
    except TypeError:
        return JsonResponse(status=500, data={"message": "An error occurred"})
</code></pre>
<p>Мы будем использовать два декоратора для представления <code>send_push</code>: декоратор <code>require_POST</code>, ограничивающий представление только для запросов POST, и декоратор <code>csrf_exempt</code>, выводящий представление из-под защиты от CSRF.</p>

<p>Это представление ожидает данные POST и делает следующее: получает <code>body</code> запроса и с помощью пакета <a href="https://docs.python.org/3/library/json.html">json</a> десериализует документ JSON и получает объект Python, используя <a href="https://docs.python.org/3.6/library/json.html"><code>json.loads</code></a>. <code>json.loads</code> получает структурированный документ JSON и преобразовывает его в объект Python.</p>

<p>Представление ожидает, что у поля объекта запроса будут три свойства:</p>

<ul>
<li><code>head</code>: заголовок push-уведомления.</li>
<li><code>body</code>: тело уведомления.</li>
<li><code>id</code>: <code>id</code> отправившего запрос пользователя.</li>
</ul>

<p>Если какое-либо из требуемых свойств отсутствует, представление будет возвращать <code>JSONResponse</code> со статусом 404 &ldquo;Not Found&rdquo;. Если пользователь с данным основным ключом существует, представление будет возвращать <code>user</code> с соответствующим основным ключом, используя <a href="https://docs.djangoproject.com/en/2.1/topics/http/shortcuts/#get-object-or-404">функцию <code>get_object_or_404</code></a> из библиотеки <code>django.shortcuts</code>. Если пользователь не существует, функция будет возвращать ошибку 404.</p>

<p>Также представление использует функцию <code>send_user_notification</code> из библиотеки <code>webpush</code>. Эта функция принимает три параметра:</p>

<ul>
<li><code>User: получатель push-уведомления.</code></li>
<li><code>payload</code>: информация уведомления, которая включает <code>head</code> и <code>body</code> уведомления.</li>
<li><code>ttl: максимальное время в секундах, в течение которого уведомление следует хранить, если польз</code>ователь находится оффлайн.</li>
</ul>

<p>При отсутствии ошибок представление возвращает <code>JSONResponse</code> со статусом 200 &ldquo;Success&rdquo; и объектом данных. При возникновении ошибки <code>KeyError</code> представление будет возвращать статус 500 &ldquo;Internal Server Error&rdquo;. Ошибка <code>KeyError</code> возникает при отсутствии запрошенного ключа объекта.</p>

<p>На следующем шаге мы создадим соответствующие маршруты URL для представлений, которые мы создали.</p>

<h2 id="Шаг-3-—-Разметка-url-адресов-для-представлений">Шаг 3 — Разметка URL-адресов для представлений</h2>

<p>Django позволяет создавать <a href="https://docs.djangoproject.com/en/2.0/topics/http/urls/">URL-адреса</a>, которые будут подключаться к представлениям с помощью модуля Python с именем <code>URLconf</code>. Этот модуль размечает выражения маршрута URL для функций Python (ваших представлений). Обычно файл конфигурации URL генерируется автоматически при создании проекта. На этом шаге вы будете обновлять этот файл для включения новых маршрутов для представлений, созданных на предыдущем шаге, а также URL-адресов для приложения <code>django-webpush</code>, которые будут предоставлять конечные точки для подписанных пользователей для push-уведомлений.</p>

<p>Дополнительную информацию о представлениях см. в руководстве <a href="https://www.digitalocean.com/community/tutorials/how-to-create-django-views">Создание представлений Django</a>.</p>

<p>Откройте <code>urls.py</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/djangopush/urls.py
</li></ul></code></pre>
<p>Файл будет выглядеть примерно так:</p>
<div class="code-label " title="~/djangopush/djangopush/urls.py">~/djangopush/djangopush/urls.py</div><pre class="code-pre "><code class="code-highlight language-python">
"""untitled URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/2.1/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path

urlpatterns = [
    path('admin/', admin.site.urls),
]
</code></pre>
<p>Следующим шагом будет разметка представлений с созданными вами URL-адресами. Во-первых, добавьте импорт <code>include</code>, чтобы гарантировать, что все маршруты для библиотеки Django-Webpush будут добавляться в ваш проект:</p>
<div class="code-label " title="~/djangopush/djangopush/urls.py">~/djangopush/djangopush/urls.py</div><pre class="code-pre "><code class="code-highlight language-python">
"""webpushdjango URL Configuration
...
"""
from django.contrib import admin
from django.urls import path, <span class="highlight">include</span>
</code></pre>
<p>Далее импортируйте представления, которые вы создали на последнем шаге, и обновите список <code>urlpatterns</code> для разметки представлений:</p>
<div class="code-label " title="~/djangopush/djangopush/urls.py">~/djangopush/djangopush/urls.py</div><pre class="code-pre "><code class="code-highlight language-python">
"""webpushdjango URL Configuration
...
"""
from django.contrib import admin
from django.urls import path, <span class="highlight">include</span>

<span class="highlight">from .views import home, send_push</span>

urlpatterns = [
                  path('admin/', admin.site.urls),
                  <span class="highlight">path('', home),</span>
                  <span class="highlight">path('send_push', send_push),</span>
                  <span class="highlight">path('webpush/', include('webpush.urls')),</span>
              ]
</code></pre>
<p>Здесь список <code>urlpatterns</code> регистрирует URL-адреса для пакета <code>django-webpush</code> и сопоставляет представления с URL-адресами <code>/send_push</code> и <code>/home</code>.</p>

<p>Давайте проверим представление <code>/home</code>, чтобы убедиться, что оно работает надлежащим образом. Убедитесь, что вы находитесь в корневой директории проекта:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">cd ~/djangopush
</li></ul></code></pre>
<p>Запустите ваш сервер с помощью следующей команды:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">python manage.py runserver <span class="highlight">your_server_ip</span>:8000
</li></ul></code></pre>
<p>Перейдите по адресу <code>http://<span class="highlight">your_server_ip</span>:8000</code>. Вы должны увидеть следующую домашнюю страницу:</p>

<p><img src="https://assets.digitalocean.com/articles/django_push_18_04/django_push_home.png" alt="Первоначальное представление домашней страницы"></p>

<p>В данный момент вы можете остановить сервер с помощью кнопок <code>CTRL+C</code>, потому что мы переходим к созданию шаблонов и их отображению в наших представлениях с помощью функции <code>render</code>.</p>

<h2 id="Шаг-4-—-Создание-шаблонов">Шаг 4 — Создание шаблонов</h2>

<p>Движок шаблонов Django позволяет определять отображаемые пользователям слои приложения с помощью шаблонов, которые аналогичны файлам HTML. На этом шаге вы создадите и отобразите шаблон для представления <code>home</code>.</p>

<p>Создайте папку с именем <code>templates</code> в корневой директории вашего проекта:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">mkdir ~/djangopush/templates
</li></ul></code></pre>
<p>Если вы запустите команду <code>ls</code> в корневой папке вашего проекта в текущий момент, вывод будет выглядеть примерно так:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>/djangopush
/templates
db.sqlite3
manage.py
/my_env
</code></pre>
<p>Создайте файл <code>home.html</code> в папке <code>templates</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/templates/home.html
</li></ul></code></pre>
<p>Добавьте следующий в файл для создания формы, в которую пользователи смогут вводить информацию для создания push-уведомлений:</p>
<pre class="code-pre "><code class="code-highlight language-html">{% load static %}
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
    &lt;meta name="vapid-key" content="{{ vapid_key }}"&gt;
    {% if user.id %}
        &lt;meta name="user_id" content="{{ user.id }}"&gt;
    {% endif %}
    &lt;title&gt;Web Push&lt;/title&gt;
    &lt;link href="https://fonts.googleapis.com/css?family=PT+Sans:400,700" rel="stylesheet"&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;div&gt;
    &lt;form id="send-push__form"&gt;
        &lt;h3 class="header"&gt;Send a push notification&lt;/h3&gt;
        &lt;p class="error"&gt;&lt;/p&gt;
        &lt;input type="text" name="head" placeholder="Header: Your favorite airline 😍"&gt;
        &lt;textarea name="body" id="" cols="30" rows="10" placeholder="Body: Your flight has been cancelled 😱😱😱"&gt;&lt;/textarea&gt;
        &lt;button&gt;Send Me&lt;/button&gt;
    &lt;/form&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><code>body</code> файла включает в себя форму с двумя полями: элемент <code>input</code> будет хранить заголовок/название уведомления, а элемент <code>textarea</code> будет хранить тело уведомления.</p>

<p>В разделе <code>head</code> в файле есть два тега <code>meta</code>, которые будут хранить публичный ключ VAPID и идентификатор пользователя. Эти две переменные требуются для регистрации пользователя и отправки ему push-уведомления. Здесь требуется идентификатор пользователя, поскольку вы будете направлять запросы AJAX на сервер, а <code>id</code> будет использоваться для идентификации пользователя. Если текущий пользователь является зарегистрированным пользователем, шаблон будет создавать тег <code>meta</code> с его <code>id</code> в качестве контента.</p>

<p>Следующим шагом нужно указать Django, где нужно хранить ваши шаблоны. Для этого нужно отредактировать файл <code>settings.py</code> и обновить список <code>TEMPLATES</code>.</p>

<p>Откройте файл <code>settings.py</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/djangopush/settings.py
</li></ul></code></pre>
<p>Добавьте следующие данные в список <code>DIRS</code> для указания пути к директории шаблонов:</p>
<div class="code-label " title="~/djangopush/djangopush/settings.py">~/djangopush/djangopush/settings.py</div><pre class="code-pre "><code class="code-highlight language-python">...
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [<span class="highlight">os.path.join(BASE_DIR, 'templates')</span>],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                ...
            ],
        },
    },
]
...
</code></pre>
<p>Затем в файле <code>views.py</code> обновите представление <code>home</code> для отображения шаблона <code>home.html</code>. Откройте файл:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangpush/djangopush/views.py
</li></ul></code></pre>
<p>Во-первых, добавьте ряд импортов, включая конфигурацию <code>settings</code>, которая содержит все параметры проекта из файла <code>settings.py</code> и функцию <code>render</code> из <code>django.shortcuts</code>:</p>
<div class="code-label " title="~/djangopush/djangopush/views.py">~/djangopush/djangopush/views.py</div><pre class="code-pre "><code class="code-highlight language-python">...
from django.shortcuts import <span class="highlight">render</span>, get_object_or_404
...
import json
<span class="highlight">from django.conf import settings</span>

...
</code></pre>
<p>Далее удалите первоначальный код, добавленный в представление <code>home</code>, и добавьте следующие данные, указывающие, как созданный вами шаблон будет отображаться:</p>
<div class="code-label " title="~/djangopush/djangopush/views.py">~/djangopush/djangopush/views.py</div><pre class="code-pre "><code class="code-highlight language-python">...

<a href="https://www.digitalocean.com/community/users/require_get" class="username-tag">@require_GET</a>
def home(request):
   <span class="highlight">webpush_settings = getattr(settings, 'WEBPUSH_SETTINGS', {})</span>
   <span class="highlight">vapid_key = webpush_settings.get('VAPID_PUBLIC_KEY')</span>
   <span class="highlight">user = request.user</span>
   <span class="highlight">return render(request, 'home.html', {user: user, 'vapid_key': vapid_key})</span>
</code></pre>
<p>Код присваивает значения для следующих переменных:</p>

<ul>
<li><code>webpush_settings</code>: данный параметр присваивает значение атрибута <code>WEBPUSH_SETTINGS</code> из конфигурации <code>settings</code>.</li>
<li><code>vapid_key:</code> этот элемент получает значение <code>VAPID_PUBLIC_KEY</code> из объекта <code>webpush_settings</code> для отправки клиенту. Данный публичный ключ сравнивается с закрытым ключом, чтобы убедиться, что клиент с публичным ключом может получать push-сообщения от сервера.</li>
<li><code>user</code>: эта переменка поступает из входящего запроса. Когда пользователь отправляет запрос на сервер, данные этого пользователя сохраняются в поле <code>user</code>.</li>
</ul>

<p><a href="https://docs.djangoproject.com/en/2.1/topics/http/shortcuts/#render">Функция <code>render</code></a> будет возвращать файл HTML и объект <a href="https://docs.djangoproject.com/en/2.1/ref/templates/api/#django.template.Context">context</a>, содержащий текущего пользователя и публичный ключ VAPID. Здесь требуются три параметра: <code>запрос</code>, <code>шаблон</code> для отображения и объект, который содержит переменные, используемые в шаблоне.</p>

<p>После создания нашего шаблона и обновления представления <code>home</code> мы можем перейти к настройке Django для обслуживания статичных файлов.</p>

<h2 id="Шаг-5-—-Обслуживание-статичных-файлов">Шаг 5 — Обслуживание статичных файлов</h2>

<p>Веб-приложения, включая CSS, JavaScript и другие файлы образа, которые Django воспринимает в качестве &ldquo;статичных файлов&rdquo;. Django позволяет собирать все статичные файлы из каждого приложения в вашем проекте в одном месте, из которого они будут обслуживаться. Это решение называется <code>django.contrib.staticfiles</code>. На этом шаге мы обновим наши настройки, чтобы указать Django, где наши статичные файлы будут храниться.</p>

<p>Откройте файл <code>settings.py</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/djangopush/settings.py
</li></ul></code></pre>
<p>В файле <code>settings.py</code> нужно убедиться, что значение <code>STATIC_URL</code> было определено:</p>
<div class="code-label " title="~/djangopush/djangopush/settings.py">~/djangopush/djangopush/settings.py</div><pre class="code-pre "><code class="code-highlight language-python">...
STATIC_URL = '/static/'
</code></pre>
<p>Далее добавьте список директорий с названием <code>STATICFILES_DIRS</code>, где Django будет искать статичные файлы:</p>
<div class="code-label " title="~/djangopush/djangopush/settings.py">~/djangopush/djangopush/settings.py</div><pre class="code-pre "><code class="code-highlight language-python">...
STATIC_URL = '/static/'
<span class="highlight">STATICFILES_DIRS = [</span>
    <span class="highlight">os.path.join(BASE_DIR, "static"),</span>
<span class="highlight">]</span>
</code></pre>
<p>Теперь вы можете добавить <code>STATIC_URL</code> в список путей, определенных в файле <code>urls.py</code>.</p>

<p>Откройте файл:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/djangopush/urls.py
</li></ul></code></pre>
<p>Добавьте следующий код, который будет импортировать  конфигурацию <code>static</code> URL-адресов и обновлять список <code>urlpatterns</code>. Вспомогательная функция здесь использует свойства <code>STATIC_URL</code> и <code>STATIC_ROOT</code>, которые мы предоставили в файле <code>settings.py</code> для обслуживания статичных файлов проекта:</p>
<div class="code-label " title="~/djangopush/djangopush/urls.py">~/djangopush/djangopush/urls.py</div><pre class="code-pre "><code class="code-highlight language-python">
...
<span class="highlight">from django.conf import settings</span>
<span class="highlight">from django.conf.urls.static import static</span>

urlpatterns = [
    ...
] <span class="highlight"> + static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)</span>
</code></pre>
<p>После настройки параметров статичных файлов мы можем перейти к определению стиля домашней страницы приложения.</p>

<h2 id="Шаг-6-—-Определение-стиля-домашней-страницы">Шаг 6 — Определение стиля домашней страницы</h2>

<p>После настройки вашего приложения для обслуживания статичных файлов вы можете создать внешнюю таблицу стилей и привязать ее к файлу <code>home.html</code> для определения стиля домашней страницы. Все ваши статичные файлы будут храниться в директории <code>static</code> корневой папки вашего проекта.</p>

<p>Создайте папку <code>static</code>, а внутри папки <code>static</code> создайте папку <code>css</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">mkdir -p ~/djangopush/static/css
</li></ul></code></pre>
<p>Откройте файл css с именем <code>styles.css</code> в папке <code>css</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/static/css/styles.css
</li></ul></code></pre>
<p>Добавьте следующие стили для домашней страницы:</p>
<div class="code-label " title="~/djangopush/static/css/styles.css">~/djangopush/static/css/styles.css</div><pre class="code-pre "><code class="code-highlight language-css">
body {
    height: 100%;
    background: rgba(0, 0, 0, 0.87);
    font-family: 'PT Sans', sans-serif;
}

div {
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
}

form {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 35%;
    margin: 10% auto;
}

form &gt; h3 {
    font-size: 17px;
    font-weight: bold;
    margin: 15px 0;
    color: orangered;
    text-transform: uppercase;
}

form &gt; .error {
    margin: 0;
    font-size: 15px;
    font-weight: normal;
    color: orange;
    opacity: 0.7;
}

form &gt; input, form &gt; textarea {
    border: 3px solid orangered;
    box-shadow: unset;
    padding: 13px 12px;
    margin: 12px auto;
    width: 80%;
    font-size: 13px;
    font-weight: 500;
}

form &gt; input:focus, form &gt; textarea:focus {
    border: 3px solid orangered;
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.2);
    outline: unset;
}

form &gt; button {
    justify-self: center;
    padding: 12px 25px;
    border-radius: 0;
    text-transform: uppercase;
    font-weight: 600;
    background: orangered;
    color: white;
    border: none;
    font-size: 14px;
    letter-spacing: -0.1px;
    cursor: pointer;
}

form &gt; button:disabled {
    background: dimgrey;
    cursor: not-allowed;
}
</code></pre>
<p>После создания таблицы стилей вы можете привязать ее к файлу <code>home.html</code>, используя <a href="https://docs.djangoproject.com/en/2.1/ref/templates/builtins/#std:templatetag-static">теги статичного шаблона</a>. Откройте файл <code>home.html</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/templates/home.html
</li></ul></code></pre>
<p>Обновите раздел <code>head</code> для включения в него ссылки на внешнюю таблицу стилей:</p>
<div class="code-label " title="~/djangopush/templates/home.html">~/djangopush/templates/home.html</div><pre class="code-pre "><code class="code-highlight language-html">
{% load static %}
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    ...
    <span class="highlight">&lt;link href="{% static '/css/styles.css' %}" rel="stylesheet"&gt;</span>
&lt;/head&gt;
&lt;body&gt;
    ...
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Убедитесь, что вы находитесь в директории основного проекта, и снова запустите ваш сервер для проверки работы:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">cd ~/djangopush
</li><li class="line" prefix="(my_env) $">python manage.py runserver <span class="highlight">your_server_ip</span>:8000
</li></ul></code></pre>
<p>При посещении <code>http://<span class="highlight">your_server_ip</span>:8080</code> страница должна выглядеть следующим образом:</p>

<p><img src="https://assets.digitalocean.com/articles/django_push_18_04/push_styled_home.png" alt="Представление домашней страницы"> Снова используйте сочетание клавиш <code>CTRL+C</code> для остановки сервера.</p>

<p>Теперь, когда вы успешно создали страницу <code>home.html</code> и добавили для нее таблицу стилей, вы можете оформить для пользователей подписку на push-уведомления, когда бы они ни посетили домашнюю страницу.</p>

<h2 id="Шаг-7-—-Регистрация-service-worker-и-подписка-пользователей-на-push-уведомления">Шаг 7 — Регистрация service worker и подписка пользователей на push-уведомления</h2>

<p>Push-уведомления в веб могут уведомлять пользователей о наличии обновлений для приложений, на которые они подписаны, или для напоминания о возможности вспомнить приложение, которое они использовали в прошлом. Они опираются на две технологии, API <a href="https://developer.mozilla.org/en-US/docs/Web/API/Push_API">push</a> и API <a href="https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API">notifications</a>. Обеим технологиям необходимо наличие service worker.</p>

<p>Push-уведомление отправляется, когда сервер предоставляет информацию для service worker, а service worker использует API уведомлений для отображения этой информации.</p>

<p>Мы будем подписывать наших пользователей на push-уведомления, а затем будем отправлять информацию из подписки на сервер для их регистрации.</p>

<p>В директории <code>static</code> создайте папку с именем <code>js</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">mkdir ~/djangopush/static/js
</li></ul></code></pre>
<p>Создайте файл с именем <code>registerSw.js</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/static/js/registerSw.js
</li></ul></code></pre>
<p>Добавьте следующий код, который проверяет, поддерживает ли service worker'ы в браузере пользователя, прежде чем пытаться регистрировать service worker:</p>
<div class="code-label " title="~/djangopush/static/js/registerSw.js">~/djangopush/static/js/registerSw.js</div><pre class="code-pre "><code class="code-highlight language-javascript">
const registerSw = async () =&gt; {
    if ('serviceWorker' in navigator) {
        const reg = await navigator.serviceWorker.register('sw.js');
        initialiseState(reg)

    } else {
        showNotAllowed("You can't send push notifications ☹️😢")
    }
};
</code></pre>
<p>Во-первых, функция <code>registerSw</code> проверяет, поддерживает ли браузер service worker'ы, прежде чем регистрировать их. После регистрации она вызывает функцию <code>initializeState</code> с данными регистрации. Если service worker'ы не поддерживаются в браузере, вызывается функция <code>showNotAllowed</code>.</p>

<p>Далее добавьте следующий код под функцией <code>registerSw</code> для проверки того, может ли пользователь получать push-уведомления, прежде чем пытаться подписать их:</p>
<div class="code-label " title="~/djangopush/static/js/registerSw.js">~/djangopush/static/js/registerSw.js</div><pre class="code-pre "><code class="code-highlight language-javascript">
...

const initialiseState = (reg) =&gt; {
    if (!reg.showNotification) {
        showNotAllowed('Showing notifications isn\'t supported ☹️😢');
        return
    }
    if (Notification.permission === 'denied') {
        showNotAllowed('You prevented us from showing notifications ☹️🤔');
        return
    }
    if (!'PushManager' in window) {
        showNotAllowed("Push isn't allowed in your browser 🤔");
        return
    }
    subscribe(reg);
}

const showNotAllowed = (message) =&gt; {
    const button = document.querySelector('form&gt;button');
    button.innerHTML = `${message}`;
    button.setAttribute('disabled', 'true');
};
</code></pre>
<p>Функция <code>initializeState</code> проверяет следующее:</p>

<ul>
<li>Активировал ли пользователь уведомления или нет, использование значения <code>reg.showNotification</code>.</li>
<li>Предоставил ли пользователь приложению разрешение на отображение уведомлений или нет.</li>
<li>Поддерживает ли браузер API <code>PushManager</code> или нет. Если какая-либо из этих проверок не будет пройдена, функция <code>showNotAllowed</code> вызывается, а подписка отменяется.</li>
</ul>

<p>Функция <code>showNotAllowed</code> отображает сообщение на кнопке и отключает его, если пользователь не имеет права принимать уведомления. Также она отображает соответствующие сообщения, если пользователь ограничил для приложения отображение уведомлений, либо если браузер не поддерживает push-уведомления.</p>

<p>После того как мы убедимся, что пользователь может получать push-уведомления, следующим шагом будет оформления подписки на уведомления с помощью команды <code>pushManager</code>. Добавьте следующий код под функцией <code>showNotAllowed</code>:</p>
<div class="code-label " title="~/djangopush/static/js/registerSw.js">~/djangopush/static/js/registerSw.js</div><pre class="code-pre "><code class="code-highlight language-javascript">
...

function urlB64ToUint8Array(base64String) {
    const padding = '='.repeat((4 - base64String.length % 4) % 4);
    const base64 = (base64String + padding)
        .replace(/\-/g, '+')
        .replace(/_/g, '/');

    const rawData = window.atob(base64);
    const outputArray = new Uint8Array(rawData.length);
    const outputData = outputArray.map((output, index) =&gt; rawData.charCodeAt(index));

    return outputData;
}

const subscribe = async (reg) =&gt; {
    const subscription = await reg.pushManager.getSubscription();
    if (subscription) {
        sendSubData(subscription);
        return;
    }

    const vapidMeta = document.querySelector('meta[name="vapid-key"]');
    const key = vapidMeta.content;
    const options = {
        userVisibleOnly: true,
        // if key exists, create applicationServerKey property
        ...(key &amp;&amp; {applicationServerKey: urlB64ToUint8Array(key)})
    };

    const sub = await reg.pushManager.subscribe(options);
    sendSubData(sub)
};
</code></pre>
<p>Вызов функции <code>pushManager.getSubscription</code> возвращает данные для активной подписки. При наличии активной подписки функция <code>sendSubData</code> вызывается, а информация подписки передается в качестве параметра.</p>

<p>При отсутствии активной подписки публичный ключ VAPID, который шифруется с помощью алгоритма Base64, преобразовывается в Uint8Array с помощью функции <code>urlB64TUint8Array</code>. Затем вызывается функция <code>pushManager.subscribe</code> с публичным ключом VAPID и значением <code>userVisible</code> в качестве опции. Вы можете ознакомиться с доступными опциями <a href="https://developers.google.com/web/fundamentals/push-notifications/subscribing-a-user#uservisibleonly_options">здесь</a>.</p>

<p>После успешной подписки пользователя следующим шагом будет отправка данных подписки на сервер. Эти данные будут направляться на конечную точку <code>webpush/save_information</code>, предоставленную пакетом <code>django-webpush</code>. Добавьте следующий код под функцией <code>subscribe:</code></p>
<div class="code-label " title="~/djangopush/static/js/registerSw.js">~/djangopush/static/js/registerSw.js</div><pre class="code-pre "><code class="code-highlight language-javascript">
...

const sendSubData = async (subscription) =&gt; {
    const browser = navigator.userAgent.match(/(firefox|msie|chrome|safari|trident)/ig)[0].toLowerCase();
    const data = {
        status_type: 'subscribe',
        subscription: subscription.toJSON(),
        browser: browser,
    };

    const res = await fetch('/webpush/save_information', {
        method: 'POST',
        body: JSON.stringify(data),
        headers: {
            'content-type': 'application/json'
        },
        credentials: "include"
    });

    handleResponse(res);
};

const handleResponse = (res) =&gt; {
    console.log(res.status);
};

registerSw();
</code></pre>
<p>Конечной точке <code>save_information</code> требуется информация о состоянии подписки (<code>subscribe</code> и <code>unsubscribe</code>), данные подписки и браузер. Наконец, мы вызываем функцию <code>registerSw()</code> для запуска процесса подписки пользователя.</p>

<p>Завершенный файл выглядит следующим образом:</p>
<div class="code-label " title="~/djangopush/static/js/registerSw.js">~/djangopush/static/js/registerSw.js</div><pre class="code-pre "><code class="code-highlight language-javascript">
const registerSw = async () =&gt; {
    if ('serviceWorker' in navigator) {
        const reg = await navigator.serviceWorker.register('sw.js');
        initialiseState(reg)

    } else {
        showNotAllowed("You can't send push notifications ☹️😢")
    }
};

const initialiseState = (reg) =&gt; {
    if (!reg.showNotification) {
        showNotAllowed('Showing notifications isn\'t supported ☹️😢');
        return
    }
    if (Notification.permission === 'denied') {
        showNotAllowed('You prevented us from showing notifications ☹️🤔');
        return
    }
    if (!'PushManager' in window) {
        showNotAllowed("Push isn't allowed in your browser 🤔");
        return
    }
    subscribe(reg);
}

const showNotAllowed = (message) =&gt; {
    const button = document.querySelector('form&gt;button');
    button.innerHTML = `${message}`;
    button.setAttribute('disabled', 'true');
};

function urlB64ToUint8Array(base64String) {
    const padding = '='.repeat((4 - base64String.length % 4) % 4);
    const base64 = (base64String + padding)
        .replace(/\-/g, '+')
        .replace(/_/g, '/');

    const rawData = window.atob(base64);
    const outputArray = new Uint8Array(rawData.length);
    const outputData = outputArray.map((output, index) =&gt; rawData.charCodeAt(index));

    return outputData;
}

const subscribe = async (reg) =&gt; {
    const subscription = await reg.pushManager.getSubscription();
    if (subscription) {
        sendSubData(subscription);
        return;
    }

    const vapidMeta = document.querySelector('meta[name="vapid-key"]');
    const key = vapidMeta.content;
    const options = {
        userVisibleOnly: true,
        // if key exists, create applicationServerKey property
        ...(key &amp;&amp; {applicationServerKey: urlB64ToUint8Array(key)})
    };

    const sub = await reg.pushManager.subscribe(options);
    sendSubData(sub)
};

const sendSubData = async (subscription) =&gt; {
    const browser = navigator.userAgent.match(/(firefox|msie|chrome|safari|trident)/ig)[0].toLowerCase();
    const data = {
        status_type: 'subscribe',
        subscription: subscription.toJSON(),
        browser: browser,
    };

    const res = await fetch('/webpush/save_information', {
        method: 'POST',
        body: JSON.stringify(data),
        headers: {
            'content-type': 'application/json'
        },
        credentials: "include"
    });

    handleResponse(res);
};

const handleResponse = (res) =&gt; {
    console.log(res.status);
};

registerSw();
</code></pre>
<p>Далее добавьте тег <code>script</code> для файла <code>registerSw.js</code> в <code>home.html</code>. Откройте файл:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/templates/home.html
</li></ul></code></pre>
<p>Добавьте тег <code>script</code> перед закрывающим тегом элемента <code>body</code>:</p>
<div class="code-label " title="~/djangopush/templates/home.html">~/djangopush/templates/home.html</div><pre class="code-pre "><code class="code-highlight language-html">
{% load static %}
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
   ...
&lt;/head&gt;
&lt;body&gt;
   ...
   <span class="highlight">&lt;script src="{% static '/js/registerSw.js' %}"&gt;&lt;/script&gt;</span>
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Поскольку service worker еще не существует, если бы вы оставили приложение запущенным или попытались запустить его снова, то увидели бы сообщение об ошибке. Давайте устраним эту проблему с помощью service worker.</p>

<h2 id="Шаг-8-—-Создание-service-worker">Шаг 8 — Создание service worker</h2>

<p>Для отображения push-уведомления вам потребуется активный service worker, установленный на домашней странице приложения. Мы создадим service worker, который прослушивает события <code>push</code> и отображает сообщения при готовности.</p>

<p>Поскольку мы хотим, чтобы service worker покрывал весь домен, нам нужно установить его в корневой директории приложения. В статье о <a href="https://developers.google.com/web/fundamentals/primers/service-workers/#register_a_service_worker">регистрации service worker</a> вы можете подробнее ознакомиться с процессом. Согласно нашему подходу будет создан файл <code>sw.js</code> в папке <code>templates</code>, который мы позднее зарегистрируем в качестве представления.</p>

<p>Создайте файл:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/templates/sw.js
</li></ul></code></pre>
<p>Добавьте следующий код, который указывает service worker на необходимость прослушивания push событий:</p>
<div class="code-label " title="~/djangopush/templates/sw.js">~/djangopush/templates/sw.js</div><pre class="code-pre "><code class="code-highlight language-javascript">
// Register event listener for the 'push' event.
self.addEventListener('push', function (event) {
    // Retrieve the textual payload from event.data (a PushMessageData object).
    // Other formats are supported (ArrayBuffer, Blob, JSON), check out the documentation
    // on https://developer.mozilla.org/en-US/docs/Web/API/PushMessageData.
    const eventInfo = event.data.text();
    const data = JSON.parse(eventInfo);
    const head = data.head || 'New Notification 🕺🕺';
    const body = data.body || 'This is default content. Your notification didn\'t have one 🙄🙄';

    // Keep the service worker alive until the notification is created.
    event.waitUntil(
        self.registration.showNotification(head, {
            body: body,
            icon: 'https://i.imgur.com/MZM3K5w.png'
        })
    );
});
</code></pre>
<p>Service worker следит за наличием push события. В функции обратного вызова данные <code>события</code> конвертируются в текст. Мы используем строки <code>title</code> и <code>body</code>, если в данных события они отсутствуют. Функция <code>showNotification</code> получает название уведомления, заголовок уведомления для отображения и объект <a href="https://developers.google.com/web/fundamentals/push-notifications/display-a-notification#visual_options">options</a> в качестве параметров. Объект options содержит несколько свойств для настройки визуальных параметров уведомления.</p>

<p>Чтобы service worker мог работать для всего домена, вам потребуется выполнить его установки в корневой директории приложения. Мы будем использовать <a href="https://docs.djangoproject.com/en/2.1/topics/class-based-views/"><code>TemplateView</code></a> для предоставления service worker доступа ко всему домену.</p>

<p>Откройте файл <code>urls.py</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/djangopush/urls.py
</li></ul></code></pre>
<p>Добавьте новое объявление импорта и путь в список <code>urlpatterns</code> для создания представления на основе классов:</p>
<div class="code-label " title="~/djangopush/djangopush/urls.py">~/djangopush/djangopush/urls.py</div><pre class="code-pre "><code class="code-highlight language-python">...
<span class="highlight">from django.views.generic import TemplateView</span>

urlpatterns = [
                  ...<span class="highlight">,</span>
                  <span class="highlight">path('sw.js', TemplateView.as_view(template_name='sw.js', content_type='application/x-javascript'))</span>
              ] + static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)
</code></pre>
<p>Представления на основе классов, такие как <code>TemplateView</code>, позволяют создавать гибкие и доступные для повторного использования представления. В этом случае метод <code>TemplateView.as_view</code> создает путь для service worker, передав недавно созданный service worker в качестве шаблона и <code>application/x-javascript</code> в качестве параметра <code>content_type</code> для шаблона.</p>

<p>Вы уже создали service worker и зарегистрировали его в качестве маршрута. Далее вы настроите форму на домашней странице для отправки push-уведомлений.</p>

<h2 id="Шаг-9-—-Отправка-push-уведомлений">Шаг 9 — Отправка push-уведомлений</h2>

<p>Используя форму на домашней странице, пользователи смогут отправлять push-уведомления, пока ваш сервер запущен. Также вы можете отправить push-уведомления с помощью любой службы RESTful, например, Postman. Когда пользователь отправляет push-уведомления из формы на домашней странице, данные будут включать <code>head</code> и <code>body</code>, а также <code>id</code> получателя. Данные должны быть структурированы следующим образом:</p>
<pre class="code-pre "><code class="code-highlight language-javascript">{
    head: "Title of the notification",
    body: "Notification body",
    id: "User's id"
}
</code></pre>
<p>Для прослушивания события <code>submit</code> формы и отправки данных, которые вводит пользователь, на сервер, мы создадим файл <code>site.js</code> в директории <code>~/djangopush/static/js</code>.</p>

<p>Откройте файл:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/static/js/site.js
</li></ul></code></pre>
<p>Во-первых, добавьте прослушивателя событий <code>submit</code> в форму, что позволит получить значения для вводимых данных в форме и идентификатор пользователя, который хранится в теге <code>meta</code> вашего шаблона:</p>
<div class="code-label " title="~/djangopush/static/js/site.js">~/djangopush/static/js/site.js</div><pre class="code-pre "><code class="code-highlight language-javascript">
const pushForm = document.getElementById('send-push__form');
const errorMsg = document.querySelector('.error');

pushForm.addEventListener('submit', async function (e) {
    e.preventDefault();
    const input = this[0];
    const textarea = this[1];
    const button = this[2];
    errorMsg.innerText = '';

    const head = input.value;
    const body = textarea.value;
    const meta = document.querySelector('meta[name="user_id"]');
    const id = meta ? meta.content : null;
    ...
    // TODO: make an AJAX request to send notification
});
</code></pre>
<p>Функция <code>pushForm</code> получает <code>input</code>,  <code>textarea</code> и <code>button</code> внутри формы. Также она получает информацию из тега <code>meta</code>, включая атрибут <code>user_id</code> и идентификатор пользователя, который хранится в атрибуте <code>content</code> тега. Получив эту информацию, она может отправить запрос POST на конечную точку <code>/send_push</code> на сервере.</p>

<p>Для отправки запросов на сервер мы будем использовать нативную API <a href="https://developer.mozilla.org/en/docs/Web/API/Fetch_API">Fetch</a>. Мы используем Fetch здесь, поскольку API поддерживается большинством браузеров и не требует для работы внешних библиотек. Под добавленным ранее кодом обновите функцию <code>pushForm</code> для включения кода для отправки запросов AJAX:</p>
<div class="code-label " title="~/djangopush/static/js/site.js">~/djangopush/static/js/site.js</div><pre class="code-pre "><code class="code-highlight language-javascript">const pushForm = document.getElementById('send-push__form');
const errorMsg = document.querySelector('.error');

pushForm.addEventListener('submit', async function (e) {
     ...
    const id = meta ? meta.content : null;

     if (head &amp;&amp; body &amp;&amp; id) {
        button.innerText = 'Sending...';
        button.disabled = true;

        const res = await fetch('/send_push', {
            method: 'POST',
            body: JSON.stringify({head, body, id}),
            headers: {
                'content-type': 'application/json'
            }
        });
        if (res.status === 200) {
            button.innerText = 'Send another 😃!';
            button.disabled = false;
            input.value = '';
            textarea.value = '';
        } else {
            errorMsg.innerText = res.message;
            button.innerText = 'Something broke 😢..  Try again?';
            button.disabled = false;
        }
    }
    else {
        let error;
        if (!head || !body){
            error = 'Please ensure you complete the form 🙏🏾'
        }
        else if (!id){
            error = "Are you sure you're logged in? 🤔. Make sure! 👍🏼"
        }
        errorMsg.innerText = error;
    }
});
</code></pre>
<p>Если три обязательных параметра <code>head,</code> <code>body</code> и <code>id</code> присутствуют, мы отправим запрос и временно отключим кнопку submit.</p>

<p>Завершенный файл выглядит следующим образом:</p>
<div class="code-label " title="~/djangopush/static/js/site.js">~/djangopush/static/js/site.js</div><pre class="code-pre "><code class="code-highlight language-javascript">const pushForm = document.getElementById('send-push__form');
const errorMsg = document.querySelector('.error');

pushForm.addEventListener('submit', async function (e) {
    e.preventDefault();
    const input = this[0];
    const textarea = this[1];
    const button = this[2];
    errorMsg.innerText = '';

    const head = input.value;
    const body = textarea.value;
    const meta = document.querySelector('meta[name="user_id"]');
    const id = meta ? meta.content : null;

    if (head &amp;&amp; body &amp;&amp; id) {
        button.innerText = 'Sending...';
        button.disabled = true;

        const res = await fetch('/send_push', {
            method: 'POST',
            body: JSON.stringify({head, body, id}),
            headers: {
                'content-type': 'application/json'
            }
        });
        if (res.status === 200) {
            button.innerText = 'Send another 😃!';
            button.disabled = false;
            input.value = '';
            textarea.value = '';
        } else {
            errorMsg.innerText = res.message;
            button.innerText = 'Something broke 😢..  Try again?';
            button.disabled = false;
        }
    }
    else {
        let error;
        if (!head || !body){
            error = 'Please ensure you complete the form 🙏🏾'
        }
        else if (!id){
            error = "Are you sure you're logged in? 🤔. Make sure! 👍🏼"
        }
        errorMsg.innerText = error;
    }    
});
</code></pre>
<p>После этого остается добавить файл <code>site.js</code> в файл <code>home.html</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/templates/home.html
</li></ul></code></pre>
<p>Добавьте тег <code>script</code>:</p>
<div class="code-label " title="~/djangopush/templates/home.html">~/djangopush/templates/home.html</div><pre class="code-pre "><code class="code-highlight language-html">
{% load static %}
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
   ...
&lt;/head&gt;
&lt;body&gt;
   ...
   <span class="highlight">&lt;script src="{% static '/js/site.js' %}"&gt;&lt;/script&gt;</span>
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>В данный момент, если вы оставили приложение запущенным или попытались запустить его снова, то получите ошибку, поскольку service workers может функционировать только на защищенных доменах или в <code>localhost</code>: На следующем шаге мы будем использовать <a href="https://ngrok.com/">ngrok</a> для создания безопасного туннеля на нашем веб-сервере.</p>

<h2 id="Шаг-10-—-Создание-защищенного-туннеля-для-тестирования-приложения">Шаг 10 — Создание защищенного туннеля для тестирования приложения</h2>

<p>Service worker'ы требуют наличия защищенных соединений для работы на любом сайте, кроме <code>localhost</code>, поскольку они не защищены от взлома для последующей фильтрации и подмены ответов. По этой причине мы создадим защищенный туннель для нашего сервера с помощью <a href="https://ngrok.com">ngrok</a>.</p>

<p>Откройте второе окно командной строки и убедитесь, что вы находитесь в домашней директории:</p>
<pre class="code-pre command second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd ~
</li></ul></code></pre>
<p>Если вы начали работу с чистым сервером на базе Ubuntu 18.04, вам потребуется выполнить установку <code>unzip</code>:</p>
<pre class="code-pre command second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt update &amp;&amp; sudo apt install unzip
</li></ul></code></pre>
<p>Загрузите ngrok:</p>
<pre class="code-pre command second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="$">wget https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-amd64.zip
</li><li class="line" prefix="$">unzip ngrok-stable-linux-amd64.zip
</li></ul></code></pre>
<p>Переместите <code>ngrok</code> в <code>/usr/local/bin</code>, чтобы получить доступ к команде <code>ngrok</code> из командной строки:</p>
<pre class="code-pre command second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo mv ngrok /usr/local/bin
</li></ul></code></pre>
<p>В первом окне командной строки убедитесь, что вы находитесь в директории проекта и запустите сервер:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">cd ~/djangopush
</li><li class="line" prefix="(my_env) $">python manage.py runserver <span class="highlight">your_server_ip</span>:8000
</li></ul></code></pre>
<p>Вы должны были сделать это, прежде чем создать защищенный туннель для вашего приложения.</p>

<p>Во втором окне командной строки перейдите к папке проекта и активируйте виртуальную среду:</p>
<pre class="code-pre command second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd ~/djangopush
</li><li class="line" prefix="$">source my_env/bin/activate
</li></ul></code></pre>
<p>Создайте защищенный туннель для вашего приложения:</p>
<pre class="code-pre custom_prefix second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">ngrok http <span class="highlight">your_server_ip</span>:8000
</li></ul></code></pre>
<p>Вы увидите следующий вывод, который включает информацию о защищенном URL-адресе ngrok:</p>
<pre class="code-pre  second-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>ngrok by <a href="https://www.digitalocean.com/community/users/inconshreveable" class="username-tag">@inconshreveable</a>                                                                                                                       (Ctrl+C to quit)

Session Status                online
Session Expires               7 hours, 59 minutes
Version                       2.2.8
Region                        United States (us)
Web Interface                 http://127.0.0.1:4040
Forwarding                    http://<span class="highlight">ngrok_secure_url</span> -&gt; 203.0.113.0:8000
Forwarding                    https://<span class="highlight">ngrok_secure_url</span> -&gt; 203.0.113.0:8000

Connections                   ttl     opn     rt1     rt5     p50     p90
                              0       0       0.00    0.00    0.00    0.00
</code></pre>
<p>Скопируйте <code><span class="highlight">ngrok_secure_url</span></code> из вывода консоли. Вы должны будете добавить его в список <code>ALLOWED_HOSTS</code> в файле <code>settings.py</code>.</p>

<p>Откройте другое окно командной строки перейдите в папку проекта и активируйте виртуальную среду:</p>
<pre class="code-pre command third-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd ~/djangopush
</li><li class="line" prefix="$">source my_env/bin/activate
</li></ul></code></pre>
<p>Откройте файл <code>settings.py</code>:</p>
<pre class="code-pre custom_prefix third-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="(my_env) $">nano ~/djangopush/djangopush/settings.py
</li></ul></code></pre>
<p>Обновите список <code>ALLOWED_HOSTS</code> с защищенным туннелем ngrok:</p>
<div class="code-label " title="~/djangopush/djangopush/settings.py">~/djangopush/djangopush/settings.py</div><pre class="code-pre "><code class="code-highlight language-python">...

ALLOWED_HOSTS = ['your_server_ip', '<span class="highlight">ngrok_secure_url</span>']
...

</code></pre>
<p>Перейдите на защищенную страницу администратора для входа: <code>https://<span class="highlight">ngrok_secure_url</span>/admin/</code>. Вы увидите экран, который будет выглядеть примерно так:</p>

<p><img src="https://assets.digitalocean.com/articles/django_push_18_04/ngrok_login.png" alt="Вход для администратора ngrok"></p>

<p>Введите данные пользователя Django с правами администратора на этом экране. Эта информация должна повторять информацию, которую вы вводили при входе в интерфейс администратора на этапе <a href="https://www.digitalocean.com/community/tutorials/how-to-install-the-django-web-framework-on-ubuntu-18-04#testing-the-development-server">предварительной подготовки</a>. Теперь вы готовы к отправке push-уведомлений.</p>

<p>Введите <code>https://<span class="highlight">ngrok_secure_url</span></code> в адресной строке браузера. Вы увидите запрос разрешения на отображение уведомлений. Нажмите кнопку <strong>Allow (Разрешить)</strong>, чтобы разрешить отображение push-уведомлений в браузере.</p>

<p><img src="https://assets.digitalocean.com/articles/django_push_18_04/allow_push_two.png" alt="запрос push-уведомлений"></p>

<p>Отправка заполненной формы будет отображать уведомлений примерно следующего вида:</p>

<p><img src="https://assets.digitalocean.com/articles/django_push_18_04/web_push_final.png" alt="скриншот уведомления"></p>

<p><span class='note'><strong>Примечание</strong>: убедитесь, что ваш сервер запущен, прежде чем пытаться отправить уведомления.<br></span></p>

<p>Если вы получили уведомления, это значит, что приложение работает корректно.</p>

<p>Вы создали веб-приложения, которое отправляет push-уведомления на сервере, и с помощью service workers получает и отображает уведомления. Также вы выполнили действия по получению ключей VAPID, которые требуются для отправки push-уведомлений с сервера приложения.</p>

<h2 id="Заключение">Заключение</h2>

<p>В этом обучающем руководстве вы научились оформлять подписку пользователя для получения push-уведомлений, устанавливать service worker'ы и отображать push-уведомления с помощью API уведомлений.</p>

<p>Вы можете пойти дальше и настроить уведомления для конкретных областей вашего приложения при нажатии. Исходный код для данного руководства можно найти <a href="https://github.com/HackAfro/django-push">здесь</a>.</p>
