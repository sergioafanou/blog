---
layout: post
title: Cómo implementar una aplicación PHP con Kubernetes en Ubuntu 16.04
network: digitalocean
date: January 22, 2020 at 09:31PM
url: https://www.digitalocean.com/community/tutorials/how-to-deploy-a-php-application-with-kubernetes-on-ubuntu-16-04-es
image: http://ifttt.com/images/no_image_card.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<p><em>El autor seleccionó <a href="https://www.brightfunds.org/funds/open-internet-free-speech">Open Internet/Free Speech</a> para recibir una donación como parte del programa <a href="https://do.co/w4do-cta">Write for DOnations</a>.</em></p>

<h3 id="introducción">Introducción</h3>

<p>Kubernetes es un sistema de orquestación de contenedores de código abierto. Le permite crear, actualizar y escalar contenedores sin preocuparse por el tiempo de inactividad.</p>

<p>Para ejecutar una aplicación PHP, Nginx funciona como proxy para <a href="http://php.net/manual/en/install.fpm.php">PHP-FPM</a>. Disponer esta configuración en un solo contenedor puede ser un proceso engorroso, pero Kubernetes permitirá administrar ambos servicios en contenedores separados. Utilizar Kubernetes le permitirá lograr que sus contenedores sean reutilizables e intercambiables, y no tendrá que reconstruir la imagen de sus contenedores cada vez que haya una nueva versión de Nginx o PHP.</p>

<p>En este tutorial, implementará una aplicación PHP 7 en un clúster de Kubernetes con Nginx y PHP-FPM ejecutándose en contenedores separados. También aprenderá a mantener los archivos de configuración y el código de aplicación fuera de la imagen de contenedor que utilice el sistema de <a href="https://www.digitalocean.com/products/block-storage/">almacenamiento en bloque de DigitalOcean.</a> Este enfoque le permitirá reutilizar la imagen de Nginx para cualquier aplicación que necesite un servidor web o proxy pasando un volumen de configuración en lugar de reconstruir la imagen.</p>

<h2 id="requisitos-previos">Requisitos previos</h2>

<ul>
<li>Comprensión básica de los objetos de Kubernetes. Para obtener mayor información, consulte nuestro artículo <a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-kubernetes#kubernetes-objects-and-workloads">Introducción a Kubernetes</a>.</li>
<li>Un clúster de Kubernetes activo en Ubuntu 16.04. Puede configurarlo siguiendo el tutorial <a href="https://www.digitalocean.com/community/tutorials/how-to-create-a-kubernetes-1-10-cluster-using-kubeadm-on-ubuntu-16-04">Cómo crear un clúster de Kubernetes 1.10 utilizando Kubeadm en Ubuntu 16.04</a>.</li>
<li>Una cuenta de DigitalOcean y un token de acceso a la API con permisos de lectura y escritura para crear nuestro volumen de almacenamiento. Si no tiene su token de acceso a la API, puede <a href="https://www.digitalocean.com/docs/api/create-personal-access-token/">crearlo desde aquí</a>.</li>
<li>Su código de aplicación alojado en una URL de acceso público, como <a href="https://github.com">Github</a>.</li>
</ul>

<h2 id="paso-1-crear-los-servicios-de-php-fpm-y-nginx">Paso 1: Crear los servicios de PHP-FPM y Nginx</h2>

<p>En este paso, creará los servicios de PHP-FPM y Nginx. Un servicio permite acceder a un conjunto de pods desde el interior del clúster. Los servicios dentro de un clúster pueden comunicarse de forma directa a través de sus nombres, sin necesidad de direcciones IP. El servicio de PHP-FPM permitirá el acceso a los pods de PHP-FPM, mientras que el servicio Nginx permitirá el acceso a los pods de Nginx.</p>

<p>Debido a que los pods de Nginx representarán los pods de PHP-FPM, tendrá que indicar al servicio la forma de encontrarlos. En lugar de utilizar direcciones IP, aprovechará la detección automática de servicios de Kubernetes para utilizar nombres legibles para humanos para dirigir solicitudes al servicio apropiado.</p>

<p>Para crear el servicio, creará un archivo de definición de objeto. Cada definición de objeto de Kubernetes es un archivo YAML que contiene por lo menos los siguientes elementos:</p>

<ul>
<li><code>apiVersion</code>: versión de la API de Kubernetes a la que pertenece la definición.</li>
<li><code>kind</code>: objeto de Kubernetes que este archivo representa. Por ejemplo,un <code>pod</code> o <code>service</code>.</li>
<li><code>metadata</code>: contiene el <code>name</code> del objeto junto con cualquier <code>labels</code> que desee aplicarle.</li>
<li><code>spec</code>: contiene una configuración específica según el tipo de objeto que cree, como la imagen del contenedor o los puertos en los cuales se podrá acceder a este.</li>
</ul>

<p>Primero, creará un directorio para contener sus definiciones de objetos de Kubernetes.</p>

<p>Aplique SSH a su *<em>nodo maestro *</em>y cree el directorio <code>definitions</code> que contendrá sus definiciones de objetos de Kubernetes.</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir definitions
</li></ul></code></pre>
<p>Acceda al directorio <code>definitions</code> recién creado:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd definitions
</li></ul></code></pre>
<p>Realice su servicio de PHP-FPM creando un archivo <code>php_service.yaml</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano php_service.yaml
</li></ul></code></pre>
<p>Establezca <code>kind</code> como <code>Service</code> para especificar que este objeto es un servicio:</p>
<div class="code-label " title="php_service.yaml">php_service.yaml</div><pre class="code-pre "><code langs="">...
apiVersion: v1
kind: Service
</code></pre>
<p>Nombre el servicio como <code>php</code>,  ya que proporcionará acceso a PHP-FPM:</p>
<div class="code-label " title="php_service.yaml">php_service.yaml</div><pre class="code-pre "><code langs="">...
metadata:
  name: php
</code></pre>
<p>Agrupará de manera lógica diferentes objetos con etiquetas. En este tutorial, utilizará etiquetas para agrupar los objetos en “niveles”, como frontend o backend. Los pods de PHP se ejecutarán detrás de este servicio, por lo que le asignará la etiqueta tier: <code>backend</code>.</p>
<div class="code-label " title="php_service.yaml">php_service.yaml</div><pre class="code-pre "><code langs="">...
  labels:
    tier: backend
</code></pre>
<p>Un servicio determina los pods a los que se debe acceder utilizando las etiquetas <code>selector</code>. Se servirá un pod que coincida con estas etiquetas, independiente de que este se cree antes o después del servicio. Agregará etiquetas para sus pods posteriormente en el tutorial.</p>

<p>Utilice la etiqueta <code>tier: backend</code> para asignar el pod al nivel de backend. También agregará la etiqueta <code>app: php</code> para especificar que este pod ejecuta PHP. Agregue estas dos etiquetas después de la sección de <code>metadata</code>.</p>
<div class="code-label " title="php_service.yaml">php_service.yaml</div><pre class="code-pre "><code langs="">...
spec:
  selector:
    app: php
    tier: backend
</code></pre>
<p>A continuación, especifique el puerto utilizado para acceder a este servicio. En este tutorial, utilizará el puerto <code>9000</code>. Añádalo al archivo <code>php_service.yaml</code> en <code>spec</code>:</p>
<div class="code-label " title="php_service.yaml">php_service.yaml</div><pre class="code-pre "><code langs="">...
  ports:
    - protocol: TCP
      port: 9000
</code></pre>
<p>Su archivo <code>php_service.yaml</code> completo tendrá el siguiente aspecto:</p>
<div class="code-label " title="php_service.yaml">php_service.yaml</div><pre class="code-pre "><code langs="">apiVersion: v1
kind: Service
metadata:
  name: php
  labels:
    tier: backend
spec:
  selector:
    app: php
    tier: backend
  ports:
  - protocol: TCP
    port: 9000
</code></pre>
<p>Presione <code>CTRL + o</code> para guardar el archivo y luego <code>CTRL + x</code> para cerrar <code>nano</code>.</p>

<p>Ahora que ha creado la definición de objeto para su servicio, para ejecutar el servicio utilizará el comando <code>kubectl apply</code> junto con el argumento <code>-f</code> y especificará su archivo <code>php_service.yaml</code>.</p>

<p>Cree su servicio:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f php_service.yaml
</li></ul></code></pre>
<p>Este resultado confirma la creación del servicio:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>service/php created
</code></pre>
<p>Verifique que su servicio esté en ejecución:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get svc
</li></ul></code></pre>
<p>Observará su servicio de PHP-FPM en ejecución:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE
kubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP    10m
php          ClusterIP   10.100.59.238   &lt;none&gt;        9000/TCP   5m
</code></pre>
<p>Kubernetes admite varios tipos de <a href="https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types">servicios</a>. Su servicio <code>php</code> utiliza el tipo de servicio predeterminado, <code>clusterIP</code>. Este tipo de servicio asigna una IP interna y permite acceder al servicio sólo desde el interior del clúster.</p>

<p>Ahora que el servicio de PHP-FPM está listo, creará el servicio de Nginx. Cree y abra  un nuevo archivo llamado <code>nginx_service.yaml</code> con el editor:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano nginx_service.yaml
</li></ul></code></pre>
<p>Este servicio se orientará a los pods de Nginx, por lo que lo llamará <code>nginx</code>. También agregará una etiqueta <code>tier: backend</code>, ya que pertenece al nivel de backend:</p>
<div class="code-label " title="nginx_service.yaml">nginx_service.yaml</div><pre class="code-pre "><code langs="">apiVersion: v1
kind: Service
metadata:
  name: nginx
  labels:
    tier: backend
</code></pre>
<p>De modo similar al servicio <code>php</code>, dirija los pods con las etiquetas de selección <code>app: nginx</code> y <code>tier: backend</code>. Permita que sea posible acceder a este servicio en el puerto 80, el puerto HTTP predeterminado.</p>
<div class="code-label " title="nginx_service.yaml">nginx_service.yaml</div><pre class="code-pre "><code langs="">...
spec:
  selector:
    app: nginx
    tier: backend
  ports:
  - protocol: TCP
    port: 80
</code></pre>
<p>Será posible acceder al servicio de Nginx de forma pública en Internet desde la dirección IP pública de su Droplet. Puede encontrar <code><span class="highlight">your_public_ip</span></code> desde su <a href="https://cloud.digitalocean.com">panel en la nube de DigitalOcean</a>. En <code>spec.externalIPs</code>, agregue lo siguiente:</p>
<div class="code-label " title="nginx_service.yaml">nginx_service.yaml</div><pre class="code-pre "><code langs="">...
spec:
  externalIPs:
  - <span class="highlight">your_public_ip</span>
</code></pre>
<p>Su archivo <code>nginx_service.yaml</code> tendrá este aspecto:</p>
<div class="code-label " title="nginx_service.yaml">nginx_service.yaml</div><pre class="code-pre "><code langs="">apiVersion: v1
kind: Service
metadata:
  name: nginx
  labels:
    tier: backend
spec:
  selector:
    app: nginx
    tier: backend
  ports:
  - protocol: TCP
    port: 80
  externalIPs:
  - <span class="highlight">your_public_ip</span>    
</code></pre>
<p>Guarde y cierre el archivo. Cree el servicio de Nginx:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f nginx_service.yaml
</li></ul></code></pre>
<p>Observará el siguiente resultado cuando el servicio esté en ejecución:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>service/nginx created
</code></pre>
<p>Puede ver todos los servicios en funcionamiento ejecutando lo siguiente:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get svc
</li></ul></code></pre>
<p>Observará los servicios de PHP-FPM y Nginx enumerados en el resultado:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE
kubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP    13m
nginx        ClusterIP   10.102.160.47   <span class="highlight">your_public_ip</span> 80/TCP     50s
php          ClusterIP   10.100.59.238   &lt;none&gt;        9000/TCP   8m
</code></pre>
<p>Tenga en cuenta que si desea eliminar un servicio puede ejecutar lo siguiente:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl delete svc/<span class="highlight">service_name</span>
</li></ul></code></pre>
<p>Ahora que creó sus servicios de PHP-FPM y Nginx, deberá especificar el lugar de almacenamiento para el código de su aplicación y sus archivos de configuración.</p>

<h2 id="paso-2-instalar-el-complemento-de-almacenamiento-de-digitalocean">Paso 2: Instalar el complemento de almacenamiento de DigitalOcean</h2>

<p>Kubernetes proporciona diversos complementos de almacenamiento que pueden crear el espacio de almacenamiento para su entorno. En este paso, instalará el <a href="https://github.com/digitalocean/csi-digitalocean">complemento de almacenamiento de DigitalOcean</a> para crear un <a href="https://www.digitalocean.com/products/storage/">almacén en bloques</a> en DigitalOcean. Una vez completada la instalación, agregará una clase de almacenamiento llamada <code>do-block-storage</code> que utilizará para crear su almacenamiento en bloques.</p>

<p>Primero configurará un objeto secreto de Kubernetes para almacenar su token de API de DigitalOcean. Los objetos secretos se utilizan para compartir información confidencial, como claves y contraseñas SSH, con otros objetos de Kubernetes dentro del mismo espacio de nombres. Los espacios de nombres ofrecen una alternativa lógica para separar sus objetos de Kubernetes.</p>

<p>Abra un archivo llamado <code>secret.yaml</code> con el editor:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano secret.yaml
</li></ul></code></pre>
<p>Nombre su objeto secreto <code>digitalocean</code> y agréguelo al <code>namespace</code> <code>kube-system</code>. <code>kube-system</code> es el espacio de nombres predeterminado para los servicios internos de Kubernetes y el complemento de almacenamiento de DigitalOcean también lo utiliza para iniciar varios componentes.</p>
<div class="code-label " title="secret.yaml">secret.yaml</div><pre class="code-pre "><code langs="">apiVersion: v1
kind: Secret
metadata:
  name: digitalocean
  namespace: kube-system
</code></pre>
<p>En lugar de una clave <code>spec</code>, un secreto utiliza una clave <code>data</code> o <code>stringData</code> para contener la información necesaria. El parámetro <code>data</code> contiene datos codificados en base64 que se decodifican de manera automática cuando se recuperan. El parámetro <code>stringData</code> contiene datos no codificados que se codifican de manera automática durante la creación o actualización, y no muestra los datos al recuperar secretos. En este tutorial, utilizará <code>stringData</code> para una mayor practicidad.</p>

<p>Agregue el <code>access-token</code> como <code>stringData</code>:</p>
<div class="code-label " title="secret.yaml">secret.yaml</div><pre class="code-pre "><code langs="">...
stringData:
  access-token: <span class="highlight">your-api-token</span>
</code></pre>
<p>Guarde y cierre el archivo.</p>

<p>Su archivo <code>secret.yaml</code> tendrá el siguiente aspecto:</p>
<div class="code-label " title="secret.yaml">secret.yaml</div><pre class="code-pre "><code langs="">apiVersion: v1
kind: Secret
metadata:
  name: digitalocean
  namespace: kube-system
stringData:
  access-token: <span class="highlight">your-api-token</span>
</code></pre>
<p>Cree el secreto:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f secret.yaml
</li></ul></code></pre>
<p>Verá este resultado al crear secretos:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>secret/digitalocean created
</code></pre>
<p>Puede visualizar el secreto con el siguiente comando:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl -n kube-system get secret digitalocean
</li></ul></code></pre>
<p>El resultado tendrá un aspecto similar a este:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME           TYPE      DATA      AGE
digitalocean   Opaque    1         41s
</code></pre>
<p>El tipo <code>Opaque</code> implica que este secreto es de sólo lectura, parámetro estándar para los secretos de <code>stringData</code>. Puede obtener más información más acerca de ello en las <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/auth/secrets.md">especificaciones de diseño de secretos</a>. El campo <code>DATA</code> muestra el número de elementos almacenados en este secreto. En este caso, muestra <code>1</code> porque tiene una sola clave almacenada.</p>

<p>Ahora que su secreto está implementado, instale el <a href="https://github.com/digitalocean/csi-digitalocean">complemento de almacenamiento en bloques de DigitalOcean</a>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f https://raw.githubusercontent.com/digitalocean/csi-digitalocean/master/deploy/kubernetes/releases/csi-digitalocean-v0.3.0.yaml
</li></ul></code></pre>
<p>Verá resultados similares al siguiente:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>storageclass.storage.k8s.io/do-block-storage created
serviceaccount/csi-attacher created
clusterrole.rbac.authorization.k8s.io/external-attacher-runner created
clusterrolebinding.rbac.authorization.k8s.io/csi-attacher-role created
service/csi-attacher-doplug-in created
statefulset.apps/csi-attacher-doplug-in created
serviceaccount/csi-provisioner created
clusterrole.rbac.authorization.k8s.io/external-provisioner-runner created
clusterrolebinding.rbac.authorization.k8s.io/csi-provisioner-role created
service/csi-provisioner-doplug-in created
statefulset.apps/csi-provisioner-doplug-in created
serviceaccount/csi-doplug-in created
clusterrole.rbac.authorization.k8s.io/csi-doplug-in created
clusterrolebinding.rbac.authorization.k8s.io/csi-doplug-in created
daemonset.apps/csi-doplug-in created
</code></pre>
<p>Ahora que instaló el complemento de almacenamiento de DigitalOcean, puede crear almacenamiento en bloques para contener el código de su aplicación y sus archivos de configuración.</p>

<h2 id="paso-3-crear-el-volumen-persistente">Paso 3: Crear el volumen persistente</h2>

<p>Con su secreto implementado y el complemento de almacenamiento en bloques instalado, estará listo para crear su <em>volumen persistente</em>. Un volumen persistente, o VP, es un almacenamiento en bloques de un tamaño especifico que es independiente del ciclo de vida de un pod. Utilizar un volumen persistente le permitirá administrar o actualizar sus pods sin preocuparse por la posibilidad de perder el código de su aplicación. El acceso a un volumen persistente es posible utilizando un <code>PersistentVolumeClaim</code>, o PVC, que monta el VP en la ruta requerida.</p>

<p>Abra un archivo llamado <code>code_volume.yaml</code> con su editor:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano code_volume.yaml
</li></ul></code></pre>
<p>Dé el nombre <code>code</code> al PVC agregando los siguientes parámetros y valores a su archivo:</p>
<div class="code-label " title="code_volume.yaml">code_volume.yaml</div><pre class="code-pre "><code langs="">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: code
</code></pre>
<p>La <code>spec</code> para un PVC contiene los siguientes elementos:</p>

<ul>
<li><code>accessModes</code> que varían según el caso de uso. Son los siguientes:

<ul>
<li><code>ReadWriteOnce</code>: monta el volumen con atributos de lectura y escritura para un solo nodo.</li>
<li><code>ReadOnlyMany</code>: monta el volumen con atributos de sólo lectura para muchos nodos.</li>
<li><code>ReadWriteMany</code>: monta el volumen con atributos de lectura y escritura para muchos nodos.</li>
</ul></li>
<li><code>resources</code>: espacio de almacenamiento que usted requiere.</li>
</ul>

<p>El almacenamiento en bloques de DigitalOcean solo se monta en un único nodo, por lo que usted fijará <code>accessModes</code> en <code>ReadWriteOnce</code>. Este tutorial le servirá de guía para agregar una pequeña cantidad de código de aplicación. Por lo tanto 1 gigabyte será suficiente en este caso de uso. Si planea almacenar una mayor cantidad de código o datos en el volumen, puede modificar el parámetro <code>storage</code> para que se adapte a sus necesidades. Puede aumentar la cantidad de almacenamiento después de crear el volumen, pero no es posible reducir el disco.</p>
<div class="code-label " title="code_volume.yaml">code_volume.yaml</div><pre class="code-pre "><code langs="">...
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: <span class="highlight">1Gi</span>
</code></pre>
<p>A continuación, especifique la clase de almacenamiento que Kubernetes utilizará para proporcionar los volúmenes. Utilizará la clase <code>do-block-storage</code> creada por el complemento de almacenamiento en bloques de DigitalOcean.</p>
<div class="code-label " title="code_volume.yaml">code_volume.yaml</div><pre class="code-pre "><code langs="">...
  storageClassName: do-block-storage
</code></pre>
<p>Su archivo <code>code_volume.yaml</code> tendrá el siguiente aspecto:</p>
<div class="code-label " title="code_volume.yaml">code_volume.yaml</div><pre class="code-pre "><code langs="">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: code
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: <span class="highlight">1Gi</span>
  storageClassName: do-block-storage
</code></pre>
<p>Guarde y cierre el archivo.</p>

<p>Cree el elemento <code>code</code> PersistentVolumeClaim utilizando <code>kubectl</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f code_volume.yaml
</li></ul></code></pre>
<p>El siguiente resultado le indica que el objeto se creó de forma correcta y está listo para montar su PVC de 1 GB como un volumen.</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>persistentvolumeclaim/code created
</code></pre>
<p>Para visualizar volúmenes persistentes (VP) disponibles:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get pv
</li></ul></code></pre>
<p>Verá su VP enumerado:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS    CLAIM          STORAGECLASS       REASON    AGE
pvc-ca4df10f-ab8c-11e8-b89d-12331aa95b13   1Gi        RWO            Delete           Bound     default/code   do-block-storage             2m
</code></pre>
<p>A excepción de <code>Reclaim Policy</code> y <code>Status</code>, en los campos anteriores se muestra un resumen de su archivo de configuración. <code>Reclaim Policy</code> define lo que se hace con el VP después de que el PVC que lo accede es eliminado. <code>Delete</code> elimina el VP de Kubernetes y la infraestructura de DigitalOcean. Puede obtener más información sobre <code>Reclaim Policy</code> y <code>Status</code> en la <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/">documentación de VP de Kubernetes</a>.</p>

<p>De esta manera, habrá creado correctamente un volumen persistente utilizando el complemento de almacenamiento en bloques de DigitalOcean. Ahora que su volumen persistente está listo, creará sus pods con una implementación.</p>

<h2 id="paso-4-crear-una-implementación-de-php-fpm">Paso 4: Crear una implementación de PHP-FPM</h2>

<p>En este paso, aprenderá a utilizar una implementación para crear su pod de PHP-FPM. Las implementaciones proporcionan una manera uniforme de crear, actualizar y administrar pods utilizando <a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/">ReplicaSets</a>. Si una actualización no funciona como se espera, una implementación restaurará de manera automática sus pods a una imagen anterior.</p>

<p>La clave de despliegue <code>spec.selector</code> enumerará las etiquetas de los pods que administrará. También utilizará la clave <code>template</code> para crear los pods necesarios.</p>

<p>En este paso también se introducirá el uso de contenedores Init. <em>Los contenedores Init</em> ejecutan uno o más comandos antes que los contenedores regulares especificados en la clave <code>template</code> del pod. En este tutorial, su contenedor Init obtendrá un archivo de muestra de <code>index.php</code> de <a href="https://gist.github.com">GitHub Gist</a> utilizando <code>wget</code>. El archivo de muestra contiene lo siguiente:</p>
<div class="code-label " title="index.php">index.php</div><pre class="code-pre "><code langs="">&lt;?php
echo phpinfo();
</code></pre>
<p>Para crear su implementación, abra un nuevo archivo llamado <code>php_deployment.yaml</code> con su editor:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano php_deployment.yaml
</li></ul></code></pre>
<p>Esta implementación administrará sus pods de PHP-FPM, por lo que dará al objeto de implementación el nombre <code>php</code>. Los pods pertenecen al nivel de backend, por lo que agrupará la implementación en este grupo utilizando la etiqueta <code>tier: backend</code>:</p>
<div class="code-label " title="php_deployment.yaml">php_deployment.yaml</div><pre class="code-pre "><code langs="">apiVersion: apps/v1
kind: Deployment
metadata:
  name: php
  labels:
    tier: backend
</code></pre>
<p>Para la implementación <code>spec</code>, especificará la cantidad de copias de este pod que se crearán utilizando el parámetro <code>replicas</code>. El número de <code>replicas</code> variará según sus necesidades y los recursos disponibles. En este tutorial, creará una réplica:</p>
<div class="code-label " title="php_deployment.yaml">php_deployment.yaml</div><pre class="code-pre "><code langs="">...
spec:
  replicas: 1
</code></pre>
<p>La implementación administrará pods que coincidan con <code>app: php</code> y las etiquetas de <code>tier: backend</code>. En la clave de <code>selector</code> agregue:</p>
<div class="code-label " title="php_deployment.yaml">php_deployment.yaml</div><pre class="code-pre "><code langs="">...
  selector:
    matchLabels:
      app: php
      tier: backend
</code></pre>
<p>A continuación, la implementación <code>spec</code> requiere el elemento <code>template</code> para la definición de objeto de su pod. Esta plantilla definirá las especificaciones a partir de las cuales se creará el pod. Primero, agregará las etiquetas que se especificaron para el servicio <code>php</code> <code>selectors</code> y las <code>matchLabels</code> de la implementación. Agregue <code>app: php</code> y <code>tier: backend</code> en <code>template.metadata.labels</code>:</p>
<div class="code-label " title="php_deployment.yaml">php_deployment.yaml</div><pre class="code-pre "><code langs="">...
  template:
    metadata:
      labels:
        app: php
        tier: backend
</code></pre>
<p>Un pod puede tener varios contenedores y volúmenes, pero cada uno requerirá un nombre. Puede montar de manera selectiva volúmenes en un contenedor especificando una ruta de montaje para cada volumen.</p>

<p>Primero, especifique los volúmenes a los que accederá su contenedor. Creó un PVC llamado <code>code</code> para contener el código de su aplicación. Por lo tanto dé el nombre <code>code</code> a este volumen también. En <code>spec.template.spec.volumes</code>, agregue lo siguiente:</p>
<div class="code-label " title="php_deployment.yaml">php_deployment.yaml</div><pre class="code-pre "><code langs="">...
    spec:
      volumes:
      - name: code
        persistentVolumeClaim:
          claimName: code
</code></pre>
<p>A continuación, especifique el contenedor que desee ejecutar en este pod. Puede encontrar varias imágenes en <a href="https://hub.docker.com/explore/">la tienda de Docker</a>, pero en este tutorial empleará la imagen <code>php:7-fpm</code>.</p>

<p>En <code>spec.template.spec.containers</code>, agregue lo siguiente:</p>
<div class="code-label " title="php_deployment.yaml">php_deployment.yaml</div><pre class="code-pre "><code langs="">...
      containers:
      - name: php
        image: php:7-fpm
</code></pre>
<p>A continuación, montará los volúmenes a los que el contenedor solicita acceso. Este contenedor ejecutará su código PHP, de modo que deberá acceder al volumen <code>code</code>. También utilizará <code>mountPath</code> para especificar <code>/code</code> como punto de montaje.</p>

<p>En <code>spec.template.spec.containers.volumeMounts</code>, agregue lo siguiente:</p>
<div class="code-label " title="php_deployment.yaml">php_deployment.yaml</div><pre class="code-pre "><code langs="">...
        volumeMounts:
        - name: code
          mountPath: /code
</code></pre>
<p>Ahora que montó su volumen, debe introducir el código de su aplicación en el volumen. Es posible que para hacerlo haya utilizado previamente FTP/SFTP o clonado el código a través de una conexión SSH, pero en este paso verá la forma de copiar el código utilizando un contenedor Init.</p>

<p>Según la complejidad de su proceso de configuración, puede utilizar un solo <code>initContainer</code> para ejecutar una secuencia de comandos que construya su aplicación, o puede utilizar un initConta<code>iner por coma</code>ndo. Asegúrese de que los volúmenes se monten en el <code>initContainer</code>.</p>

<p>En este tutorial, utilizará un contenedor Init único con <code>busybox</code> para descargar el código. <code>busybox</code> es una pequeña imagen que contiene la utilidad <code>wget</code> que utilizará para hacerlo.</p>

<p>En <code>spec.template.spec</code>, agregue su <code>initContainer</code> y especifique la imagen <code>busybox</code>:</p>
<div class="code-label " title="php_deployment.yaml">php_deployment.yaml</div><pre class="code-pre "><code langs="">...
      initContainers:
      - name: install
        image: busybox
</code></pre>
<p>Su contenedor Init necesitará acceso al volumen <code>code</code> para que pueda descargar el código en esa ubicación. En <code>spec.template.spec.initContainers</code>, monte el volumen <code>code</code> en la ruta <code>/code</code>:</p>
<div class="code-label " title="php_deployment.yaml">php_deployment.yaml</div><pre class="code-pre "><code langs="">...
        volumeMounts:
        - name: code
          mountPath: /code
</code></pre>
<p>Cada contenedor Init debe ejecutar un <code>command</code>. Su contenedor Init utilizará <code>wget</code> para descargar <a href="https://raw.githubusercontent.com/do-community/php-kubernetes/master/index.php">el código</a> de <a href="https://github.com/do-community/php-kubernetes">Github</a> en el directorio de trabajo <code>/code</code>. La opción <code>-O</code> asigna un nombre al archivo descargado, y usted dará a este archivo el nombre <code>index.php</code>.</p>

<p><span class='note'><strong>Nota:</strong> Asegúrese de el código que extraerá sea confiable. Antes de introducir el código fuente en su servidor, inspecciónelo para asegurarse de que las funciones que realiza le parezcan adecuadas.<br></span></p>

<p>En el contenedor <code>install</code> en <code>spec.template.spec.initContainers</code>, agregue estas líneas:</p>
<div class="code-label " title="php_deployment.yaml">php_deployment.yaml</div><pre class="code-pre "><code langs="">...
        command:
        - wget
        - "-O"
        - "/code/index.php"
        - <span class="highlight">https://raw.githubusercontent.com/do-community/php-kubernetes/master/index.php</span>
</code></pre>
<p>Su archivo <code>php_deployment.yaml</code> completo tendrá este aspecto:</p>
<div class="code-label " title="php_deployment.yaml">php_deployment.yaml</div><pre class="code-pre "><code langs="">apiVersion: apps/v1
kind: Deployment
metadata:
  name: php
  labels:
    tier: backend
spec:
  replicas: 1
  selector:
    matchLabels:
      app: php
      tier: backend
  template:
    metadata:
      labels:
        app: php
        tier: backend
    spec:
      volumes:
      - name: code
        persistentVolumeClaim:
          claimName: code
      containers:
      - name: php
        image: php:7-fpm
        volumeMounts:
        - name: code
          mountPath: /code
      initContainers:
      - name: install
        image: busybox
        volumeMounts:
        - name: code
          mountPath: /code
        command:
        - wget
        - "-O"
        - "/code/index.php"
        - <span class="highlight">https://raw.githubusercontent.com/do-community/php-kubernetes/master/index.php</span>
</code></pre>
<p>Guarde el archivo y salga del editor.</p>

<p>Cree la implementación de PHP-FPM con <code>kubectl</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f php_deployment.yaml
</li></ul></code></pre>
<p>Visualizará el siguiente resultado al crear la implementación:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>deployment.apps/php created
</code></pre>
<p>A modo de resumen, esta implementación se iniciará descargando las imágenes especificadas. Luego, solicitará el <code>PersistentVolume</code> de su <code>PersistentVolumeClaim</code> y ejecutará en serie sus <code>initContainers</code>. Una vez completado el proceso, los contenedores ejecutarán y montarán los <code>volumes</code> en punto de montaje especificado. Una vez que todos estos pasos se hayan completado, su pod estará listo y en ejecución.</p>

<p>Puede ver su implementación ejecutando lo siguiente:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get deployments
</li></ul></code></pre>
<p>Verá el siguiente resultado:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
php       1         1         1            0           19s
</code></pre>
<p>Este resultado puede ayudarle a comprender el estado actual de la implementación. <code>Deployment</code> es <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">uno de los controladores</a> que conservan un estado deseado. El elemento <code>template</code> que creó especifica que un elemento  <code>replicas</code> del pod del estado <code>DESIRED</code> se llamará <code>php</code>. El campo <code>CURRENT</code> indica cuántas réplicas se encuentran en ejecución, por lo que debe coincidir con el estado <code>DESIRED</code>. Puede leer información sobre los campos restantes en la <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">documentación de implementación de Kubernetes</a>.</p>

<p>Puede ver los pods iniciados por esta implementación con el siguiente comando:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get pods
</li></ul></code></pre>
<p>El resultado de este comando varía según el tiempo transcurrido desde la creación de la implementación. Si la ejecuta poco después de su creación, el resultado probablemente tendrá este aspecto:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME                   READY     STATUS     RESTARTS   AGE
php-86d59fd666-bf8zd   0/1       Init:0/1   0          9s
</code></pre>
<p>Las columnas representan la siguiente información:</p>

<ul>
<li><code>Ready</code>: número de <code>replicas</code> que ejecutan este pod.</li>
<li><code>Status</code>: estado del pod. <code>Init</code> indica que los contenedores Init están en ejecución. En este resultado, del total de 1 contenedor Init, ninguno terminó de ejecutarse.</li>
<li><code>Restarts</code>: cantidad de veces que este proceso se reinició para iniciar el pod. Este número aumentará si alguno de sus contenedores Init falla. La implementación se reiniciará hasta que alcance un estado deseado.</li>
</ul>

<p>Según de la complejidad de sus secuencias de comandos de inicio, pueden pasar algunos minutos hasta que el estado cambie a <code>podInitializing</code>:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME                   READY     STATUS            RESTARTS   AGE
php-86d59fd666-lkwgn   0/1       podInitializing   0          39s
</code></pre>
<p>Esto significa que los contenedores Init han finalizado y que se están iniciando los contenedores. Si ejecuta el comando cuando todos los contenedores estén en ejecución, verá que el estado de pod cambiará a <code>Running</code>.</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME                   READY     STATUS            RESTARTS   AGE
php-86d59fd666-lkwgn   1/1       Running   0          1m
</code></pre>
<p>Ahora verá que su pod se ejecuta de forma correcta. Si su pod no se inicia, puede realizar una depuración con los siguientes comandos:</p>

<ul>
<li>Ver información detallada de un pod:</li>
</ul>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl describe pods <span class="highlight">pod-name</span>
</li></ul></code></pre>
<ul>
<li>Ver registros generados por un pod:</li>
</ul>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl logs <span class="highlight">pod-name</span>
</li></ul></code></pre>
<ul>
<li>Ver registros para un contenedor específico en un pod:</li>
</ul>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl logs <span class="highlight">pod-name</span> <span class="highlight">container-name</span>
</li></ul></code></pre>
<p>Su código de aplicación está montado y el servicio de PHP-FPM ya está listo para manejar conexiones. Ahora podrá crear su implementación de Nginx.</p>

<h2 id="paso-5-crear-la-implementación-de-nginx">Paso 5: Crear la implementación de Nginx</h2>

<p>En este paso, utilizará un <em>ConfigMap</em> para configurar Nginx. Un ConfigMap contiene su configuración en un formato de clave-valor al que puede hacer referencia en otras definiciones de objetos de Kubernetes. Este enfoque le brindará la flexibilidad necesaria para reutilizar o cambiar la imagen con una versión de Nginx distinta si es necesario. Actualizar ConfigMap replicará los cambios de manera automática en cualquier pod montado en él.</p>

<p>Con su editor, cree un archivo <code>nginx_configMap.yaml</code> para su ConfigMap:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano nginx_configMap.yaml
</li></ul></code></pre>
<p>Dé el nombre <code>nginx-config</code> a ConfigMap y agrúpelo en el microservicio de <code>tier: backend</code>:</p>
<div class="code-label " title="nginx_configMap.yaml">nginx_configMap.yaml</div><pre class="code-pre "><code langs="">apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
  labels:
    tier: backend
</code></pre>
<p>A continuación, agregará <code>data</code> para ConfigMap. Dé a la clave el nombre <code>config</code> y añada el contenido de su archivo de configuración de Nginx como valor. Puede utilizar el ejemplo de configuración de Nginx de <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-nginx-server-blocks-virtual-hosts-on-ubuntu-16-04#step-three-create-server-block-files-for-each-domain">este tutorial</a>.</p>

<p>Debido a que Kubernetes puede dirigir solicitudes al host adecuado para un servicio, puede ingresar el nombre de su servicio de PHP-FPM en el parámetro <code>fastcgi_pass</code> en lugar de su dirección IP. Agregue lo siguiente a su archivo <code>nginx_configMap.yaml</code>:</p>
<div class="code-label " title="nginx_configMap.yaml">nginx_configMap.yaml</div><pre class="code-pre "><code langs="">...
data:
  config : |
    server {
      index index.php index.html;
      error_log  /var/log/nginx/error.log;
      access_log /var/log/nginx/access.log;
      root ^/code^;

      location / {
          try_files $uri $uri/ /index.php?$query_string;
      }

      location ~ \.php$ {
          try_files $uri =404;
          fastcgi_split_path_info ^(.+\.php)(/.+)$;
          fastcgi_pass <span class="highlight">php:9000</span>;
          fastcgi_index index.php;
          include fastcgi_params;
          fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
          fastcgi_param PATH_INFO $fastcgi_path_info;
        }
    }
</code></pre>
<p>Su archivo <code>nginx_configMap.yaml</code> tendrá el siguiente aspecto:</p>
<div class="code-label " title="nginx_configMap.yaml">nginx_configMap.yaml</div><pre class="code-pre "><code langs="">apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
  labels:
    tier: backend
data:
  config : |
    server {
      index index.php index.html;
      error_log  /var/log/nginx/error.log;
      access_log /var/log/nginx/access.log;
      root <span class="highlight">/code</span>;

      location / {
          try_files $uri $uri/ /index.php?$query_string;
      }

      location ~ \.php$ {
          try_files $uri =404;
          fastcgi_split_path_info ^(.+\.php)(/.+)$;
          fastcgi_pass <span class="highlight">php:9000</span>;
          fastcgi_index index.php;
          include fastcgi_params;
          fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
          fastcgi_param PATH_INFO $fastcgi_path_info;
        }
    }
</code></pre>
<p>Guarde el archivo y salga del editor.</p>

<p>Cree el ConfigMap:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f nginx_configMap.yaml
</li></ul></code></pre>
<p>Verá lo siguiente:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>configmap/nginx-config created
</code></pre>
<p>Con esto, habrá terminado de crear su ConfigMap y ya podrá crear su implementación de Nginx.</p>

<p>Comience abriendo un nuevo archivo <code>nginx_deployment.yaml</code> en el editor:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano nginx_deployment.yaml
</li></ul></code></pre>
<p>Dé el nombre <code>nginx</code> a la implementación y añada la etiqueta <code>tier: backend</code>:</p>
<div class="code-label " title="nginx_deployment.yaml">nginx_deployment.yaml</div><pre class="code-pre "><code langs="">apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
  labels:
    tier: backend
</code></pre>
<p>Especifique que desea un elemento <code>replicas</code> en la implementación <code>spec</code>. Esta implementación administra pods con etiquetas <code>app: nginx</code> y <code>tier: backend</code>. Agregue los siguientes parámetros y valores:</p>
<div class="code-label " title="nginx_deployment.yaml">nginx_deployment.yaml</div><pre class="code-pre "><code langs="">...
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
      tier: backend
</code></pre>
<p>A continuación, agregue el elemento <code>template</code> del pod. Debe utilizar las mismas etiquetas que agregó para <code>selector.matchLabels</code> de la implementación. Agregue lo siguiente:</p>
<div class="code-label " title="nginx_deployment.yaml">nginx_deployment.yaml</div><pre class="code-pre "><code langs="">...
  template:
    metadata:
      labels:
        app: nginx
        tier: backend
</code></pre>
<p>Habilite el acceso de Nginx al PVC <code>code</code> que creó previamente. En <code>spec.template.spec.volumes</code>, agregue lo siguiente:</p>
<div class="code-label " title="nginx_deployment.yaml">nginx_deployment.yaml</div><pre class="code-pre "><code langs="">...
    spec:
      volumes:
      - name: code
        persistentVolumeClaim:
          claimName: code
</code></pre>
<p>Los pods pueden montar un ConfigMap como un volumen. Especificar un nombre de archivo y una clave creará un archivo con su valor como el contenido. Para usar ConfigMap, fije <code>path</code> en el nombre del archivo que tendrá el contenido de <code>key</code>. EL objetivo es crear un archivo <code>site.conf</code> a partir de la clave <code>config</code>. En <code>spec.template.spec.volumes</code>, agregue lo siguiente:</p>
<div class="code-label " title="nginx_deployment.yaml">nginx_deployment.yaml</div><pre class="code-pre "><code langs="">...
      - name: config
        configMap:
          name: nginx-config
          items:
          - key: config
            path: site.conf
</code></pre>
<p><span class='warning'><strong>Advertencia:</strong> Si no se especifica un archivo, el contenido de <code>key</code> sustituirá el elemento <code>mountPath</code> del volumen. Esto quiere decir que si una ruta no está especificada de manera explícita, perderá todo el contenido de la carpeta de destino.<br></span></p>

<p>A continuación, especificará la imagen a partir de la cual se creará su pod. En  este tutorial se utilizará la imagen <code>nginx:1.7.9</code> por cuestiones de estabilidad, pero puede encontrar otras imágenes de Nginx en la tienda de <a href="https://hub.docker.com/explore/">Docker</a>. Además, debe hacer que Nginx esté disponible en el puerto 80. En <code>spec.template.spec</code>, agregue lo siguiente:</p>
<div class="code-label " title="nginx_deployment.yaml">nginx_deployment.yaml</div><pre class="code-pre "><code langs="">...
      containers:
      - name: nginx
        image: <span class="highlight">nginx:1.7.9</span>
        ports:
        - containerPort: 80
</code></pre>
<p>Nginx y PHP-FPM deben acceder al archivo en la misma ruta. Por ello, monte el volumen de <code>code</code> en <code>/code</code>:</p>
<div class="code-label " title="nginx_deployment.yaml">nginx_deployment.yaml</div><pre class="code-pre "><code langs="">...
        volumeMounts:
        - name: code
          mountPath: /code
</code></pre>
<p>La imagen <code>nginx:1.7.9</code> cargará de manera automática cualquier archivo de configuración en el directorio <code>/etc/nginx/conf.d</code>. Si se monta el volumen de <code>config</code> en este directorio, se creará el archivo <code>/etc/nginx/conf.d/site.conf</code>. En <code>volumeMounts</code>, agregue lo siguiente:</p>
<div class="code-label " title="nginx_deployment.yaml">nginx_deployment.yaml</div><pre class="code-pre "><code langs="">...
        - name: config
          mountPath: /etc/nginx/conf.d
</code></pre>
<p>Su archivo <code>nginx_deployment.yaml</code> tendrá el siguiente aspecto:</p>
<div class="code-label " title="nginx_deployment.yaml">nginx_deployment.yaml</div><pre class="code-pre "><code langs="">apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
  labels:
    tier: backend
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
      tier: backend
  template:
    metadata:
      labels:
        app: nginx
        tier: backend
    spec:
      volumes:
      - name: code
        persistentVolumeClaim:
          claimName: code
      - name: config
        configMap:
          name: nginx-config
          items:
          - key: config
            path: site.conf
      containers:
      - name: nginx
        image: <span class="highlight">nginx:1.7.9</span>
        ports:
        - containerPort: 80
        volumeMounts:
        - name: code
          mountPath: /code
        - name: config
          mountPath: /etc/nginx/conf.d
</code></pre>
<p>Guarde el archivo y salga del editor.</p>

<p>Cree la implementación de Nginx:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f nginx_deployment.yaml
</li></ul></code></pre>
<p>El siguiente resultado indica que se creó su implementación:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>deployment.apps/nginx created
</code></pre>
<p>Enumere sus implementaciones con el siguiente comando:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get deployments
</li></ul></code></pre>
<p>Visualizará las implementaciones de Nginx y PHP-FPM:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx     1         1         1            0           16s
php       1         1         1            1           7m
</code></pre>
<p>Enumere los pods administrados por ambas implementaciones:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get pods
</li></ul></code></pre>
<p>Visualizará los pods que estén en ejecución:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME                     READY     STATUS    RESTARTS   AGE
nginx-7bf5476b6f-zppml   1/1       Running   0          32s
php-86d59fd666-lkwgn     1/1       Running   0          7m
</code></pre>
<p>Ahora que todos los objetos de Kubernetes están activos, podrá visitar el servicio de Nginx en su navegador.</p>

<p>Enumere los servicios en ejecución:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get services -o wide
</li></ul></code></pre>
<p>Obtenga la IP externa para su servicio de Nginx:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE       SELECTOR
kubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP    39m       &lt;none&gt;
nginx        ClusterIP   10.102.160.47   <span class="highlight">your_public_ip</span> 80/TCP     27m       app=nginx,tier=backend
php          ClusterIP   10.100.59.238   &lt;none&gt;        9000/TCP   34m       app=php,tier=backend
</code></pre>
<p>En su navegador, visite su servidor escribiendo <code>http://<span class="highlight">your_public_ip</span></code>. Verá el resultado de <code>php_info()</code> y habrá confirmado que sus servicios de Kubernetes están configurados y activos.</p>

<h2 id="conclusión">Conclusión</h2>

<p>A través de esta guía , cargó en contenedores los servicios de PHP-FPM y Nginx para poder administrarlos de manera independiente. Este enfoque no solo mejorará la escalabilidad de su proyecto a medida que amplíe sus capacidades, sino también le permitirá utilizar los recursos de manera eficaz. También almacenó el código de su aplicación en un volumen para poder actualizar sus servicios de manera sencilla en el futuro.</p>
