---
layout: post
title: Понимание понятия классов в JavaScript
network: digitalocean
date: January 07, 2020 at 08:05PM
url: https://www.digitalocean.com/community/tutorials/understanding-classes-in-javascript-ru
image: http://ifttt.com/images/no_image_card.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="Введение">Введение</h3>

<p>JavaScript — это язык на базе прототипов, и каждый объект JavaScript имеет скрытое внутреннее свойство <code>[[Prototype]]</code>, которое можно использовать для расширения свойств и методов объекта. Вы можете узнать больше о прототипах из нашего обучающего модуля <a href="https://www.digitalocean.com/community/tutorials/understanding-prototypes-and-inheritance-in-javascript">Понимание принципов прототипов и наследования в JavaScript</a>.</p>

<p>До недавнего времени промышленные разработчики использовали <a href="https://www.digitalocean.com/community/tutorials/understanding-prototypes-and-inheritance-in-javascript#constructor-functions">функции конструктора</a> для имитации объектно-ориентированного шаблона в JavaScript. Языковая спецификация ECMAScript 2015 (часто называемая ES6) ввела в язык JavaScript понятие классов. Классы в JavaScript не добавляют дополнительные функции, и представляют собой способ упростить синтаксис при использовании прототипов и наследования и сделать его более элегантным. Поскольку в других языках программирования также используются классы, синтаксис классов в JavaScript упрощает работу для разработчиков, владеющих другими языками.</p>

<h2 id="Классы-—-это-функции">Классы — это функции</h2>

<p>Класс JavaScript — это вид функции. Для декларирования классов используется ключевое слово <code>class</code>. Мы используем синтаксис выражения функции для инициализации функции и синтаксис выражения класса для инициализации класса.</p>
<pre class="code-pre  second-environment"><code class="code-highlight language-js">// Initializing a function with a function expression
const x = function() {}
</code></pre><pre class="code-pre  fourth-environment"><code class="code-highlight language-js">// Initializing a class with a class expression
const y = class {}
</code></pre>
<p>Мы можем получить доступ к <code>[[Prototype]]</code> объекта с помощью <a href="https://www.digitalocean.com/community/tutorials/understanding-prototypes-and-inheritance-in-javascript#javascript-prototypes">метода <code>Object.getPrototypeOf()</code></a>. Давайте протестируем созданную нами пустую <strong>функцию</strong>.</p>
<pre class="code-pre  second-environment"><code class="code-highlight language-js">Object.getPrototypeOf(x);
</code></pre><pre class="code-pre  second-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>ƒ () { [native code] }
</code></pre>
<p>Также мы можем использовать этот метод для только что созданного нами <strong>класса</strong>.</p>
<pre class="code-pre  fourth-environment"><code class="code-highlight language-js">Object.getPrototypeOf(y);
</code></pre><pre class="code-pre  fourth-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>ƒ () { [native code] }
</code></pre>
<p>Программный код, декларированный с помощью <code>function</code> и <code>class</code>, возвращает функцию <code>[[Prototype]]</code>. При использовании прототипов любую функцию можно превратить в экземпляр конструктора с помощью ключевого слова <code>new</code>.</p>
<pre class="code-pre  second-environment"><code class="code-highlight language-js">const x = function() {}

// Initialize a constructor from a function
const constructorFromFunction = new x();

console.log(constructorFromFunction);
</code></pre><pre class="code-pre  second-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>x {}
constructor: ƒ ()
</code></pre>
<p>Это также относится и к классам.</p>
<pre class="code-pre  fourth-environment"><code class="code-highlight language-js">const y = class {}

// Initialize a constructor from a class
const constructorFromClass = new y();

console.log(constructorFromClass);
</code></pre><pre class="code-pre  fourth-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>y {}
constructor: class
</code></pre>
<p>Эти примеры конструктора прототипов пустые, но вы видите, как оба метода позволяют добиться одинакового результата вне зависимости от синтаксиса.</p>

<h2 id="Определение-класса">Определение класса</h2>

<p>В обучающем модуле <a href="https://www.digitalocean.com/community/tutorials/understanding-prototypes-and-inheritance-in-javascript#constructor-functions">Прототипы и наследование</a> мы создали пример, основанный на создании персонажа в текстовой ролевой игре. На этом же примере мы рассмотрим, как обновлять синтаксис от функций к классам.</p>

<p><strong>Функция конструктора</strong> инициализируется с рядом параметров, которые назначаются как свойства <code>this,</code> относящиеся к самой функции. Согласно правилам, первая буква идентификатора будет преобразована в заглавную.</p>
<div class="code-label " title="constructor.js">constructor.js</div><pre class="code-pre  second-environment"><code class="code-highlight language-js">// Initializing a constructor function
function Hero(name, level) {
    this.name = name;
    this.level = level;
}
</code></pre>
<p>При трансляции в синтаксис <strong>класса</strong>, как показано ниже, структура будет очень похожей.</p>
<div class="code-label " title="class.js">class.js</div><pre class="code-pre  fourth-environment"><code class="code-highlight language-js">// Initializing a class definition
class Hero {
    constructor(name, level) {
        this.name = name;
        this.level = level;
    }
}
</code></pre>
<p>Мы знаем, что функция конструктора является планом объекта благодаря тому, что первая буква инициализатора (необязательно) заглавная, и потому что мы знакомы с синтаксисом. Ключевое слово <code>class</code> показывает назначение нашей функции более прямо.</p>

<p>Единственная разница в синтаксисе инициализации заключается в использовании ключевого слова <code>class</code> вместо <code>function</code>, и в том, что свойства назначаются внутри метода <code>constructor()</code>.</p>

<h2 id="Определение-методов">Определение методов</h2>

<p>При использовании функций конструктора методы обычно назначаются непосредственно в <code>prototype</code> вместо инициализации, как показано ниже на примере метода <code>greet()</code>.</p>
<div class="code-label " title="constructor.js">constructor.js</div><pre class="code-pre  second-environment"><code class="code-highlight language-js">function Hero(name, level) {
    this.name = name;
    this.level = level;
}

// Adding a method to the constructor
Hero.prototype.greet = function() {
    return `${this.name} says hello.`;
}
</code></pre>
<p>При использовании классов этот синтаксис упрощается, и метод можно добавить напрямую в класс. Благодаря концепции <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions">заблаговременного определения методов,</a> введенной в ES6, определение методов стало еще более быстрой процедурой.</p>
<div class="code-label " title="class.js">class.js</div><pre class="code-pre  fourth-environment"><code class="code-highlight language-js">class Hero {
    constructor(name, level) {
        this.name = name;
        this.level = level;
    }

    // Adding a method to the constructor
    greet() {
        return `${this.name} says hello.`;
    }
}
</code></pre>
<p>Давайте посмотрим на эти свойства и методы в действии. Мы создадим новый экземпляр <code>Hero</code>, используя ключевое слово <code>new</code>, и присвоим некоторые значения.</p>
<pre class="code-pre  fourth-environment"><code class="code-highlight language-js">const hero1 = new Hero('Varg', 1);
</code></pre>
<p>Если мы распечатаем дополнительную информацию о нашем новом объекте с помощью команды <code>console.log(hero1)</code>, мы более подробно увидим. что происходит при инициализации класса.</p>
<pre class="code-pre  fourth-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>Hero {name: "Varg", level: 1}
__proto__:
  ▶ constructor: class Hero
  ▶ greet: ƒ greet()
</code></pre>
<p>В результатах мы видим, что функции <code>constructor()</code> и <code>greet() functions</code> были применены к прототипу <code>__proto__</code> или <code>[[Prototype]]</code> объекта <code>hero1</code>, а непосредственно к объекту <code>hero1</code> как к методу. Хотя при создании функций конструктора это очевидно, при создании классов дело обстоит по другому. Классы позволяют использовать более простой и сжатый синтаксис, но при этом немного теряется понятность процесса.</p>

<h2 id="Расширение-класса">Расширение класса</h2>

<p>Функции конструктора и классы можно расширять на новые планы объекта на основе родительского экземпляра. Это позволяет не повторять код для похожих объектов, для которых нужно просто добавить дополнительные или более детальные характеристики.</p>

<p>Новые функции конструктора можно создавать на основе родительского экземпляра с помощью метода <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call"><code>call()</code></a>. В примере ниже мы создадим более конкретный класс персонажа <code>Mage</code> и присвоим ему свойства <code>Hero</code> с помощью метода <code>call()</code>, а также добавим дополнительное свойство.</p>
<div class="code-label " title="constructor.js">constructor.js</div><pre class="code-pre  second-environment"><code class="code-highlight language-js">// Creating a new constructor from the parent
function Mage(name, level, spell) {
    // Chain constructor with call
    Hero.call(this, name, level);

    this.spell = spell;
}
</code></pre>
<p>Сейчас мы можем создать новый экземпляр <code>Mage</code>, используя те же свойства, что и <code>Hero</code> ,а также добавленное свойство.</p>
<pre class="code-pre  second-environment"><code class="code-highlight language-js">const hero2 = new Mage('Lejon', 2, 'Magic Missile');
</code></pre>
<p>Отправив на консоль команду <code>hero2</code>, мы увидим, что создали новый экземпляр <code>Mage</code> на базе конструктора.</p>
<pre class="code-pre  second-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>Mage {name: "Lejon", level: 2, spell: "Magic Missile"}
__proto__:
    ▶ constructor: ƒ Mage(name, level, spell)
</code></pre>
<p>Для классов ES6 ключевое слово <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super"><code>super</code></a> используется вместо <code>call</code> для доступа к родительским функциям. Мы будем использовать <code>extends</code> для обозначения родительского класса.</p>
<div class="code-label " title="class.js">class.js</div><pre class="code-pre  fourth-environment"><code class="code-highlight language-js">// Creating a new class from the parent
class Mage extends Hero {
    constructor(name, level, spell) {
        // Chain constructor with super
        super(name, level);

        // Add a new property
        this.spell = spell;
    }
}
</code></pre>
<p>Теперь мы можем точно так же создать новый экземпляр <code>Mage</code>.</p>
<pre class="code-pre  fourth-environment"><code class="code-highlight language-js">const hero2 = new Mage('Lejon', 2, 'Magic Missile');
</code></pre>
<p>Распечатаем <code>hero2</code> на консоли и посмотрим результат.</p>
<pre class="code-pre  fourth-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>Mage {name: "Lejon", level: 2, spell: "Magic Missile"}
__proto__: Hero
    ▶ constructor: class Mage
</code></pre>
<p>Результат практически такой же, но в конструкции класса прототип <code>[[Prototype]]</code> связан с родительским объектом, в данном случае <code>Hero</code>.</p>

<p>Ниже приводится полное сравнение процесса инициализации, добавления методов и наследования между функцией конструктора и классом.</p>
<div class="code-label " title="constructor.js">constructor.js</div><pre class="code-pre  second-environment"><code class="code-highlight language-js">function Hero(name, level) {
    this.name = name;
    this.level = level;
}

// Adding a method to the constructor
Hero.prototype.greet = function() {
    return `${this.name} says hello.`;
}

// Creating a new constructor from the parent
function Mage(name, level, spell) {
    // Chain constructor with call
    Hero.call(this, name, level);

    this.spell = spell;
}
</code></pre><div class="code-label " title="class.js">class.js</div><pre class="code-pre  fourth-environment"><code class="code-highlight language-js">// Initializing a class
class Hero {
    constructor(name, level) {
        this.name = name;
        this.level = level;
    }

    // Adding a method to the constructor
    greet() {
        return `${this.name} says hello.`;
    }
}

// Creating a new class from the parent
class Mage extends Hero {
    constructor(name, level, spell) {
        // Chain constructor with super
        super(name, level);

        // Add a new property
        this.spell = spell;
    }
}
</code></pre>
<p>Хотя синтаксис различается, конечный результат для обоих методов практически одинаковый. Классы дают более краткий способ создания шаблонов объектов, а функции конструктора более точно описывают конкретную механику.</p>

<h2 id="Заключение">Заключение</h2>

<p>В этом обучающем модуле мы узнали о сходствах и различиях между функциями конструктора JavaScript и классами ES6. Классы и конструкторы имитируют объектно-ориентированную модель наследования в JavaScript, который представляет собой язык наследования на основе прототипов.</p>

<p>Понимание принципов наследования прототипов очень важно, если вы хотите стать эффективным разработчиком на JavaScript. Знакомство с классами очень полезно, потому что популярные библиотеки JavaScript, такие как <a href="https://reactjs.org/">React</a>, часто используют синтаксис <code>class</code>.</p>
