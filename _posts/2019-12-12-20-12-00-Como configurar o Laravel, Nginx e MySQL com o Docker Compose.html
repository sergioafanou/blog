---
layout: post
title: Como configurar o Laravel, Nginx e MySQL com o Docker Compose
network: digitalocean
date: December 12, 2019 at 08:12PM
url: https://www.digitalocean.com/community/tutorials/how-to-set-up-laravel-nginx-and-mysql-with-docker-compose-pt
image: https://assets.digitalocean.com/articles/laravel_docker/laravel_home.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<p><em>O autor selecionou <a href="https://www.brightfunds.org/organizations/the-freebsd-foundation">A FreeBSD Foundation</a> para receber uma doação como parte do programa <a href="https://do.co/w4do-cta">Write for DOnations.</a></em></p>

<h3 id="introdução">Introdução</h3>

<p>Ao longo dos últimos anos, o <a href="https://docs.docker.com/">Docker</a> tornou-se uma solução frequentemente usada para implantar aplicativos graças a como ele simplifica a execução e implantação de aplicativos em <a href="https://www.docker.com/resources/what-container">contêineres</a> efêmeros. Ao usar uma pilha do aplicativo LEMP, por exemplo, com o <a href="https://php.net/docs.php">PHP</a>, <a href="https://nginx.org/en/">Nginx</a>, <a href="https://dev.mysql.com/doc/">MySQL</a> e o framework <a href="https://laravel.com/docs/5.6">Laravel</a>, o Docker pode simplificar significativamente o processo de configuração.</p>

<p>O <a href="https://docs.docker.com/compose/">Docker Compose</a> simplificou ainda mais o processo de desenvolvimento, permitindo que os desenvolvedores definam sua infraestrutura, incluindo serviços de aplicativo, redes e volumes em um único arquivo. O Docker Compose oferece uma alternativa eficiente para executar vários comandos <code>docker container create</code> e <code>docker container run</code>.</p>

<p>Neste tutorial, você irá construir um aplicativo Web usando o framework Laravel, com o Nginx como servidor Web e o MySQL como banco de dados, todos dentro de contêineres Docker. Você definirá a configuração de toda a pilha em um arquivo <code>docker-compose</code>, junto com arquivos de configuração para o PHP, MySQL e Nginx.</p>

<h2 id="pré-requisitos">Pré-requisitos</h2>

<p>Antes de começar, será necessário:</p>

<ul>
<li>Um servidor Ubuntu 18.04 e um usuário não raiz com privilégios <code>sudo</code>. Siga o tutorial <a href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04">Configuração inicial de servidor com o Ubuntu 18.04</a> para configurar isso.</li>
<li>O Docker instalado, seguindo os Passos 1 e 2 de <a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-18-04">Como instalar  e usar o Docker no Ubuntu 18.04</a>.</li>
<li>O Docker Compose instalado, seguindo o Passo 1 de <a href="https://www.digitalocean.com/community/tutorials/how-to-install-docker-compose-on-ubuntu-18-04">Como instalar o Docker Compose no Ubuntu 18.04</a>.</li>
</ul>

<h2 id="passo-1-—-fazendo-download-do-laravel-e-instalando-dependências">Passo 1 — Fazendo download do Laravel e instalando dependências</h2>

<p>Como primeiro passo, vamos obter a versão mais recente do Laravel e instalar as dependências para o projeto, incluindo o <a href="https://github.com/composer/docker">Composer</a>, o gerenciador de pacotes a nível de aplicativo para o PHP. Vamos instalar essas dependências com o Docker para evitar ter que instalar o Composer globalmente.</p>

<p>Primeiramente, verifique se você está no seu diretório home e faça uma cópia do último lançamento do Laravel para um diretório chamado <code><span class="highlight">laravel-app</span></code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd ~
</li><li class="line" prefix="$">git clone https://github.com/laravel/laravel.git <span class="highlight">laravel-app</span>
</li></ul></code></pre>
<p>Vá até o diretório <code><span class="highlight">laravel-app</span></code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd ~/<span class="highlight">laravel-app</span>
</li></ul></code></pre>
<p>Em seguida, utilize a imagem do <a href="https://hub.docker.com/r/library/composer/"><code>composer</code></a> para montar os diretórios que você precisará para seu projeto Laravel e evite os custos de instalar o Composer globalmente:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker run --rm -v $(pwd):/app composer install
</li></ul></code></pre>
<p>Ao usar os flag <code>-v</code> e <code>--rm</code> com o <code>docker run</code>, cria-se um contêiner efêmero que será montado e ligado ao seu diretório atual antes de ser removido. Isso irá copiar o conteúdo do seu diretório <code>~/<span class="highlight">laravel-app</span></code> para o container e também irá garantir que a pasta <code>vendor</code> que o Composer cria dentro do container seja copiada para seu diretório atual.</p>

<p>Como passo final, defina as permissões no diretório do projeto para que ele seja propriedade do seu usuário não <strong>root</strong>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo chown -R $USER:$USER ~/laravel-app
</li></ul></code></pre>
<p>Isso será importante quando escrever o Dockerfile para sua imagem do aplicativo no Passo 4, uma vez que permitirá que você trabalhe com seu código do aplicativo e executar processos no seu contêiner como um usuário não <strong>root</strong>.</p>

<p>Com seu código do aplicativo funcionando, você pode seguir em frente para definir seus serviços com o Docker Compose.</p>

<h2 id="passo-2-—-criando-o-arquivo-do-docker-compose">Passo 2 — Criando o arquivo do Docker Compose</h2>

<p>Construir seus aplicativos com o Docker Compose simplifica o processo de configurar e criar uma nova versão da sua infraestrutura. Para configurar nosso aplicativo Laravel, vamos escrever um arquivo <code>docker-compose</code> que defina nosso servidor Web, banco de dados e serviços de aplicativo.</p>

<p>Abra o arquivo:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano ~/laravel-app/docker-compose.yml
</li></ul></code></pre>
<p>No arquivo <code>docker-compose</code>, você definirá três serviços: <code>app</code>, <code>webserver</code> e <code>db</code>. Adicione o código a seguir ao arquivo, certificando-se de substituir a senha <strong>root</strong> para o <code>MYSQL_ROOT_PASSWORD</code>, definida como uma <a href="https://docs.docker.com/compose/compose-file/#environment">variável de ambiente</a> sob o serviço <code>db</code>, por uma senha forte da sua escolha:</p>
<div class="code-label " title="~/laravel-app/docker-compose.yml">~/laravel-app/docker-compose.yml</div><pre class="code-pre yml"><code langs="">version: '3'
services:

  #PHP Service
  app:
    build:
      context: .
      dockerfile: Dockerfile
    image: digitalocean.com/php
    container_name: app
    restart: unless-stopped
    tty: true
    environment:
      SERVICE_NAME: app
      SERVICE_TAGS: dev
    working_dir: /var/www
    networks:
      - app-network

  #Nginx Service
  webserver:
    image: nginx:alpine
    container_name: webserver
    restart: unless-stopped
    tty: true
    ports:
      - "80:80"
      - "443:443"
    networks:
      - app-network

  #MySQL Service
  db:
    image: mysql:5.7.22
    container_name: db
    restart: unless-stopped
    tty: true
    ports:
      - "3306:3306"
    environment:
      MYSQL_DATABASE: <span class="highlight">laravel</span>
      MYSQL_ROOT_PASSWORD: <span class="highlight">your_mysql_root_password</span>
      SERVICE_TAGS: dev
      SERVICE_NAME: mysql
    networks:
      - app-network

#Docker Networks
networks:
  app-network:
    driver: bridge
</code></pre>
<p>Os serviços aqui definidos incluem:</p>

<ul>
<li><code>app</code>: esta definição de serviço contém o aplicativo Laravel e executa uma imagem personalizada do Docker, <code>digitalocean.com/php</code>, que você definirá no Passo 4. Ela também define o <code>working_dir</code> no contêiner para <code>/var/www</code>.</li>
<li><code>webserver</code>: esta definição de serviço extrai a imagem <a href="https://hub.docker.com/_/nginx/"><code>nginx:alpine</code></a> do Docker e expõe as portas <code>80</code> e <code>443</code>.</li>
<li><code>db</code>: esta definição de serviço extrai a imagem <a href="https://hub.docker.com/_/mysql/"><code>mysql:5.7.22</code></a> do Docker e define algumas variáveis de ambiente, incluindo um banco de dados chamado <code><span class="highlight">laravel</span></code> para seu aplicativo e a senha da <strong>root</strong> para o banco de dados. Você pode dar o nome que quiser ao banco de dados e deve substituir o <code><span class="highlight">your_mysql_root_password</span></code> pela senha forte escolhida. Esta definição de serviço também mapeia a porta <code>3306</code> no host para a porta <code>3306</code> no contêiner.</li>
</ul>

<p>Cada propriedade <code>container_name</code> define um nome para o contêiner, que corresponde ao nome do serviço. Se não definir esta propriedade, o Docker irá atribuir um nome a cada contêiner combinando um nome de uma pessoa historicamente famosa e uma palavra aleatória separada por um underline.</p>

<p>Para facilitar a comunicação entre contêineres, os serviços estão conectados a uma rede bridge chamada <code>app-network</code>. Uma rede bridge utiliza um software bridge que permite que os contêineres conectados à mesma rede bridge se comuniquem uns com os outros. O driver da bridge instala automaticamente regras na máquina do host para que contêineres em redes bridge diferentes não possam se comunicar diretamente entre eles. Isso cria um nível de segurança mais elevado para os aplicativos, garantindo que apenas serviços relacionados possam se comunicar uns com os outros. Isso também significa que você pode definir várias redes e serviços que se conectam a funções relacionadas: os serviços de aplicativo front-end podem usar uma rede <code>frontend</code>, por exemplo, e os serviços <code>back-end</code> podem usar uma rede backend.</p>

<p>Vamos ver como adicionar volumes e bind mounts às definições do seu serviço para persistir os dados do seu aplicativo.</p>

<h2 id="passo-3-—-persistindo-os-dados">Passo 3 — Persistindo os dados</h2>

<p>O Docker tem recursos poderosos e convenientes para persistir os dados. No nosso aplicativo, vamos usar <a href="https://docs.docker.com/storage/volumes/"><em>volumes</em></a> e <a href="https://docs.docker.com/storage/bind-mounts/"><em>bind mounts</em></a> para persistir o banco de dados, o aplicativo e os arquivos de configuração. Os volumes oferecem flexibilidade para backups e persistência além do ciclo de vida de um contêiner, enquanto os bind mounts facilitam alterações no código durante o desenvolvimento, fazendo alterações nos arquivos do host ou diretórios imediatamente disponíveis nos seus contêineres. Nossa configuração usará ambos.</p>

<p><span class='warning'><strong>Aviso:</strong> ao usar os bind mounts, você torna possível alterar o sistema de arquivos do host através de processos executados em um contêiner, incluindo criar, modificar ou excluir arquivos de sistema ou diretórios importantes. Esta é uma habilidade poderosa com implicações de segurança e pode ter impacto em processos além do Docker no sistema do host. Use os bind mounts com cuidado.<br></span></p>

<p>No arquivo <code>docker-compose</code>, defina um volume chamado <code>dbdata</code> sob a definição do serviço <code>db</code> para persistir o banco de dados MySQL:</p>
<div class="code-label " title="~/laravel-app/docker-compose.yml">~/laravel-app/docker-compose.yml</div><pre class="code-pre docker"><code langs="">...
#MySQL Service
db:
  ...
    <span class="highlight">volumes:</span>
      <span class="highlight">- dbdata:/var/lib/mysql</span>
    networks:
      - app-network
  ...
</code></pre>
<p>O volume com nome <code>dbdata</code> persiste o conteúdo da pasta <code>/var/lib/mysql</code> presente dentro do container. Isso permite que você pare e reinicie o serviço <code>db</code> sem perder dados.</p>

<p>No final do arquivo, adicione a definição para o volume <code>dbdata</code>:</p>
<div class="code-label " title="~/laravel-app/docker-compose.yml">~/laravel-app/docker-compose.yml</div><pre class="code-pre docker"><code langs="">...
#Volumes
volumes:
  dbdata:
    driver: local
</code></pre>
<p>Com esta definição no lugar, você poderá usar este volume em diferentes serviços.</p>

<p>Em seguida, adicione um bind mount ao serviço <code>db</code> para os arquivos de configuração do MySQL que você criará no Passo 7:</p>
<div class="code-label " title="~/laravel-app/docker-compose.yml">~/laravel-app/docker-compose.yml</div><pre class="code-pre docker"><code langs="">...
#MySQL Service
db:
  ...
    volumes:
      - dbdata:/var/lib/mysql
      <span class="highlight">- ./mysql/my.cnf:/etc/mysql/my.cnf</span>
  ...
</code></pre>
<p>Este bind mount vincula o <code>~/laravel-app/mysql/my.cnf</code> ao <code>/etc/mysql/my.cnf</code> no contêiner.</p>

<p>Em seguida, adicione bind mounts ao serviço <code>webserver</code>. Haverá dois: um para seu código do aplicativo e outro para a definição de configuração do Nginx que você criará no Passo 6:</p>
<div class="code-label " title="~/laravel-app/docker-compose.yml">~/laravel-app/docker-compose.yml</div><pre class="code-pre docker"><code langs="">#Nginx Service
webserver:
  ...
  <span class="highlight">volumes:</span>
      <span class="highlight">- ./:/var/www</span>
      <span class="highlight">- ./nginx/conf.d/:/etc/nginx/conf.d/</span>
  networks:
      - app-network
</code></pre>
<p>O primeiro bind mount vincula o código do aplicativo no diretório <code>~/laravel-app</code> ao diretório <code>/var/www</code> dentro do contêiner. O arquivo de configuração que você adicionará ao <code>~/laravel-app/nginx/conf.d/</code> também será montado em <code>etc/nginx/conf.d/</code> no container, permitindo que o conteúdo do diretório de configuração seja adicionado ou modificado conforme necessário.</p>

<p>Por fim, adicione os seguintes bind mounts ao serviço <code>app</code> para o código do aplicativo e os arquivos de configuração:</p>
<div class="code-label " title="~/laravel-app/docker-compose.yml">~/laravel-app/docker-compose.yml</div><pre class="code-pre docker"><code langs="">#PHP Service
app:
  ...
  <span class="highlight">volumes:</span>
       <span class="highlight">- ./:/var/www</span>
       <span class="highlight">- ./php/local.ini:/usr/local/etc/php/conf.d/local.ini</span>
  networks:
      - app-network
</code></pre>
<p>O serviço <code>app</code> está vinculando a pasta <code>~/laravel-app</code>, que contém o código do aplicativo, à pasta <code>/var/www</code> no contêiner com o uso do bind mount. Isso irá acelerar o processo de desenvolvimento, uma vez que quaisquer alterações feitas no seu diretório local do aplicativo serão refletidas instantaneamente dentro do contêiner. Você também está vinculando seu arquivo de configuração PHP, <code>~/laravel-app/php/local.ini</code>, ao <code>/usr/local/etc/php/conf.d/local.ini</code> dentro do contêiner. Você criará o arquivo de configuração local do PHP no Passo 5.</p>

<p>Seu arquivo <code>docker-compose</code> agora se parecerá com este:</p>
<div class="code-label " title="~/laravel-app/docker-compose.yml">~/laravel-app/docker-compose.yml</div><pre class="code-pre yml"><code langs="">version: '3'
services:

  #PHP Service
  app:
    build:
      context: .
      dockerfile: Dockerfile
    image: digitalocean.com/php
    container_name: app
    restart: unless-stopped
    tty: true
    environment:
      SERVICE_NAME: app
      SERVICE_TAGS: dev
    working_dir: /var/www
    volumes:
      - ./:/var/www
      - ./php/local.ini:/usr/local/etc/php/conf.d/local.ini
    networks:
      - app-network

  #Nginx Service
  webserver:
    image: nginx:alpine
    container_name: webserver
    restart: unless-stopped
    tty: true
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./:/var/www
      - ./nginx/conf.d/:/etc/nginx/conf.d/
    networks:
      - app-network

  #MySQL Service
  db:
    image: mysql:5.7.22
    container_name: db
    restart: unless-stopped
    tty: true
    ports:
      - "3306:3306"
    environment:
      MYSQL_DATABASE: <span class="highlight">laravel</span>
      MYSQL_ROOT_PASSWORD: <span class="highlight">your_mysql_root_password</span>
      SERVICE_TAGS: dev
      SERVICE_NAME: mysql
    volumes:
      - dbdata:/var/lib/mysql/
      - ./mysql/my.cnf:/etc/mysql/my.cnf
    networks:
      - app-network

#Docker Networks
networks:
  app-network:
    driver: bridge
#Volumes
volumes:
  dbdata:
    driver: local
</code></pre>
<p>Salve o arquivo e saia do seu editor quando terminar de fazer alterações.</p>

<p>Com seu arquivo <code>docker-compose</code> escrito, você pode agora construir a imagem personalizada para seu aplicativo.</p>

<h2 id="passo-4-—-criando-o-dockerfile">Passo 4 — Criando o Dockerfile</h2>

<p>O Docker permite que você especifique o ambiente dentro de contêineres individuais com um* Dockerfil*e. Um Dockerfile permite que você crie imagens personalizadas que você possa usar para instalar o software necessário para seu aplicativo e configurar as definições baseando-se nos seus requisitos. Você pode enviar as imagens personalizadas que você criar para o <a href="https://hub.docker.com/">Docker Hub</a> ou qualquer registro privado.</p>

<p>Nosso <code>Dockerfile</code> estará localizado no nosso diretório <code>~/laravel-app</code>. Crie o arquivo:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano ~/laravel-app/Dockerfile
</li></ul></code></pre>
<p>Este <code>Dockerfile</code> irá definir a imagem base e especificar os comandos e instruções necessários para construir a imagem do aplicativo Laravel. Adicione o código a seguir ao arquivo:</p>
<div class="code-label " title="~/laravel-app/php/Dockerfile">~/laravel-app/php/Dockerfile</div><pre class="code-pre docker"><code langs="">FROM php:7.2-fpm

# Copy composer.lock and composer.json
COPY composer.lock composer.json /var/www/

# Set working directory
WORKDIR /var/www

# Install dependencies
RUN apt-get update &amp;&amp; apt-get install -y \
    build-essential \
    mysql-client \
    libpng-dev \
    libjpeg62-turbo-dev \
    libfreetype6-dev \
    locales \
    zip \
    jpegoptim optipng pngquant gifsicle \
    vim \
    unzip \
    git \
    curl

# Clear cache
RUN apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/*

# Install extensions
RUN docker-php-ext-install pdo_mysql mbstring zip exif pcntl
RUN docker-php-ext-configure gd --with-gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ --with-png-dir=/usr/include/
RUN docker-php-ext-install gd

# Install composer
RUN curl -sS https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer

# Add user for laravel application
RUN groupadd -g 1000 www
RUN useradd -u 1000 -ms /bin/bash -g www www

# Copy existing application directory contents
COPY . /var/www

# Copy existing application directory permissions
COPY --chown=www:www . /var/www

# Change current user to www
USER www

# Expose port 9000 and start php-fpm server
EXPOSE 9000
CMD ["php-fpm"]
</code></pre>
<p>Primeiramente, o Dockerfile cria uma imagem sobre a imagem Docker <a href="https://hub.docker.com/_/php/"><code>php:7.2-fpm</code></a>. Esta é uma imagem baseada no Debian que tem a implementação FastCGI <a href="https://php-fpm.org/">PHP-FPM</a> do PHP instalada. O arquivo também instala os pacotes pré-requisitos para o Laravel: o <code>mcrypt</code>, <code>pdo_mysql</code>, <code>mbstring</code> e <code>imagick</code> com o <code>composer</code>.</p>

<p>A diretriz <code>RUN</code> especifica os comandos para atualizar, instalar e configurar as configurações dentro do contêiner, incluindo a criação de um usuário e grupo dedicados chamados <strong>www</strong>. A instrução <code>WORKDIR</code> especifica o diretório <code>/var/www</code> como diretório de trabalho para o aplicativo.</p>

<p>Criar um usuário e grupo dedicados com permissões limitadas mitiga a vulnerabilidade inerente na execução de contêineres Docker, que são executados por padrão como <strong>root</strong>. Ao invés de executar este contêiner como <strong>root</strong>, criamos o usuário <strong>www</strong>, que tem acesso de leitura/escrita à pasta <code>/var/www</code> graças à instrução <code>COPY</code> que estamos usando com a flag <code>--chown</code> para copiar as permissões da pasta do aplicativo.</p>

<p>Por fim, o comando <code>EXPOSE</code> expõe uma porta no contêiner, <code>9000</code>, para o servidor <code>php-fpm</code>. <code>O CMD</code> especifica o comando que deve ser executado assim que o contêiner for criado. Aqui, o <code>CMD</code> especifica o <code>"php-fpm"</code>, que fará com que o servidor inicie.</p>

<p>Salve o arquivo e saia do seu editor quando terminar de fazer alterações.</p>

<p>Agora, você pode seguir em frente para definir sua configuração PHP.</p>

<h2 id="passo-5-—-configurando-o-php">Passo 5 — Configurando o PHP</h2>

<p>Agora que você definiu sua infraestrutura no arquivo <code>docker-compose</code>, é possível configurar o serviço PHP para agir como um processador PHP para pedidos de entrada do Nginx.</p>

<p>Para configurar o PHP, será criado o arquivo <code>local.ini</code> dentro da pasta <code>php</code>. Este é o arquivo que você vinculou ao <code>/usr/local/etc/php/conf.d/local.ini</code> dentro do contêiner no Passo 2. A criação deste arquivo permitirá que você substitua o arquivo padrão <code>php.ini</code> que o PHP lê quando inicia.</p>

<p>Crie o diretório <code>php</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir ~/laravel-app/php
</li></ul></code></pre>
<p>Em seguida, abra o arquivo <code>local.ini</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano ~/laravel-app/php/local.ini
</li></ul></code></pre>
<p>Para demonstrar como configurar o PHP, adicionaremos o código a seguir para definir limitações de tamanho para arquivos enviados:</p>
<div class="code-label " title="~/laravel-app/php/local.ini">~/laravel-app/php/local.ini</div><pre class="code-pre "><code class="code-highlight language-ini">upload_max_filesize=40M
post_max_size=40M
</code></pre>
<p>As diretrizes <code>upload_max_filesize</code> e <code>post_max_size</code> definem o tamanho máximo permitido para arquivos enviados e demonstram como você pode definir configurações <code>php.ini</code> a partir do seu arquivo <code>local.ini</code>. Você pode colocar qualquer configuração específica do PHP que queira substituir no arquivo <code>local.ini</code>.</p>

<p>Salve o arquivo e saia do seu editor.</p>

<p>Com o seu arquivo PHP <code>local.ini</code> no lugar, você pode seguir em frente para configurar o Nginx.</p>

<h2 id="passo-6-—-configurando-o-nginx">Passo 6 — Configurando o Nginx</h2>

<p>Com o serviço PHP configurado, você pode modificar o serviço Nginx para usar o PHP-FPM como o servidor FastCGI a atender um conteúdo dinâmico. O servidor FastCGI baseia-se em um protocolo binário para relacionar programas interativos com um servidor Web. Para maiores informações, consulte este artigo <a href="https://www.digitalocean.com/community/tutorials/understanding-and-implementing-fastcgi-proxying-in-nginx">Entendendo e implementando o proxy FastCGI no Nginx</a>.</p>

<p>Para configurar o Nginx, será criado um arquivo <code>app.conf</code> com a configuração do serviço na pasta <code>~/laravel-app/nginx/conf.d/</code>.</p>

<p>Primeiramente, crie o diretório <code>nginx/conf.d/</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir -p ~/laravel-app/nginx/conf.d
</li></ul></code></pre>
<p>Em seguida, crie o arquivo de configuração <code>app.conf</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano ~/laravel-app/nginx/conf.d/app.conf
</li></ul></code></pre>
<p>Adicione o código a seguir ao arquivo para especificar sua configuração do Nginx:</p>
<div class="code-label " title="~/laravel-app/nginx/conf.d/app.conf">~/laravel-app/nginx/conf.d/app.conf</div><pre class="code-pre "><code class="code-highlight language-nginx">server {
    listen 80;
    index index.php index.html;
    error_log  /var/log/nginx/error.log;
    access_log /var/log/nginx/access.log;
    root /var/www/public;
    location ~ \.php$ {
        try_files $uri =404;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass app:9000;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param PATH_INFO $fastcgi_path_info;
    }
    location / {
        try_files $uri $uri/ /index.php?$query_string;
        gzip_static on;
    }
}
</code></pre>
<p>O <a href="https://www.digitalocean.com/community/tutorials/understanding-nginx-server-and-location-block-selection-algorithms">bloco de servidor</a> define a configuração do servidor Web Nginx com as diretrizes a seguir:</p>

<ul>
<li><code>listen</code>: esta diretriz define a porta na qual o servidor irá escutar os pedidos de entrada.</li>
<li><code>error_log</code> e <code>access_log</code>: estas diretrizes definem os arquivos para a criação de registros.</li>
<li><code>root</code>: esta diretriz define o caminho da pasta raiz, formando o caminho completo para qualquer arquivo solicitado no sistema de arquivo local.</li>
</ul>

<p>No bloco de localização <code>php</code>, a diretriz <code>fastcgi_pass</code> especifica que o serviço <code>app</code> está escutando em um socket TCP na porta <code>9000</code>. Isso faz com que o servidor PHP-FPM escute pela rede em vez de escutar por um socket Unix. Embora um socket Unix tenha uma ligeira vantagem de velocidade em relação a um socket TCP, ele não tem um protocolo de rede e, desta maneira, ignora a pilha de rede. Para casos onde os hosts estão localizados em uma máquina, um socket Unix pode fazer sentido, mas nos casos em que se tenha serviços sendo executados em hosts diferentes, um socket TCP oferece a vantagem de permitir que você se conecte a serviços distribuídos. Pelo fato do nosso contêiner <code>app</code> estar sendo executado em um host diferente do nosso contêiner <code>webserver</code>, um socket TCP faz mais sentido para nossa configuração.</p>

<p>Salve o arquivo e saia do seu editor quando terminar de fazer alterações.</p>

<p>Graças ao bind mount criado no Passo 2, quaisquer alterações que você faça dentro da pasta <code>nginx/conf.d/</code> serão refletidas diretamente dentro do contêiner <code>webserver</code>.</p>

<p>Em seguida, vamos olhar nossas configurações do MySQL.</p>

<h2 id="passo-7-—-configurando-o-mysql">Passo 7 — Configurando o MySQL</h2>

<p>Com o PHP e o Nginx configurados, você pode habilitar o MySQL para agir como o banco de dados para seu aplicativo.</p>

<p>Para configurar o MySQL, será criado o arquivo <code>my.cnf</code> na pasta <code>mysql</code>. Este é o arquivo que você vinculou ao <code>/etc/mysql/my.cnf</code> dentro do contêiner no Passo 2. Este bind mount permite que você substitua as configurações <code>my.cnf</code> sempre que necessário.</p>

<p>Para demonstrar como isso funciona, adicionaremos as configurações ao arquivo <code>my.cnf</code> que habilitam o registro de consulta geral e especificam o arquivo de registro.</p>

<p>Primeiramente, crie o diretório <code>mysql</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir ~/laravel-app/mysql
</li></ul></code></pre>
<p>Em seguida, crie o arquivo <code>my.cnf</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano ~/laravel-app/mysql/my.cnf
</li></ul></code></pre>
<p>No arquivo, adicione o código a seguir para habilitar o registro de consulta e definir a localização do arquivo de registro:</p>
<div class="code-label " title="~/laravel-app/mysql/my.cnf">~/laravel-app/mysql/my.cnf</div><pre class="code-pre "><code class="code-highlight language-ini">[mysqld]
general_log = 1
general_log_file = /var/lib/mysql/general.log
</code></pre>
<p>Este arquivo <code>my.cnf</code> habilita os registros, definindo a configuração <code>general_log</code> em <code>1</code> para permitir registros gerais. A configuração <code>general_log_file</code> especifica onde os registros serão armazenados.</p>

<p>Salve o arquivo e saia do seu editor.</p>

<p>Nosso próximo passo será iniciar os contêineres.</p>

<h2 id="passo-8-—-executando-os-contêineres-e-modificando-as-configurações-de-ambiente">Passo 8 — Executando os contêineres e modificando as configurações de ambiente</h2>

<p>Agora que definiu todos os seus serviços no seu arquivo <code>docker-compose</code> e criou os arquivos de configuração para esses serviços, você pode iniciar os contêineres. Como passo final, porém, vamos fazer uma cópia do arquivo <code>.env.example</code> que o Laravel inclui por padrão e nomear a copia <code>.env</code>, que é o arquivo que o Laravel espera para definir seu ambiente:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cp .env.example .env
</li></ul></code></pre>
<p>Vamos configurar os detalhes específicos da nossa configuração neste arquivo assim que tivermos iniciado os contêineres.</p>

<p>Com todos os seus serviços definidos no seu arquivo <code>docker-compose</code>, você precisa emitir um único comando para iniciar todos os contêineres, criar os volumes e configurar e conectar as redes:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose up -d
</li></ul></code></pre>
<p>Quando você executar o <code>docker-compose up</code> pela primeira vez, ele irá baixar todas as imagens Docker necessárias, o que pode levar um tempo. Assim que as imagens forem baixadas e armazenadas na sua máquina local, o Compose criará seus contêineres. A flag <code>-d</code> faz o daemon do processo, executando seus contêineres em segundo plano.</p>

<p>Assim que o processo for concluído, utilize o comando a seguir para listar todos os contêineres em execução:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker ps
</li></ul></code></pre>
<p>Você verá o seguinte resultado com detalhes sobre seus contêineres do <code>app</code>, <code>webserver</code> e <code>db</code>:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>CONTAINER ID        NAMES               IMAGE                             STATUS              PORTS
c31b7b3251e0        db                  mysql:5.7.22                      Up 2 seconds        0.0.0.0:3306-&gt;3306/tcp
ed5a69704580        app                 digitalocean.com/php              Up 2 seconds        9000/tcp
5ce4ee31d7c0        webserver           nginx:alpine                      Up 2 seconds        0.0.0.0:80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp
</code></pre>
<p>O <code>CONTAINER ID</code> neste resultado é um identificador único para cada contêiner, enquanto o <code>NAMES</code> lista o nome do serviço associado a cada um. Você pode usar ambos esses identificadores para acessar os contêineres<code>. IMAGE</code> define o nome da imagem para cada contêiner, enquanto o <code>STATUS</code> fornece informações sobre o estado do contêiner: se ele está em execução, reiniciando ou parado.</p>

<p>Você pode agora modificar o arquivo <code>.env</code> no contêiner <code>app</code> para incluir detalhes específicos sobre sua configuração.</p>

<p>Abra o arquivo usando o <code>docker-compose exec</code>, que permite que você execute comandos específicos em contêineres. Neste caso, você está abrindo o arquivo para edição:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose exec <span class="highlight">app</span> nano .env
</li></ul></code></pre>
<p>Encontre o bloco que especifica o <code>DB_CONNECTION</code> e atualize-o para refletir as especificidades da sua configuração. Você modificará os seguintes campos:</p>

<ul>
<li>O <code>DB_HOST</code> será seu contêiner de banco de dados <code>db</code>.</li>
<li>O <code>DB_DATABASE</code> será o banco de dados <code><span class="highlight">laravel</span></code>.</li>
<li>O <code>DB_USERNAME</code> será o nome de usuário que você usará para o seu banco de dados. Neste caso, vamos usar <code><span class="highlight">laraveluser</span></code>.</li>
<li>O <code>DB_PASSWORD</code> será a senha segura que você gostaria de usar para esta conta de usuário.</li>
</ul>
<div class="code-label " title="/var/www/.env">/var/www/.env</div><pre class="code-pre "><code langs="">DB_CONNECTION=mysql
DB_HOST=<span class="highlight">db</span>
DB_PORT=3306
DB_DATABASE=<span class="highlight">laravel</span>
DB_USERNAME=<span class="highlight">laraveluser</span>
DB_PASSWORD=<span class="highlight">your_laravel_db_password</span>
</code></pre>
<p>Salve suas alterações e saia do seu editor.</p>

<p>Em seguida, defina a chave do aplicativo para o aplicativo Laravel com o comando <code>php artisan key:generate</code>. Este comando irá gerar uma chave e copiá-la para seu arquivo <code>.env</code>, garantindo que as sessões do seu usuário e dados criptografados permaneçam seguros:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose exec <span class="highlight">app</span> php artisan key:generate
</li></ul></code></pre>
<p>Você tem agora as configurações de ambiente necessárias para executar seu aplicativo. Para colocar essas configurações em um arquivo de cache, que irá aumentar a velocidade de carregamento do seu aplicativo, execute:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose exec <span class="highlight">app</span> php artisan config:cache
</li></ul></code></pre>
<p>Suas definições da configuração serão carregadas em <code>/var/www/bootstrap/cache/config.php</code> no contêiner.</p>

<p>Como passo final, visite <code>http://<span class="highlight">your_server_ip</span></code> no navegador. Você verá a seguinte página inicial para seu aplicativo Laravel:</p>

<p><img src="https://assets.digitalocean.com/articles/laravel_docker/laravel_home.png" alt="Laravel Home Page"></p>

<p>Com os seus contêineres em funcionamento e as suas informações de configuração no lugar, você pode seguir em frente para configurar as informações do seu usuário para o banco de dados <code><span class="highlight">laravel</span></code> no contêiner <code>db</code>.</p>

<h2 id="passo-9-—-criando-um-usuário-para-o-mysql">Passo 9 — Criando um usuário para o MySQL</h2>

<p>A instalação padrão do MySQL cria apenas a conta administrativa <strong>root</strong>, que tem privilégios ilimitados no servidor do banco de dados. Geralmente, é melhor evitar usar contas administrativas <strong>root</strong> ao interagir com o banco de dados. Ao invés disso, vamos criar um usuário de banco de dados dedicado para o banco de dados do nosso aplicativo Laravel.</p>

<p>Para criar um novo usuário, execute uma bash shell interativa no contêiner <code>db</code> com o <code>docker-compose exec</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose exec <span class="highlight">db</span> bash
</li></ul></code></pre>
<p>Dentro do contêiner, logue na conta administrativa <strong>root</strong> do MySQL:</p>
<pre class="code-pre custom_prefix second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="root@c31b7b3251e0:/#">mysql -u root -p
</li></ul></code></pre>
<p>Você será solicitado a inserir a senha que você definiu para a conta <strong>root</strong> do MySQL durante a instalação no seu arquivo <code>docker-compose</code>.</p>

<p>Inicie procurando pelo banco de dados chamado <code><span class="highlight">laravel</span></code>, que você definiu no seu arquivo <code>docker-compose</code>. Execute o comando <code>show databases</code> para procurar por bancos de dados existentes:</p>
<pre class="code-pre custom_prefix second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="mysql&gt;">show databases;
</li></ul></code></pre>
<p>Você verá o banco de dados <code><span class="highlight">laravel</span></code> listado no resultado:</p>
<pre class="code-pre  second-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>+--------------------+
| Database           |
+--------------------+
| information_schema |
| <span class="highlight">laravel</span>            |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
5 rows in set (0.00 sec)
</code></pre>
<p>Em seguida, crie a conta de usuário que terá permissão para acessar esse banco de dados. Nosso nome de usuário será <code><span class="highlight">laraveluser</span></code>, embora você possa substituí-lo por outro nome se preferir. Certifique-se apenas de que seu nome de usuário e senha aqui utilizados correspondam aos detalhes que você definiu no seu arquivo <code>.env</code> no passo anterior:</p>
<pre class="code-pre custom_prefix second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="mysql&gt;">GRANT ALL ON laravel.* TO '<span class="highlight">laraveluser</span>'@'%' IDENTIFIED BY '<span class="highlight">your_laravel_db_password</span>';
</li></ul></code></pre>
<p>Reinicie os privilégios para notificar o servidor MySQL das alterações:</p>
<pre class="code-pre custom_prefix second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="mysql&gt;">FLUSH PRIVILEGES;
</li></ul></code></pre>
<p>Saia do MySQL:</p>
<pre class="code-pre custom_prefix second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="mysql&gt;">EXIT;
</li></ul></code></pre>
<p>Por fim, saia do contêiner:</p>
<pre class="code-pre custom_prefix second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="root@c31b7b3251e0:/#">exit
</li></ul></code></pre>
<p>Você configurou a conta de usuário para seu banco de dados do aplicativo Laravel e está pronto para migrar seus dados e trabalhar com o console Tinker.</p>

<h2 id="passo-10-—-migrando-dados-e-trabalhando-com-o-console-tinker">Passo 10 — Migrando dados e trabalhando com o console Tinker</h2>

<p>Com seu aplicativo em execução, você pode migrar seus dados e testar o comando <code>tinker</code>, que iniciará um console <a href="http://psysh.org/"><em>PsySH</em></a> com o Laravel pré-carregado. O PsySH é um console de desenvolvimento runtime e um corretor de bugs interativo para o PHP e o Tinker é um REPL específico para o Laravel. Usar o comando <code>tinker</code> permitirá que você interaja com seu aplicativo Laravel a partir da linha de comando em uma shell interativa.</p>

<p>Primeiramente, teste a conexão com o MySQL executando o comando Laravel <code>artisan migrate</code>, que cria uma tabela <code>migrations</code> no banco de dados de dentro do contêiner:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose exec <span class="highlight">app</span> php artisan migrate
</li></ul></code></pre>
<p>Este comando irá migrar as tabelas padrão do Laravel. O resultado que confirma a migração será como este:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>
Migration table created successfully.
Migrating: 2014_10_12_000000_create_users_table
Migrated:  2014_10_12_000000_create_users_table
Migrating: 2014_10_12_100000_create_password_resets_table
Migrated:  2014_10_12_100000_create_password_resets_table
</code></pre>
<p>Assim que a migração for concluída, você pode fazer uma consulta para verificar se está devidamente conectado ao banco de dados usando o comando <code>tinker</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose exec <span class="highlight">app</span> php artisan tinker
</li></ul></code></pre>
<p>Teste a conexão do MySQL obtendo os dados que acabou de migrar:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="&gt;&gt;&gt;">\DB::table('migrations')-&gt;get();
</li></ul></code></pre>
<p>Você verá um resultado que se parece com este:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>=&gt; Illuminate\Support\Collection {#2856
     all: [
       {#2862
         +"id": 1,
         +"migration": "2014_10_12_000000_create_users_table",
         +"batch": 1,
       },
       {#2865
         +"id": 2,
         +"migration": "2014_10_12_100000_create_password_resets_table",
         +"batch": 1,
       },
     ],
   }
</code></pre>
<p>Você pode usar o <code>tinker</code> para interagir com seus bancos de dados e testar serviços e modelos.</p>

<p>Com seu aplicativo Laravel funcionando, você está pronto para mais desenvolvimento e experimentação.</p>

<h2 id="conclusão">Conclusão</h2>

<p>Você tem agora um aplicativo de pilha LEMP em execução no seu servidor, que você testou ao acessar a página inicial do Laravel e ao criar migrações de banco de dados MySQL.</p>

<p>A chave para a simplicidade desta instalação é o Docker Compose, que permite que você crie um grupo de contêineres Docker, definidos em um único arquivo, com um único comando. Se você quiser aprender mais sobre como fazer integração contínua com o Docker Compose, veja <a href="https://www.digitalocean.com/community/tutorials/how-to-configure-a-continuous-integration-testing-environment-with-docker-and-docker-compose-on-ubuntu-16-04">Como configurar um ambiente de teste de integração contínua com o Docker e o Docker Compose no Ubuntu 16.04</a>. Se você quiser simplificar seu processo de implantação do aplicativo Laravel, então o <a href="https://www.digitalocean.com/community/tutorials/automatically-deploy-laravel-applications-deployer-ubuntu">Como implantar aplicativos Laravel automaticamente com o Deployer no Ubuntu 16.04</a> será uma leitura relevante.</p>
