---
layout: post
title: How To Set Up a Node.js Application for Production on Debian 10
network: digitalocean
date: July 12, 2019 at 06:42PM
---
<h3 id="introduction">Introduction</h3>

<p><a href="https://nodejs.org/en/">Node.js</a> is an open-source JavaScript runtime environment for building server-side and networking applications. The platform runs on Linux, macOS, FreeBSD, and Windows. Though you can run Node.js applications at the command line, this tutorial will focus on running them as a service. This means that the applications will restart on reboot or failure and are safe for use in a production environment.</p>

<p>In this tutorial, you will set up a production-ready Node.js environment on a single Debian 10 server.  This server will run a Node.js application managed by <a href="http://pm2.keymetrics.io/">PM2</a>, and provide users with secure access to the application through an <a href="https://nginx.org/">Nginx</a> reverse proxy. The Nginx server will offer HTTPS, using a free certificate provided by <a href="https://letsencrypt.org/">Let's Encrypt</a>.</p>

<h2 id="prerequisites">Prerequisites</h2>

<p>This guide assumes that you have the following:</p>

<ul>
<li>A Debian 10 server setup, as described in the <a href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-debian-10">initial server setup guide for Debian 10</a>. You should have a non-root user with <code>sudo</code> privileges and an active firewall.</li>
<li>A <a href="https://www.digitalocean.com/docs/networking/dns/quickstart/">domain name pointed at your server's public IP</a>. </li>
<li>Nginx installed, as covered in <a href="https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-debian-10">How To Install Nginx on Debian 10</a>.</li>
<li>Nginx configured with SSL using Let's Encrypt certificates. <a href="https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-debian-10">How To Secure Nginx with Let's Encrypt on Debian 10</a> will walk you through the process.</li>
</ul>

<p>When you've completed the prerequisites, you will have a server serving your domain's default placeholder page at <code>https://<span class="highlight">your_domain</span>/</code>.</p>

<h2 id="step-1-—-installing-node-js">Step 1 — Installing Node.js</h2>

<p>Let's begin by installing the latest LTS release of Node.js, using the <a href="https://github.com/nodesource/distributions">NodeSource</a> package archives.</p>

<p>To install the NodeSource PPA and access its contents, you will first need to update your package index and install <code>curl</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt update
</li><li class="line" prefix="$">sudo apt install curl
</li></ul></code></pre>
<p>Make sure you're in your home directory, and then use <code>curl</code> to retrieve the installation script for the Node.js <span class="highlight">10</span>.x archives:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd ~
</li><li class="line" prefix="$">curl -sL https://deb.nodesource.com/setup_<span class="highlight">10</span>.x -o nodesource_setup.sh
</li></ul></code></pre>
<p>You can inspect the contents of this script with <code>nano</code> or your <a href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-debian-9#step-six-%E2%80%94-completing-optional-configuration">preferred text editor</a>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano nodesource_setup.sh
</li></ul></code></pre>
<p>When you're done inspecting the script, run it under <code>sudo</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo bash nodesource_setup.sh
</li></ul></code></pre>
<p>The PPA will be added to your configuration and your local package cache will be updated automatically. After running the setup script from Nodesource, you can install the Node.js package:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt install nodejs
</li></ul></code></pre>
<p>To check which version of Node.js you have installed after these initial steps, type:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nodejs -v
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>v<span class="highlight">10.16.0</span>
</code></pre>
<p><span class='note'><strong>Note:</strong> When installing from the NodeSource PPA, the Node.js executable is called <code>nodejs</code>, rather than <code>node</code>.<br></span></p>

<p>The <code>nodejs</code> package contains the <code>nodejs</code> binary as well as <a href="https://www.npmjs.com/"><code>npm</code></a>, a package manager for Node modules, so you don't need to install <code>npm</code> separately. </p>

<p><code>npm</code> uses a configuration file in your home directory to keep track of updates. It will be created the first time you run <code>npm</code>. Execute this command to verify that <code>npm</code> is installed and to create the configuration file:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">npm -v
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div><span class="highlight">6.9.0</span>
</code></pre>
<p>In order for some <code>npm</code> packages to work (those that require compiling code from source, for example), you will need to install the <code>build-essential</code> package:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt install build-essential
</li></ul></code></pre>
<p>You now have the necessary tools to work with <code>npm</code> packages that require compiling code from source.</p>

<p>With the Node.js runtime installed, we can move on to writing a Node.js application.</p>

<h2 id="step-2-—-creating-a-node-js-application">Step 2 — Creating a Node.js Application</h2>

<p>Let's write a <em>Hello World</em> application that returns "Hello World" to any HTTP requests. This sample application will help you get Node.js set up. You can replace it with your own application — just make sure that you modify your application to listen on the appropriate IP addresses and ports.</p>

<p>First, let's create a sample application called <code>hello.js</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd ~
</li><li class="line" prefix="$">nano hello.js
</li></ul></code></pre>
<p>Insert the following code into the file:</p>
<div class="code-label " title="~/hello.js">~/hello.js</div><pre class="code-pre "><code langs="">const http = require('http');

const hostname = 'localhost';
const port = 3000;

const server = http.createServer((req, res) =&gt; {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello World!\n');
});

server.listen(port, hostname, () =&gt; {
  console.log(`Server running at http://${hostname}:${port}/`);
});
</code></pre>
<p>Save the file and exit the editor.</p>

<p>This Node.js application listens on the specified address (<code>localhost</code>) and port (<code>3000</code>), and returns "Hello World!" with a <code>200</code> HTTP success code. Since we're listening on <code>localhost</code>, remote clients won't be able to connect to our application.</p>

<p>To test your application, type: </p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">node hello.js
</li></ul></code></pre>
<p>You will see the following output:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Server running at http://localhost:3000/
</code></pre>
<p><span class='note'><strong>Note:</strong> Running a Node.js application in this manner will block additional commands until you kill the application by pressing <code>CTRL+C</code>.<br></span></p>

<p>To test the application, open another terminal session on your server, and connect to <code>localhost</code> with <code>curl</code>:</p>
<pre class="code-pre command second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="$">curl http://localhost:<span class="highlight">3000</span>
</li></ul></code></pre>
<p>If you see the following output, the application is working properly and listening on the correct address and port:</p>
<pre class="code-pre  second-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>Hello World!
</code></pre>
<p>If you do not see the expected output, make sure that your Node.js application is running and configured to listen on the proper address and port.</p>

<p>Once you're sure it's working, kill the application (if you haven't already) by pressing <code>CTRL+C</code>.</p>

<h2 id="step-3-—-installing-pm2">Step 3 — Installing PM2</h2>

<p>Next let's install <a href="http://pm2.keymetrics.io/">PM2</a>, a process manager for Node.js applications. PM2 makes it possible to daemonize applications so that they will run in the background as a service.</p>

<p>Use <code>npm</code> to install the latest version of PM2 on your server: </p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo npm install pm2 -g
</li></ul></code></pre>
<p>The <code>-g</code> option tells <code>npm</code> to install the module globally, so it's available system-wide.</p>

<p>Let's first use the <code>pm2 start</code> command to run the <code>hello.js</code> application in the background:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">pm2 start <span class="highlight">hello.js</span>
</li></ul></code></pre>
<p>This also adds your application to PM2's process list, which is outputted every time you start an application:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>[PM2] Spawning PM2 daemon with pm2_home=/home/sammy/.pm2
[PM2] PM2 Successfully daemonized
[PM2] Starting /home/sammy/hello.js in fork_mode (1 instance)
[PM2] Done.
┌──────────┬────┬──────┬──────┬────────┬─────────┬────────┬─────┬───────────┬───────┬──────────┐
│ App name │ id │ mode │ pid  │ status │ restart │ uptime │ cpu │ mem       │ user  │ watching │
├──────────┼────┼──────┼──────┼────────┼─────────┼────────┼─────┼───────────┼───────┼──────────┤
│ <span class="highlight">hello</span>    │ 0  │ fork │ 1338 │ online │ 0       │ 0s     │ 0%  │ 23.0 MB   │ sammy │ disabled │
└──────────┴────┴──────┴──────┴────────┴─────────┴────────┴─────┴───────────┴───────┴──────────┘
 Use `pm2 show &lt;id|name&gt;` to get more details about an app
</code></pre>
<p>As you can see, PM2 automatically assigns an <code>App name</code> based on the filename without the <code>.js</code> extension, along with a PM2 <code>id</code>. PM2 also maintains other information, such as the <code>PID</code> of the process, its current status, and memory usage.</p>

<p>Applications that are running under PM2 will be restarted automatically if the application crashes or is killed, but we can take an additional step to get the application to launch on system startup using the <code>startup</code> subcommand. This subcommand generates and configures a startup script to launch PM2 and its managed processes on server boots. Type the following:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo pm2 startup
</li></ul></code></pre>
<p>You will see output that looks like this, describing the service configuration that PM2 has generated:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>[PM2] Init System found: systemd
Platform systemd
Template
[Unit]
Description=PM2 process manager
Documentation=https://pm2.keymetrics.io/
After=network.target

[Service]
Type=forking
User=root
LimitNOFILE=infinity
LimitNPROC=infinity
LimitCORE=infinity
Environment=PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin
Environment=PM2_HOME=/root/.pm2
PIDFile=/root/.pm2/pm2.pid
Restart=on-failure

ExecStart=/usr/lib/node_modules/pm2/bin/pm2 resurrect
ExecReload=/usr/lib/node_modules/pm2/bin/pm2 reload all
ExecStop=/usr/lib/node_modules/pm2/bin/pm2 kill

[Install]
WantedBy=multi-user.target

Target path
/etc/systemd/system/pm2-root.service
Command list
[ 'systemctl enable pm2-root' ]
[PM2] Writing init configuration in /etc/systemd/system/pm2-root.service
[PM2] Making script booting at startup...
[PM2] [-] Executing: systemctl enable pm2-root...
Created symlink /etc/systemd/system/multi-user.target.wants/pm2-root.service → /etc/systemd/system/pm2-root.service.
[PM2] [v] Command successfully executed.
+---------------------------------------+
[PM2] Freeze a process list on reboot via:
$ pm2 save

[PM2] Remove init script via:
$ pm2 unstartup systemd
</code></pre>
<p>You have now created a systemd <em>unit</em> that runs <code>pm2</code> on boot.  This <code>pm2</code> instance, in turn, runs <code>hello.js</code>.  </p>

<p>Start the service with <code>systemctl</code>: </p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl start pm2-root.service
</li></ul></code></pre>
<p>Check the status of the systemd unit:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">systemctl status pm2-root.service
</li></ul></code></pre>
<p>You should see output like the following:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>● pm2-root.service - PM2 process manager
   Loaded: loaded (/etc/systemd/system/pm2-root.service; enabled; vendor preset: enabled)
   Active: <span class="highlight">active (running)</span> since Fri 2019-07-12 16:09:54 UTC; 4s ago
</code></pre>
<p>For a detailed overview of systemd, see <a href="https://www.digitalocean.com/community/tutorials/systemd-essentials-working-with-services-units-and-the-journal">Systemd Essentials: Working with Services, Units, and the Journal</a>.</p>

<p>In addition to those we have covered, PM2 provides many subcommands that allow you to manage or look up information about your applications.</p>

<p>Stop an application with this command (specify the PM2 <code>App name</code> or <code>id</code>):</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">pm2 stop <span class="highlight">app_name_or_id</span>
</li></ul></code></pre>
<p>Restart an application:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">pm2 restart <span class="highlight">app_name_or_id</span>
</li></ul></code></pre>
<p>List the applications currently managed by PM2:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">pm2 list
</li></ul></code></pre>
<p>Get information about a specific application using its <code>App name</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">pm2 info <span class="highlight">app_name</span>
</li></ul></code></pre>
<p>The PM2 process monitor can be pulled up with the <code>monit</code> subcommand. This displays the application status, CPU, and memory usage:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">pm2 monit
</li></ul></code></pre>
<p>Note that running <code>pm2</code> without any arguments will also display a help page with example usage.</p>

<p>Now that your Node.js application is running and managed by PM2, let's set up the reverse proxy.</p>

<h2 id="step-4-—-setting-up-nginx-as-a-reverse-proxy-server">Step 4 — Setting Up Nginx as a Reverse Proxy Server</h2>

<p>Your application is running and listening on <code>localhost</code>, but you need to set up a way for your users to access it. We will set up the Nginx web server as a reverse proxy for this purpose.</p>

<p>In the prerequisite tutorial, you set up your Nginx configuration in the <code>/etc/nginx/sites-available/<span class="highlight">your_domain</span></code> file. Open this file for editing:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nano /etc/nginx/sites-available/<span class="highlight">your_domain</span>
</li></ul></code></pre>
<p>Within the <code>server</code> block, you should have an existing <code>location /</code> block. Replace the contents of that block with the following configuration. If your application is set to listen on a different port, update the highlighted portion to the correct port number:</p>
<div class="code-label " title="/etc/nginx/sites-available/your_domain">/etc/nginx/sites-available/your_domain</div><pre class="code-pre "><code langs="">server {
...
    location / {
        proxy_pass http://localhost:<span class="highlight">3000</span>;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
...
}
</code></pre>
<p>This configures the server to respond to requests at its root. Assuming our server is available at <code><span class="highlight">your_domain</span></code>, accessing <code>https://<span class="highlight">your_domain</span>/</code> via a web browser would send the request to <code>hello.js</code>, listening on port <code>3000</code> at <code>localhost</code>.</p>

<p>You can add additional <code>location</code> blocks to the same server block to provide access to other applications on the same server. For example, if you were also running another Node.js application on port <code>3001</code>, you could add this location block to allow access to it via <code>https://<span class="highlight">your_domain</span>/<span class="highlight">app2</span></code>:</p>
<div class="code-label " title="/etc/nginx/sites-available/your_domain — Optional">/etc/nginx/sites-available/your_domain — Optional</div><pre class="code-pre "><code langs="">server {
...
    location /<span class="highlight">app2</span> {
        proxy_pass http://localhost:<span class="highlight">3001</span>;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
...
}
</code></pre>
<p>Once you are done adding the location blocks for your applications, save the file and exit your editor.</p>

<p>Make sure you didn't introduce any syntax errors by typing:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nginx -t
</li></ul></code></pre>
<p>Restart Nginx:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl restart nginx
</li></ul></code></pre>
<p>Assuming that your Node.js application is running and your application and Nginx configurations are correct, you should now be able to access your application via the Nginx reverse proxy. Try it out by accessing your domain in the browser: <code>https://<span class="highlight">your_domain</span></code>. </p>

<h2 id="conclusion">Conclusion</h2>

<p>Congratulations! You now have your Node.js application running behind an Nginx reverse proxy on a Debian 10 server. This reverse proxy setup is flexible enough to provide your users access to other applications or static web content that you want to share. </p>

url: https://www.digitalocean.com/community/tutorials/how-to-set-up-a-node-js-application-for-production-on-debian-10
image: http://ifttt.com/images/no_image_card.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean