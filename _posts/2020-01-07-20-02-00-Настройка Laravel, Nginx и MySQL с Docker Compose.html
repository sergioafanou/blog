---
layout: post
title: Настройка Laravel, Nginx и MySQL с Docker Compose
network: digitalocean
date: January 07, 2020 at 08:02PM
url: https://www.digitalocean.com/community/tutorials/how-to-set-up-laravel-nginx-and-mysql-with-docker-compose-ru
image: https://assets.digitalocean.com/articles/laravel_docker/laravel_home.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<p><em>Автор выбрал <a href="https://www.brightfunds.org/organizations/the-freebsd-foundation">фонд FreeBSD Foundation</a> для получения пожертвования в рамках программы <a href="https://do.co/w4do-cta">Write for DOnations</a>.</em></p>

<h3 id="Введение">Введение</h3>

<p>В последние несколько лет <a href="https://docs.docker.com/">Docker</a> стали часто использовать для развертывания приложений, поскольку он упрощает запуск и развертывание приложений в виртуальных <a href="https://www.docker.com/resources/what-container">контейнерах</a>. При использовании набора приложений LEMP, например в <a href="https://php.net/docs.php">системе с PHP</a>, <a href="https://nginx.org/en/">Nginx</a>, <a href="https://dev.mysql.com/doc/">MySQL</a> и <a href="https://laravel.com/docs/5.6">Laravel</a>, Docker может значительно ускорить процедуру настройки.</p>

<p><a href="https://docs.docker.com/compose/">Docker Compose</a> упрощает процесс разработки, позволяя разработчикам определять свою инфраструктуру в одном файле, включая службы приложений, сети и томы. Docker Compose предлагает эффективную альтернативу запуску нескольких команд <code>docker container create</code> и <code>docker container run</code>.</p>

<p>В этом обучающем модуле вы создадите веб-приложение с помощью системы Laravel, используя Nginx в качестве веб-сервера и MySQL в качестве базы данных. Все это будет делаться в контейнерах Docker. Вы зададите полную конфигурацию приложения в файле <code>docker-compose</code> вместе с файлами конфигурации для PHP, MySQL и Nginx.</p>

<h2 id="Предварительные-требования">Предварительные требования</h2>

<p>Перед началом работы вам потребуется следующее:</p>

<ul>
<li>Один сервер Ubuntu 18.04 и пользователь без привилегий root с привилегиями <code>sudo</code>. Его настройка должна быть выполнена в соответствии с указаниями обучающего модуля <a href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04">Начальная настройка сервера Ubuntu 18.04</a>.</li>
<li>Система Docker, установленная в соответствии с шагами 1 и 2 руководства <a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-18-04">Установка и использование Docker в Ubuntu 18.04</a>.</li>
<li>Система Docker Compose, установленная в соответствии с шагом 1 обучающего модуля <a href="https://www.digitalocean.com/community/tutorials/how-to-install-docker-compose-on-ubuntu-18-04">Установка Docker Compose в Ubuntu 18.04</a>.</li>
</ul>

<h2 id="Шаг-1-—-Загрузка-laravel-и-установка-зависимостей">Шаг 1 — Загрузка Laravel и установка зависимостей</h2>

<p>На первом шаге мы загрузим последнюю версию Laravel и установим зависимости проекта, включая <a href="https://github.com/composer/docker">Composer</a>, диспетчер пакетов PHP на уровне приложения. Мы установим эти зависимости с помощью Docker, чтобы не выполнять глобальную установку Composer.</p>

<p>Перейдите в домашний каталог и клонируйте последнюю версию Laravel в каталог с именем <code><span class="highlight">laravel-app</span></code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd ~
</li><li class="line" prefix="$">git clone https://github.com/laravel/laravel.git <span class="highlight">laravel-app</span>
</li></ul></code></pre>
<p>Перейдите в каталог <code><span class="highlight">laravel-app</span></code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd ~/<span class="highlight">laravel-app</span>
</li></ul></code></pre>
<p>Затем смонтируйте <a href="https://hub.docker.com/r/library/composer/">образ <code>composer</code></a> из Docker в каталоги, которые нужны для вашего проекта Laravel, чтобы избежать издержек глобальной установки Composer:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker run --rm -v $(pwd):/app composer install
</li></ul></code></pre>
<p>Флаги <code>-v</code> и <code>--rm</code>  команды <code>docker run</code> создают виртуальный контейнер, который привязывается к текущему каталогу вплоть до его удаления. Содержимое вашего каталога <code>~/<span class="highlight">laravel-app</span></code> будет скопировано в контейнер, а содержимое создаваемой Composer внутри контейнера папки <code>vendor</code> будет скопировано в текущий каталог.</p>

<p>В заключение установите в каталоге проекта такой уровень разрешений, чтобы ее владельцем был пользователь без привилегий <strong>root</strong>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo chown -R $USER:$USER ~/laravel-app
</li></ul></code></pre>
<p>Это будет важно, когда вы будете записывать Dockerfile для образа вашего приложения на шаге 4, поскольку позволит работать с кодом прложения и запускать процессы в контейнере, не имея привилегий <strong>root</strong>.</p>

<p>Теперь вы разместили код приложения и можете переходить к определению служб с помощью Docker Compose.</p>

<h2 id="Шаг-2-—-Создание-файла-docker-compose">Шаг 2 — Создание файла Docker Compose</h2>

<p>Построение приложений с помощью Docker Compose упрощает процесс настройки и контроля версий в вашей инфраструктуре. Чтобы настроить наше приложение Laravel, мы создадим файл <code>docker-compose</code> с определением служб веб-сервера, базы данных и приложения.</p>

<p>Откройте файл:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano ~/laravel-app/docker-compose.yml
</li></ul></code></pre>
<p>В файле <code>docker-compose</code> определяются три службы: <code>app</code>, <code>webserver</code> и <code>db</code>. Добавьте в файл следующий код, при этом замените пароль <strong>root</strong> для <code>MYSQL_ROOT_PASSWORD</code>, определяемый как <a href="https://docs.docker.com/compose/compose-file/#environment">переменная среды</a> службы <code>db</code>, надежный паролем по своему выбору:</p>
<div class="code-label " title="~/laravel-app/docker-compose.yml">~/laravel-app/docker-compose.yml</div><pre class="code-pre yml"><code langs="">version: '3'
services:

  #PHP Service
  app:
    build:
      context: .
      dockerfile: Dockerfile
    image: digitalocean.com/php
    container_name: app
    restart: unless-stopped
    tty: true
    environment:
      SERVICE_NAME: app
      SERVICE_TAGS: dev
    working_dir: /var/www
    networks:
      - app-network

  #Nginx Service
  webserver:
    image: nginx:alpine
    container_name: webserver
    restart: unless-stopped
    tty: true
    ports:
      - "80:80"
      - "443:443"
    networks:
      - app-network

  #MySQL Service
  db:
    image: mysql:5.7.22
    container_name: db
    restart: unless-stopped
    tty: true
    ports:
      - "3306:3306"
    environment:
      MYSQL_DATABASE: <span class="highlight">laravel</span>
      MYSQL_ROOT_PASSWORD: <span class="highlight">your_mysql_root_password</span>
      SERVICE_TAGS: dev
      SERVICE_NAME: mysql
    networks:
      - app-network

#Docker Networks
networks:
  app-network:
    driver: bridge
</code></pre>
<p>Сюда включены следующие службы:</p>

<ul>
<li><code>app</code>: это определение службы содержит приложение Laravel и запускает персонализированный образ Docker, <code>digitalocean.com/php</code>, который вы определите на шаге 4. Также оно устанавливает для параметра <code>working_dir</code> в контейнере значение <code>/var/www</code>.</li>
<li><code>webserver</code>: это определение службы берет <a href="https://hub.docker.com/_/nginx/">образ <code>nginx:alpine</code></a> из Docker и открывает порты <code>80</code> и <code>443</code>.</li>
<li><code>db</code>: это определение службы извлекает <a href="https://hub.docker.com/_/mysql/">образ <code>mysql:5.7.22</code></a> из Docker и определяет новые переменные среды, в том числе базу данных <code><span class="highlight">laravel</span></code> для вашего приложения и пароль пользователя <strong>root</strong> для базы данных. Вы можете использовать любое имя базы данных, которое захотите, также вам следует заменить <code><span class="highlight">your_mysql_root_password</span></code> собственным надежным паролем. Это определение службы также сопоставляет порт хоста <code>3306</code> и порт контейнера <code>3306</code>.</li>
</ul>

<p>Каждое свойство <code>container_name</code> определяет имя контейнера, соответствующее имени службы. Если вы не определите это свойство, Docker будет присваивать каждому контейнеру имена, состоящие из имени исторической личности и случайного слова, разделенных символом подчеркивания.</p>

<p>Для упрощения взаимодействия между контейнерами службы подключаются к соединительной сети с именем <code>app-network</code>. Соединительная сеть использует программный мост, позволяющий подключенным к этой сети контейнерам взаимодействовать друг с другом. Драйвер моста автоматически устанавливает правила хоста, чтобы контейнеры в разных соединительных сетях не могли напрямую взаимодействовать друг с другом. Это повышает уровень безопасности приложений, поскольку друг с другом могут взаимодействовать только связанные службы. Также это означает, что вы сможете задавать разные сети и службы, подключающиеся к связанным функциям: например, клиентские службы приложения могут использовать сеть <code>frontend</code>, а серверные — сеть <code>backend</code>.</p>

<p>Теперь посмотрим, как добавлять тома и привязывать смонтированные образы к определениям служб для постоянного сохранения данных приложения.</p>

<h2 id="Шаг-3-—-Постоянное-сохранение-данных">Шаг 3 — Постоянное сохранение данных</h2>

<p>В Docker имеются мощные и удобные средства для постоянного сохранения данных. В нашем приложении мы будем использовать <a href="https://docs.docker.com/storage/volumes/"><em>тома</em></a> и <a href="https://docs.docker.com/storage/bind-mounts/"><em>монтируемые образы</em></a> для постоянного сохранения файлов базы данных, приложения и конфигурации. Тома обеспечивают гибкость резервного копирования и сохранение по прекращении жизненного цикла контейнера, а привязываемые монтируемые образы упрощают изменение кода во время разработки с немедленным отражением изменений файлов или каталогов хоста в контейнерах. Мы используем оба варианта.</p>

<p><span class='warning'><strong>Предупреждение!</strong> Использование привязываемых монтируемых образов позволяет изменять файловую систему хоста через работающие в контейнеры процессы, что включает создание, изменение или удаление важных системных файлов или каталогов. Это мощная возможность с функциями безопасности, которая может повлиять на процессы без Docker в системе хоста. Привязывемые монтируемые образы следует использовать с осторожностью.<br></span></p>

<p>Определите в файле <code>docker-compose</code> том с именем <code>dbdata</code> в определении службы <code>db</code> для постоянного сохранения базы данных MySQL:</p>
<div class="code-label " title="~/laravel-app/docker-compose.yml">~/laravel-app/docker-compose.yml</div><pre class="code-pre docker"><code langs="">...
#MySQL Service
db:
  ...
    <span class="highlight">volumes:</span>
      <span class="highlight">- dbdata:/var/lib/mysql</span>
    networks:
      - app-network
  ...
</code></pre>
<p>Том с именем <code>dbdata</code> используется для постоянного сохранения содержимого папки <code>/var/lib/mysql</code> внутри контейнера. Это позволяет останавливать и перезапускать службу <code>db</code> без потери данных.</p>

<p>Добавьте в конце файла определение тома <code>dbdata</code>:</p>
<div class="code-label " title="~/laravel-app/docker-compose.yml">~/laravel-app/docker-compose.yml</div><pre class="code-pre docker"><code langs="">...
#Volumes
volumes:
  dbdata:
    driver: local
</code></pre>
<p>С этим определением вы сможете использовать этот том для разных служб.</p>

<p>Затем добавьте привязку монтируемого образа к службе <code>db</code> для файлов конфигурации MySQL, которые вы создадите на шаге 7:</p>
<div class="code-label " title="~/laravel-app/docker-compose.yml">~/laravel-app/docker-compose.yml</div><pre class="code-pre docker"><code langs="">...
#MySQL Service
db:
  ...
    volumes:
      - dbdata:/var/lib/mysql
      <span class="highlight">- ./mysql/my.cnf:/etc/mysql/my.cnf</span>
  ...
</code></pre>
<p>Этот монтируемый образ привязывает файл <code>~/laravel-app/mysql/my.cnf</code> к каталогу <code>/etc/mysql/my.cnf</code> в контейнере.</p>

<p>Затем добавьте монтируемые образы в службу <code>веб-сервера</code>. Их будет два: один для кода приложения, а другой — для определения конфигурации Nginx, которое вы создадите на шаге 6:</p>
<div class="code-label " title="~/laravel-app/docker-compose.yml">~/laravel-app/docker-compose.yml</div><pre class="code-pre docker"><code langs="">#Nginx Service
webserver:
  ...
  <span class="highlight">volumes:</span>
      <span class="highlight">- ./:/var/www</span>
      <span class="highlight">- ./nginx/conf.d/:/etc/nginx/conf.d/</span>
  networks:
      - app-network
</code></pre>
<p>Первый монтируемый образ привязывает код приложения в каталоге <code>~/laravel-app</code> к каталогу <code>/var/www</code> внутри контейнера. Файл конфигурации, добавляемые в <code>~/laravel-app/nginx/conf.d/</code>, также монтируется в <code>/etc/nginx/conf.d/</code> в контейнере, что позвоялет добавлять и изменять содержимое каталога конфигурации по мере необходимости.</p>

<p>В заключение добавьте следующие привязки монтируемых образов в службу <code>app</code> для кода приложения и файлов конфигурации:</p>
<div class="code-label " title="~/laravel-app/docker-compose.yml">~/laravel-app/docker-compose.yml</div><pre class="code-pre docker"><code langs="">#PHP Service
app:
  ...
  <span class="highlight">volumes:</span>
       <span class="highlight">- ./:/var/www</span>
       <span class="highlight">- ./php/local.ini:/usr/local/etc/php/conf.d/local.ini</span>
  networks:
      - app-network
</code></pre>
<p>Служба <code>app</code> привязывает монтируемый образ папки <code>~/laravel-app</code>, который содержит код приложения, к папке <code>/var/www</code>. Это ускорит процесс разработки, поскольку любые изменения в локальном каталоге приложения будут немедленно отражаться в контейнере. Также вы привязываете файл конфигурации PHP  <code>~/laravel-app/php/local.ini</code> к файлу <code>/usr/local/etc/php/conf.d/local.ini</code> в контейнере. На шаге 5 вы создадите локальный файл конфигурации PHP.</p>

<p>Теперь ваш файл <code>docker-compose</code> будет выглядеть следующим образом:</p>
<div class="code-label " title="~/laravel-app/docker-compose.yml">~/laravel-app/docker-compose.yml</div><pre class="code-pre yml"><code langs="">version: '3'
services:

  #PHP Service
  app:
    build:
      context: .
      dockerfile: Dockerfile
    image: digitalocean.com/php
    container_name: app
    restart: unless-stopped
    tty: true
    environment:
      SERVICE_NAME: app
      SERVICE_TAGS: dev
    working_dir: /var/www
    volumes:
      - ./:/var/www
      - ./php/local.ini:/usr/local/etc/php/conf.d/local.ini
    networks:
      - app-network

  #Nginx Service
  webserver:
    image: nginx:alpine
    container_name: webserver
    restart: unless-stopped
    tty: true
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./:/var/www
      - ./nginx/conf.d/:/etc/nginx/conf.d/
    networks:
      - app-network

  #MySQL Service
  db:
    image: mysql:5.7.22
    container_name: db
    restart: unless-stopped
    tty: true
    ports:
      - "3306:3306"
    environment:
      MYSQL_DATABASE: <span class="highlight">laravel</span>
      MYSQL_ROOT_PASSWORD: <span class="highlight">your_mysql_root_password</span>
      SERVICE_TAGS: dev
      SERVICE_NAME: mysql
    volumes:
      - dbdata:/var/lib/mysql/
      - ./mysql/my.cnf:/etc/mysql/my.cnf
    networks:
      - app-network

#Docker Networks
networks:
  app-network:
    driver: bridge
#Volumes
volumes:
  dbdata:
    driver: local
</code></pre>
<p>Когда закончите вносить изменения, сохраните файл и закройте редактор.</p>

<p>Записав файл <code>docker-compose</code>, вы сможете создать персонализированный образ вашего приложения.</p>

<h2 id="Шаг-4-—-Создание-файла-dockerfile">Шаг 4 — Создание файла Dockerfile</h2>

<p>Docker позволяет задавать среду внутри отдельных контейнеров с помощью файла <em>Dockerfile</em>. Файл Dockerfile позволяет создавать персонализированные образы. которые можно использовать для установки требуемого программного обеспечения приложения и изменения настроек в соответствии с требованиями. Вы можете передавать созданные образы в <a href="https://hub.docker.com/">Docker Hub</a> или любой частный реестр.</p>

<p>Файл <code>Dockerfile</code> будет располагаться в каталоге <code>~/laravel-app</code>. Создайте файл:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano ~/laravel-app/Dockerfile
</li></ul></code></pre>
<p>Этот файл <code>Dockerfile</code> будет задавать базовый образ и необходимые команды и инструкции для построения образа приложения Laravel. Добавьте в файл следующий код:</p>
<div class="code-label " title="~/laravel-app/php/Dockerfile">~/laravel-app/php/Dockerfile</div><pre class="code-pre docker"><code langs="">FROM php:7.2-fpm

# Copy composer.lock and composer.json
COPY composer.lock composer.json /var/www/

# Set working directory
WORKDIR /var/www

# Install dependencies
RUN apt-get update &amp;&amp; apt-get install -y \
    build-essential \
    mysql-client \
    libpng-dev \
    libjpeg62-turbo-dev \
    libfreetype6-dev \
    locales \
    zip \
    jpegoptim optipng pngquant gifsicle \
    vim \
    unzip \
    git \
    curl

# Clear cache
RUN apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/*

# Install extensions
RUN docker-php-ext-install pdo_mysql mbstring zip exif pcntl
RUN docker-php-ext-configure gd --with-gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ --with-png-dir=/usr/include/
RUN docker-php-ext-install gd

# Install composer
RUN curl -sS https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer

# Add user for laravel application
RUN groupadd -g 1000 www
RUN useradd -u 1000 -ms /bin/bash -g www www

# Copy existing application directory contents
COPY . /var/www

# Copy existing application directory permissions
COPY --chown=www:www . /var/www

# Change current user to www
USER www

# Expose port 9000 and start php-fpm server
EXPOSE 9000
CMD ["php-fpm"]
</code></pre>
<p>Сначала Dockerfile создает образ поверх <a href="https://hub.docker.com/_/php/">образа <code>php:7.2-fpm</code> Docker</a>. Это образ на базе с установленным экземпляром PHP FastCGI <a href="https://php-fpm.org/">PHP-FPM</a>. Также этот файл устанавливает требуемые пакеты для Laravel: <code>mcrypt</code>, <code>pdo_mysql</code>, <code>mbstring</code> и <code>imagick</code> с <code>composer</code>.</p>

<p>Директива <code>RUN</code> задает команды для обновления, установки и настройки параметров внутри контейнера, включая выделенного пользователя и группу с именем <strong>www</strong>. Инструкция <code>WORKDIR</code> задает каталог <code>/var/www</code> как рабочий каталог приложения.</p>

<p>Создание отдельного пользователя и группы с ограниченными правами доступа снижает уязвимость при запуске контейнеров Docker, которые по умолчанию запускаются с привилегиями <strong>root</strong>. Вместо запуска этого контейнера с <strong>привилегиями root</strong> мы создали пользователя <strong>www</strong> с правами чтения и записи для папки <code>/var/www</code> с помощью команды <code>COPY</code> с флагом <code>--chown</code> для копирования разрешений папки приложения.</p>

<p>Команда <code>EXPOSE</code> открывает порт <code>9000</code> в контейнере для сервера <code>php-fpm</code>. <code>CMD</code> указывает команду, которая должна запускаться после создания контейнера. Здесь <code>CMD</code> указывает команду <code>php-fpm</code>, которая запускает сервер.</p>

<p>Когда закончите вносить изменения, сохраните файл и закройте редактор.</p>

<p>Теперь вы можете перейти к определению конфигурации PHP.</p>

<h2 id="Шаг-5-—-Настройка-php">Шаг 5 — Настройка PHP</h2>

<p>Вы определили инфраструктуру в файле <code>docker-compose</code>, и теперь можете настроить службу PHP для работы в качестве процессора PHP для входящих запросов Nginx.</p>

<p>Для настройки PHP вы создадите файл <code>local.ini</code> в папке <code>php</code>. Это файл, который вы привязали к файлу <code>/usr/local/etc/php/conf.d/local.ini</code> в контейнере на шаге 2. Создание этого файла позволит вам игнорировать файл по умолчанию <code>php.ini</code>, который PHP считывает при запуске.</p>

<p>Создайте каталог <code>php</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir ~/laravel-app/php
</li></ul></code></pre>
<p>Затем откройте файл <code>local.ini</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano ~/laravel-app/php/local.ini
</li></ul></code></pre>
<p>Чтобы продемонстрировать настройку PHP, мы добавим следующий код для установки ограничений размера выгруженных файлов:</p>
<div class="code-label " title="~/laravel-app/php/local.ini">~/laravel-app/php/local.ini</div><pre class="code-pre "><code class="code-highlight language-ini">upload_max_filesize=40M
post_max_size=40M
</code></pre>
<p>Директивы <code>upload_max_filesize</code> и <code>post_max_size</code> задают максимальный разрешенный размер выгружаемых файлов и показывают, как задавать конфигурации <code>php.ini</code> из файла <code>local.ini</code>. Вы можете вставить любой параметр конфигурации PHP, который хотите игнорировать в файле <code>local.ini</code>.</p>

<p>Сохраните файл и закройте редактор.</p>

<p>С сохраненным файлом PHP <code>local.ini</code> можно перейти к настройке Nginx.</p>

<h2 id="Шаг-6-—-Настройка-nginx">Шаг 6 — Настройка Nginx</h2>

<p>При настройке службы PHP вы можете изменять службу Nginx для использования PHP-FPM как сервера FastCGI для обслуживания динамического контента. Сервер FastCGI основан на двоичном протоколе для взаимодействия интерактивных программ с веб-сервером. Дополнительную информацию можно найти в статье <a href="https://www.digitalocean.com/community/tutorials/understanding-and-implementing-fastcgi-proxying-in-nginx">«Понимание и реализация прокси FastCGI в Nginx»</a>.</p>

<p>Для настройки Nginx вы создадите файл <code>app.conf</code> с конфигурацией служб в папке <code>~/laravel-app/nginx/conf.d/</code>.</p>

<p>Вначале создайте каталог <code>nginx/conf.d/</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir -p ~/laravel-app/nginx/conf.d
</li></ul></code></pre>
<p>Затем создайте файл конфигурации <code>app.conf</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano ~/laravel-app/nginx/conf.d/app.conf
</li></ul></code></pre>
<p>Добавьте в файл следующий код, чтобы задать конфигурацию Nginx:</p>
<div class="code-label " title="~/laravel-app/nginx/conf.d/app.conf">~/laravel-app/nginx/conf.d/app.conf</div><pre class="code-pre "><code class="code-highlight language-nginx">server {
    listen 80;
    index index.php index.html;
    error_log  /var/log/nginx/error.log;
    access_log /var/log/nginx/access.log;
    root /var/www/public;
    location ~ \.php$ {
        try_files $uri =404;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass app:9000;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param PATH_INFO $fastcgi_path_info;
    }
    location / {
        try_files $uri $uri/ /index.php?$query_string;
        gzip_static on;
    }
}
</code></pre>
<p><a href="https://www.digitalocean.com/community/tutorials/understanding-nginx-server-and-location-block-selection-algorithms">Серверный блок</a> задает конфигурацию веб-сервера Nginx с помощью следующих директив:</p>

<ul>
<li><code>listen</code>: эта директива определяет порт, который сервер прослушивает для получения входящих запросов.</li>
<li><code>error_log</code> и <code>access_log</code>: эти директивы определяют файлы для записи журналов.</li>
<li><code>root</code>: эта директива задает путь к корневой папке, формируя полный путь для любого запрошенного файла в локальной файловой системе.</li>
</ul>

<p>В блоке расположения <code>php</code> директива <code>fastcgi_pass</code> указывает, что служба <code>app</code> прослушивает сокет TCP на порту <code>9000</code>. С ней сервер PHP-FPM выполняет прослушивание через сеть, а не через сокет Unix. Хотя сокет Unix дает небольшое преимущество в скорости по сравнению с сокетом TCP, у него нет сетевого протокола и он пропускает сетевой стек. В случаях расположения хостов в одной системе использование сокета Unix может иметь смысл, но если службы работают на разных хостах, сокет TCP дает преимущество, позволяя подключаться к распределенным службам. Поскольку наши контейнеры <code>app</code> и <code>webserver</code> работают на разных хостах, в нашей конфигурации эффективнее использовать сокет TCP.</p>

<p>Когда закончите вносить изменения, сохраните файл и закройте редактор.</p>

<p>Благодаря привязке, созданной на шаге 2, любые изменения в папке <code>nginx/conf.d/</code> прямо отражаются в контейнере <code>webserver</code>.</p>

<p>Теперь посмотрим на параметры MySQL.</p>

<h2 id="Шаг-7-—-Настройка-mysql">Шаг 7 — Настройка MySQL</h2>

<p>После настройки PHP и Nginx вы можете активировать MySQL как базу данных для вашего приложения.</p>

<p>Для настройки MySQL нужно создать файл <code>my.cnf</code> в папке <code>mysql</code>. Это файл, который вы привязали к файлу <code>/etc/mysql/my.cnf</code> внутри контейнера на шаге 2. Привязка монтируемого образа позволяет игнорировать любые параметры <code>my.cnf</code>, если и когда это требуется.</p>

<p>Чтобы продемонстрировать, как это работает, мы добавим в файл <code>my.cnf</code> настройки, которые включают журнал общих запросов и задают файл журнала.</p>

<p>Создайте каталог <code>mysql</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir ~/laravel-app/mysql
</li></ul></code></pre>
<p>Создайте файл <code>my.cnf</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano ~/laravel-app/mysql/my.cnf
</li></ul></code></pre>
<p>Добавьте в файл следующий код, чтобы активировать журнал запросов и задать местоположение файла журнала:</p>
<div class="code-label " title="~/laravel-app/mysql/my.cnf">~/laravel-app/mysql/my.cnf</div><pre class="code-pre "><code class="code-highlight language-ini">[mysqld]
general_log = 1
general_log_file = /var/lib/mysql/general.log
</code></pre>
<p>Файл <code>my.cnf</code> поддерживает журналы, задавая для параметра <code>general_log</code> значение <code>1</code>, разрешающее общие журналы. Параметр <code>general_log_file</code> указывает, где будут храниться журналы.</p>

<p>Сохраните файл и закройте редактор.</p>

<p>На следующем шаге мы запустим контейнеры.</p>

<h2 id="Шаг-8-—-Запуск-контейнеров-и-изменение-параметров-среды">Шаг 8 — Запуск контейнеров и изменение параметров среды</h2>

<p>Вы определили все службы в файле <code>docker-compose</code> и создали файлы конфигурации для этих служб. Теперь вы можете запускать контейнеры. В заключение мы создадим копию файла <code>.env.example</code>, которую Laravel включает по умолчанию, и назовем ее <code>.env</code>, поскольку Laravel использует такой файл для определения среды:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cp .env.example .env
</li></ul></code></pre>
<p>После запуска контейнеров мы настроим в этом файле конкретные параметры установки.</p>

<p>Теперь все ваши службы определены в файле <code>docker-compose</code>, и вам просто нужно запустить одну команду для запуска всех контейнеров, создания томов и настройки и подключения сетей:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose up -d
</li></ul></code></pre>
<p>При первом запуске <code>docker-compose up</code> будут загружены все необходимые образы Docker, что может занять некоторое время. После загрузки образов и их сохранения на локальном компьютере Compose создаст ваши контейнеры. Флаг <code>-d</code> преобразует процесс в демона, с которым контейнеры остаются запущенными в фоновом режиме.</p>

<p>После завершения процесса используйте следующую команду для вывода списка всех запущенных контейнеров:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker ps
</li></ul></code></pre>
<p>Вы увидите следующие результаты с данными о контейнерах <code>app</code>, <code>webserver</code> и <code>db</code>:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>CONTAINER ID        NAMES               IMAGE                             STATUS              PORTS
c31b7b3251e0        db                  mysql:5.7.22                      Up 2 seconds        0.0.0.0:3306-&gt;3306/tcp
ed5a69704580        app                 digitalocean.com/php              Up 2 seconds        9000/tcp
5ce4ee31d7c0        webserver           nginx:alpine                      Up 2 seconds        0.0.0.0:80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp
</code></pre>
<p>В этих результатах <code>CONTAINER ID</code> — это уникальный идентификатор каждого контейнера, а <code>NAMES</code> перечисляет имена служб для каждого контейнера. Вы можете использовать для доступа к контейнерам оба эти идентификатора. <code>IMAGE</code> определяет имя образа каждого контейнера, а <code>STATUS</code> предосавляет информацию о состоянии контейнера: запущен, перезапускается или остановлен.</p>

<p>Теперь вы можете изменить файл <code>.env</code> в контейнере <code>app</code>, чтобы добавить определенные параметры вашей системы.</p>

<p>Откройте файл с помощью <code>docker-compose exec</code>, позволяющего запускать определенные команды в контейнерах. В этом случае вы открываете файл для редактирования:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose exec <span class="highlight">app</span> nano .env
</li></ul></code></pre>
<p>Найдите блок, задающий <code>DB_CONNECTION</code> и обновите его для отражения особенностей настройки вашей системы. Вы измените следующие поля:</p>

<ul>
<li><code>DB_HOST</code> будет вашим контейнером базы данных <code>db</code>.</li>
<li><code>DB_DATABASE</code> будет базой данных <code><span class="highlight">laravel</span></code>.</li>
<li><code>DB_USERNAME</code> будет именем пользователя для вашей базы данных. В этом случае мы будем использовать <code><span class="highlight">laraveluser</span></code>.</li>
<li><code>DB_PASSWORD</code> будет защищенным паролем для этой учетной записи пользователя.</li>
</ul>
<div class="code-label " title="/var/www/.env">/var/www/.env</div><pre class="code-pre "><code langs="">DB_CONNECTION=mysql
DB_HOST=<span class="highlight">db</span>
DB_PORT=3306
DB_DATABASE=<span class="highlight">laravel</span>
DB_USERNAME=<span class="highlight">laraveluser</span>
DB_PASSWORD=<span class="highlight">your_laravel_db_password</span>
</code></pre>
<p>Сохраните изменения и закройте редактор.</p>

<p>Затем настройте ключ приложения для приложения Laravel с помощью команды <code>php artisan key:generate</code>. Эта команда сгенерирует ключ и скопирует его в файл <code>.env</code>, что обеспечит защиту сеансов пользователя и шифрованных данных:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose exec <span class="highlight">app</span> php artisan key:generate
</li></ul></code></pre>
<p>Теперь у вас есть все необходимые настройки среды для запуска приложения. Чтобы кэшировать эти настройки в файле, ускоряющем загрузку приложения, запустите команду:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose exec <span class="highlight">app</span> php artisan config:cache
</li></ul></code></pre>
<p>Настройки конфигурации будут загружены в файл <code>/var/www/bootstrap/cache/config.php</code> в контейнере.</p>

<p>В заключение откройте в браузере сайт <code>http://<span class="highlight">your_server_ip</span></code>. Откроется главная страница приложения Laravel:</p>

<p><img src="https://assets.digitalocean.com/articles/laravel_docker/laravel_home.png" alt="Главная страница Laravel"></p>

<p>Когда контейнеры будут работать, и данные конфигурации будут размещены на месте, вы сможете перейти к настройке данных пользователя базы данных <code><span class="highlight">laravel</span></code> в контейнере <code>db</code>.</p>

<h2 id="Шаг-9-—-Создание-пользователя-mysql">Шаг 9 — Создание пользователя MySQL</h2>

<p>При установке MySQL по умолчанию создается только административная учетная запись <strong>root</strong> с неограниченными привилегиями доступа к серверу баз данных. Обычно при работе с базой данных лучше избегать использования административной учетной записи <strong>root</strong>. Вместо этого мы создадим специального пользователя базы данных для базы данных Laravel нашего приложения.</p>

<p>Чтобы создать нового пользователя, запустите интерактивную оболочку bash в контейнере <code>db</code> с помощью команды <code>docker-compose exec</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose exec <span class="highlight">db</span> bash
</li></ul></code></pre>
<p>Выполните внутри контейнера вход в административную учетную запись MySQL <strong>root</strong>:</p>
<pre class="code-pre custom_prefix second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="root@c31b7b3251e0:/#">mysql -u root -p
</li></ul></code></pre>
<p>Вам будет предложено ввести пароль, заданный для <strong>учетной записи MySQL root</strong> при установке в файл <code>docker-compose.</code></p>

<p>Для начала проверьте наличие базы данных <code><span class="highlight">laravel</span></code>, определенной в файле <code>docker-compose</code>. Запустите команду <code>show</code> databases для проверки существующих баз данных:</p>
<pre class="code-pre custom_prefix second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="mysql&gt;">show databases;
</li></ul></code></pre>
<p>В результатах вы должны увидеть базу данных <code><span class="highlight">laravel</span></code>:</p>
<pre class="code-pre  second-environment"><code langs=""><div class="secondary-code-label " title="Output">Output</div>+--------------------+
| Database           |
+--------------------+
| information_schema |
| <span class="highlight">laravel</span>            |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
5 rows in set (0.00 sec)
</code></pre>
<p>Затем создайте учетную запись пользователя, которой будет разрешен доступ к этой базе данных. Мы используем имя пользователя <code><span class="highlight">laraveluser</span></code>, но вы можете заменить его любым предпочитаемым именем. Просто убедитесь, что имя пользователя и пароль соответствуют заданным в файле <code>.env</code> на предыдущем шаге:</p>
<pre class="code-pre custom_prefix second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="mysql&gt;">GRANT ALL ON laravel.* TO '<span class="highlight">laraveluser</span>'@'%' IDENTIFIED BY '<span class="highlight">your_laravel_db_password</span>';
</li></ul></code></pre>
<p>Обновите привилегии, чтобы уведомить сервер MySQL об изменениях:</p>
<pre class="code-pre custom_prefix second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="mysql&gt;">FLUSH PRIVILEGES;
</li></ul></code></pre>
<p>Закройте MySQL:</p>
<pre class="code-pre custom_prefix second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="mysql&gt;">EXIT;
</li></ul></code></pre>
<p>Выйдите из контейнера:</p>
<pre class="code-pre custom_prefix second-environment"><code langs=""><ul class="prefixed"><li class="line" prefix="root@c31b7b3251e0:/#">exit
</li></ul></code></pre>
<p>Вы настроили учетную запись пользователя для базы данных вашего приложения Laravel и готовы к миграции данных и работе с консолью Tinker.</p>

<h2 id="Шаг-10-—-Миграция-данных-и-работа-с-консолью-tinker">Шаг 10 — Миграция данных и работа с консолью Tinker</h2>

<p>Теперь ваше приложение запущено, и вы можете провести миграцию данных и поэкспериментировать с командой <code>tinker,</code> которая запускает консоль <a href="http://psysh.org/"><em>PsySH</em></a> с предварительно загруженным приложением Laravel. PsySH — это консоль времени исполнения для разработчика и интерактивный отладчик для PHP, а Tinker — это REPL для Laravel. Команда <code>tinker</code> позволяет взаимодействовать с приложением Laravel из командной строки в интерактивной оболочке.</p>

<p>Сначала протестируйте соединение с MySQL с помощью команды Laravel <code>artisan migrate,</code> которая создает в базе данных таблицу <code>migrations</code> изнутри контейнера:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose exec <span class="highlight">app</span> php artisan migrate
</li></ul></code></pre>
<p>Эта команда выполняет миграцию таблиц Laravel по умолчанию. Результаты подтверждения миграции выглядят следующим образом:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>
Migration table created successfully.
Migrating: 2014_10_12_000000_create_users_table
Migrated:  2014_10_12_000000_create_users_table
Migrating: 2014_10_12_100000_create_password_resets_table
Migrated:  2014_10_12_100000_create_password_resets_table
</code></pre>
<p>После завершения миграции вы можете отправить запрос для проверки правильности подключения к базе данных с помощью команды <code>tinker</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker-compose exec <span class="highlight">app</span> php artisan tinker
</li></ul></code></pre>
<p>Проверьте соединение MySQL, получив данные, миграцию которых вы только что произвели:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="&gt;&gt;&gt;">\DB::table('migrations')-&gt;get();
</li></ul></code></pre>
<p>Вы получите следующий результат:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>=&gt; Illuminate\Support\Collection {#2856
     all: [
       {#2862
         +"id": 1,
         +"migration": "2014_10_12_000000_create_users_table",
         +"batch": 1,
       },
       {#2865
         +"id": 2,
         +"migration": "2014_10_12_100000_create_password_resets_table",
         +"batch": 1,
       },
     ],
   }
</code></pre>
<p>Вы можете использовать <code>tinker</code> для взаимодействия с базами данных и экспериментов со службами и моделями.</p>

<p>Теперь ваше приложение Laravel завершено и вы готовы к дальнейшей разработке и экспериментам.</p>

<h2 id="Заключение">Заключение</h2>

<p>Теперь на вашем сервере работает приложение набора LEMP, которое вы протестировали, получив доступ к начальной странице Laravel и создав миграцию базы данных MySQL.</p>

<p>Главный фактор для простоты установки — Docker Compose, позволяющий создавать группу контейнеров Docker, определенную в одном файле, с помощью одной команды. Если вы хотите узнать больше о постоянной интеграции с Docker Compose, ознакомьтесь с обучающим модулем <a href="https://www.digitalocean.com/community/tutorials/how-to-configure-a-continuous-integration-testing-environment-with-docker-and-docker-compose-on-ubuntu-16-04">«Настройка среды постоянного тестирования интеграции с Docker и Docker Compose в Ubuntu 16.04»</a>. Если вы хотите ускорить процесс развертывания вашего приложения Laravel, вам поможет ресурс <a href="https://www.digitalocean.com/community/tutorials/automatically-deploy-laravel-applications-deployer-ubuntu">«Автоматическое развертывание приложений Laravel с помощью Deployer в Ubuntu 16.04»</a>.</p>
