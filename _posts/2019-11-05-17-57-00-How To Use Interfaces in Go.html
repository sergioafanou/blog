---
layout: post
title: How To Use Interfaces in Go
network: digitalocean
date: November 05, 2019 at 05:57PM
url: https://www.digitalocean.com/community/tutorials/how-to-use-interfaces-in-go
image: http://ifttt.com/images/no_image_card.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="introduction">Introduction</h3>

<p>Writing flexible, reusable, and modular code is vital for developing versatile programs. Working in this way ensures code is easier to maintain by avoiding the need to make the same change in multiple places. How you accomplish this varies from language to language. For instance, <a href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)"><em>inheritance</em></a> is a common approach that is used in languages such as Java, C++, C#, and more.</p>

<p>Developers can also attain those same design goals through <a href="https://en.wikipedia.org/wiki/Object_composition"><em>composition</em></a>. Composition is a way to combine objects or data types into more complex ones. This is the approach that Go uses to promote code reuse, modularity, and flexibility. Interfaces in Go provide a method of organizing complex compositions, and learning how to use them will allow you to create common, reusable code.</p>

<p>In this article, we will learn how to compose custom types that have common behaviors, which will allow us to reuse our code. We&rsquo;ll also learn how to implement interfaces for our own custom types that will satisfy interfaces defined from another package.</p>

<h2 id="defining-a-behavior">Defining a Behavior</h2>

<p>One of the core implementations of composition is the use of interfaces. An interface defines a behavior of a type. One of the most commonly used interfaces in the Go standard library is the <a href="https://golang.org/pkg/fmt/#Stringer"><code>fmt.Stringer</code></a> interface:</p>
<pre class="code-pre "><code class="code-highlight language-go">type Stringer interface {
    String() string
}
</code></pre>
<p>The first line of code defines a <code>type</code> called <code>Stringer</code>. It then states that it is an <code>interface</code>. Just like defining a struct, Go uses curly braces (<code>{}</code>) to surround the definition of the interface. In comparison to defining structs, we only define the interface&rsquo;s <em>behavior</em>; that is, &ldquo;what can this type do&rdquo;.</p>

<p>In the case of the <code>Stringer</code> interface, the only behavior is the <code>String()</code> method. The method takes no arguments and returns a string.</p>

<p>Next, let&rsquo;s look at some code that has the <code>fmt.Stringer</code> behavior:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import "fmt"

type Article struct {
    Title string
    Author string
}

func (a Article) String() string {
    return fmt.Sprintf("The %q article was written by %s.", a.Title, a.Author)
}

func main() {
    a := Article{
        Title: "Understanding Interfaces in Go",
        Author: "Sammy Shark",
    }
    fmt.Println(a.String())
}
</code></pre>
<p>The first thing we do is create a new type called <code>Article</code>. This type has a <code>Title</code> and an <code>Author</code> field and both are of the string <a href="https://www.digitalocean.com/community/tutorials/understanding-data-types-in-go">data type</a>:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">...
type Article struct {
    Title string
    Author string
}
...
</code></pre>
<p>Next, we define a <a href="https://www.digitalocean.com/community/tutorials/defining-methods-in-go"><code>method</code></a> called <code>String</code> on the <code>Article</code> type. The <code>String</code> method will return a string that represents the <code>Article</code> type:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">...
func (a Article) String() string {
    return fmt.Sprintf("The %q article was written by %s.", a.Title, a.Author)
}
...
</code></pre>
<p>Then, in our <code>main</code> <a href="https://www.digitalocean.com/community/tutorials/how-to-define-and-call-functions-in-go">function</a>, we create an instance of the <code>Article</code> type and assign it to the <a href="https://www.digitalocean.com/community/tutorials/how-to-use-variables-and-constants-in-go">variable</a> called <code>a</code>. We provide the values of <code>"Understanding Interfaces in Go"</code> for the <code>Title</code> field, and <code>"Sammy Shark"</code> for the <code>Author</code> field:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">...
a := Article{
    Title: "Understanding Interfaces in Go",
    Author: "Sammy Shark",
}
...
</code></pre>
<p>Then, we print out the result of the <code>String</code> method by calling <code>fmt.Println</code> and passing in the result of the <code>a.String()</code> method call:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">...
fmt.Println(a.String())
</code></pre>
<p>After running the program you&rsquo;ll see the following output:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>The "Understanding Interfaces in Go" article was written by Sammy Shark.
</code></pre>
<p>So far, we haven&rsquo;t used an interface, but we did create a type that had a behavior. That behavior matched the <code>fmt.Stringer</code> interface. Next, let&rsquo;s see how we can use that behavior to make our code more reusable.</p>

<h2 id="defining-an-interface">Defining an Interface</h2>

<p>Now that we have our type defined with the desired behavior, we can look at how to use that behavior.</p>

<p>Before we do that, however, let&rsquo;s look at what we would need to do if we wanted to call the <code>String</code> method from the <code>Article</code> type in a function:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre plain"><code langs="">package main

import "fmt"

type Article struct {
    Title string
    Author string
}

func (a Article) String() string {
    return fmt.Sprintf("The %q article was written by %s.", a.Title, a.Author)
}

func main() {
    a := Article{
        Title: "Understanding Interfaces in Go",
        Author: "Sammy Shark",
    }
    <span class="highlight">Print(a)</span>
}

<span class="highlight">func Print(a Article) {</span>
    <span class="highlight">fmt.Println(a.String())</span>
<span class="highlight">}</span>
</code></pre>
<p>In this code we add a new function called <code>Print</code> that takes an <code>Article</code> as an argument. Notice that the only thing the <code>Print</code> function does is call the <code>String</code> method. Because of this, we could instead define an interface to pass to the function:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre plain"><code langs="">package main

import "fmt"

type Article struct {
    Title string
    Author string
}

func (a Article) String() string {
    return fmt.Sprintf("The %q article was written by %s.", a.Title, a.Author)
}

<span class="highlight">type Stringer interface {</span>
    <span class="highlight">String() string</span>
<span class="highlight">}</span>

func main() {
    a := Article{
        Title: "Understanding Interfaces in Go",
        Author: "Sammy Shark",
    }
    Print(a)
}

func Print(<span class="highlight">s Stringer</span>) {
    fmt.Println(<span class="highlight">s.String()</span>)
}
</code></pre>
<p>Here we created an interface called <code>Stringer</code>:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">...
type Stringer interface {
    String() string
}
...
</code></pre>
<p>The <code>Stringer</code> interface has only one method, called <code>String()</code> that returns a <code>string</code>. A <a href="https://www.digitalocean.com/community/tutorials/defining-methods-in-go">method</a> is a special function that is scoped to a specific type in Go. Unlike a function, a method can only be called from the instance of the type it was defined on.</p>

<p>We then update the signature of the <code>Print</code> method to take a <code>Stringer</code>, and not a concrete type of <code>Article</code>. Because the compiler knows that a <code>Stringer</code> interface defines the <code>String</code> method, it will only accept types that also have the <code>String</code> method.</p>

<p>Now we can use the <code>Print</code> method with anything that satisfies the <code>Stringer</code> interface. Let&rsquo;s create another type to demonstrate this:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre plain"><code langs="">package main

import "fmt"

type Article struct {
    Title  string
    Author string
}

func (a Article) String() string {
    return fmt.Sprintf("The %q article was written by %s.", a.Title, a.Author)
}

<span class="highlight">type Book struct {</span>
    <span class="highlight">Title  string</span>
    <span class="highlight">Author string</span>
    <span class="highlight">Pages  int</span>
<span class="highlight">}</span>

<span class="highlight">func (b Book) String() string {</span>
    <span class="highlight">return fmt.Sprintf("The %q book was written by %s.", b.Title, b.Author)</span>
<span class="highlight">}</span>

type Stringer interface {
    String() string
}

func main() {
    a := Article{
        Title:  "Understanding Interfaces in Go",
        Author: "Sammy Shark",
    }
    Print(a)

    <span class="highlight">b := Book{</span>
        <span class="highlight">Title:  "All About Go",</span>
        <span class="highlight">Author: "Jenny Dolphin",</span>
        <span class="highlight">Pages:  25,</span>
    <span class="highlight">}</span>
    <span class="highlight">Print(b)</span>
}

func Print(s Stringer) {
    fmt.Println(s.String())
}
</code></pre>
<p>We now add a second type called <code>Book</code>. It also has the <code>String</code> method defined. This means it also satisfies the <code>Stringer</code> interface. Because of this, we can also send it to our <code>Print</code> function:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>The "Understanding Interfaces in Go" article was written by Sammy Shark.
The "All About Go" book was written by Jenny Dolphin. It has 25 pages.
</code></pre>
<p>So far, we have demonstrated how to use just a single interface. However, an interface can have more than one behavior defined. Next, we&rsquo;ll see how we can make our interfaces more versatile by declaring more methods.</p>

<h2 id="multiple-behaviors-in-an-interface">Multiple Behaviors in an Interface</h2>

<p>One of the core tenants of writing Go code is to write small, concise types and compose them up to larger, more complex types. The same is true when composing interfaces. To see how we build up an interface, we&rsquo;ll first start by defining only one interface. We&rsquo;ll define two shapes, a <code>Circle</code> and <code>Square</code>, and they will both define a method called <code>Area</code>. This method will return the geometric area of their respective shapes:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import (
    "fmt"
    "math"
)

type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return math.Pi * c.Radius
}

type Square struct {
    Width  float64
    Height float64
}

func (s Square) Area() float64 {
    return s.Width * s.Height
}

type Sizer interface {
    Area() float64
}

func main() {
    c := Circle{Radius: 10}
    s := Square{Height: 10, Width: 5}

    l := Less(c, s)
    fmt.Printf("%+v is the smallest\n", l)
}

func Less(s1, s2 Sizer) Sizer {
    if s1.Area() &lt; s2.Area() {
        return s1
    }
    return s2
}
</code></pre>
<p>Because each type declares the <code>Area</code> method, we can create an interface that defines that behavior. We create the following <code>Sizer</code> interface:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">...
type Sizer interface {
    Area() float64
}
...
</code></pre>
<p>We then define a function called <code>Less</code> that takes two <code>Sizer</code> and returns the smallest one:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">...
func Less(s1, s2 Sizer) Sizer {
    if s1.Area() &lt; s2.Area() {
        return s1
    }
    return s2
}
...
</code></pre>
<p>Notice that we not only accept both arguments as the type <code>Sizer</code>, but we also return the result as a <code>Sizer</code> as well. This means that we no longer return a <code>Square</code> or a <code>Circle</code>, but the interface of <code>Sizer</code>.</p>

<p>Finally, we print out what had the smallest area:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>{Radius:10} is the smallest
</code></pre>
<p>Next, let&rsquo;s add another behavior to each type. This time we&rsquo;ll add the <code>String()</code> method that returns a string. This will satisfy the <code>fmt.Stringer</code> interface:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre plain"><code langs="">package main

import (
    "fmt"
    "math"
)

type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return math.Pi * c.Radius
}

<span class="highlight">func (c Circle) String() string {</span>
    <span class="highlight">return fmt.Sprintf("Circle {Radius: %.2f}", c.Radius)</span>
<span class="highlight">}</span>

type Square struct {
    Width  float64
    Height float64
}

func (s Square) Area() float64 {
    return s.Width * s.Height
}

<span class="highlight">func (s Square) String() string {</span>
    <span class="highlight">return fmt.Sprintf("Square {Width: %.2f, Height: %.2f}", s.Width, s.Height)</span>
<span class="highlight">}</span>

type Sizer interface {
    Area() float64
}

type Shaper interface {
    Sizer
    fmt.Stringer
}

func main() {
    c := Circle{Radius: 10}
    <span class="highlight">PrintArea(c)</span>

    s := Square{Height: 10, Width: 5}
    <span class="highlight">PrintArea(s)</span>

    l := Less(c, s)
    fmt.Printf("%v is the smallest\n", l)

}

func Less(s1, s2 Sizer) Sizer {
    if s1.Area() &lt; s2.Area() {
        return s1
    }
    return s2
}

<span class="highlight">func PrintArea(s Shaper) {</span>
    <span class="highlight">fmt.Printf("area of %s is %.2f\n", s.String(), s.Area())</span>
<span class="highlight">}</span>
</code></pre>
<p>Because both the <code>Circle</code> and the <code>Square</code> type implement both the <code>Area</code> and <code>String</code> methods, we can now create another interface to describe that wider set of behavior. To do this, we&rsquo;ll create an interface called <code>Shaper</code>. We&rsquo;ll compose this of the <code>Sizer</code> interface and the <code>fmt.Stringer</code> interface:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">...
type Shaper interface {
    Sizer
    fmt.Stringer
}
...
</code></pre>
<p><span class='note'><strong>Note:</strong>  It is considered idiomatic to try to name your interface by ending in <code>er</code>, such as <code>fmt.Stringer</code>, <code>io.Writer</code>, etc.  This is why we named our interface <code>Shaper</code>, and not <code>Shape</code>.<br></span></p>

<p>Now we can create a function called <code>PrintArea</code> that takes a <code>Shaper</code> as an argument. This means that we can call both methods on the passed in value for both the <code>Area</code> and <code>String</code> method:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">...
func PrintArea(s Shaper) {
    fmt.Printf("area of %s is %.2f\n", s.String(), s.Area())
}
</code></pre>
<p>If we run the program, we will receive the following output:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>area of Circle {Radius: 10.00} is 31.42
area of Square {Width: 5.00, Height: 10.00} is 50.00
Circle {Radius: 10.00} is the smallest
</code></pre>
<p>We have now seen how we can create smaller interfaces and build them up into larger ones as needed. While we could have started with the larger interface and passed it to all of our functions, it is considered best practice to send only the smallest interface to a function that is needed.  This typically results in clearer code, as anything that accepts a specific smaller interface only intends to work with that defined behavior.</p>

<p>For example, if we passed <code>Shaper</code> to the <code>Less</code> function, we may assume that it is going to call both the <code>Area</code> and <code>String</code> methods.  However, since we only intend to call the <code>Area</code> method, it makes the <code>Less</code> function clear as we know that we can only call the <code>Area</code> method of any argument passed to it.</p>

<h2 id="conclusion">Conclusion</h2>

<p>We have seen how creating smaller interfaces and building them up to larger ones allows us to share only what we need to a function or method. We also learned that we can compose our interfaces from other interfaces, including those defined from other packages, not just our packages.</p>

<p>If you&rsquo;d like to learn more about the Go programming language, check out the entire <a href="https://www.digitalocean.com/community/tutorial_series/how-to-code-in-go">How To Code in Go series</a>.</p>
