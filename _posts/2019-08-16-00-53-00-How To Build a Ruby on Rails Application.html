---
layout: post
title: How To Build a Ruby on Rails Application
network: digitalocean
date: August 16, 2019 at 12:53AM
url: https://www.digitalocean.com/community/tutorials/how-to-build-a-ruby-on-rails-application
image: https://assets.digitalocean.com/articles/build_rails_app/rails_landing.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="introduction">Introduction</h3>

<p><a href="https://rubyonrails.org/">Rails</a> is a web application framework written in <a href="https://www.digitalocean.com/community/tags/ruby">Ruby</a>. It takes an opinionated approach to application development, assuming that set conventions best serve developers where there is a common goal. Rails therefore offers conventions for handling routing, stateful data, asset management, and more to provide the baseline functionality that most web applications need. </p>

<p>Rails follows the <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller"><em>model-view-controller</em></a> (MCV) architectural pattern, which separates an application's logic, located in models, from the routing and presentation of application information. This organizational structure — along with other conventions that allow developers to extract code into <a href="https://api.rubyonrails.org/classes/ActionController/Helpers.html">helpers</a> and <a href="https://api.rubyonrails.org/classes/ActionView/PartialRenderer.html">partials</a> — ensures that application code isn't <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">repeated unnecessarily</a>. </p>

<p>In this tutorial, you will build a Rails application that will enable users to post information about sharks and their behavior. It will be a good starting point for future application development.</p>

<h2 id="prerequisites">Prerequisites</h2>

<p>To follow this tutorial, you will need:</p>

<ul>
<li>A local machine or development server running Ubuntu 18.04. Your development machine should have a non-root user with administrative privileges and a firewall configured with <code>ufw</code>. For instructions on how to set this up, see our <a href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04">Initial Server Setup with Ubuntu 18.04</a> tutorial.</li>
<li><a href="https://nodejs.org">Node.js</a> and <a href="https://www.npmjs.com/">npm</a> installed on your local machine or development server. This tutorial uses Node.js version <span class="highlight">10.16.3</span> and npm version <span class="highlight">6.9.0</span>. For guidance on installing Node.js and npm on Ubuntu 18.04, follow the instructions in the "Installing Using a PPA" section of <a href="https://www.digitalocean.com/community/tutorials/how-to-install-node-js-on-ubuntu-18-04#installing-using-a-ppa">How To Install Node.js on Ubuntu 18.04</a>. </li>
<li>Ruby, <a href="https://github.com/rbenv/rbenv">rbenv</a>, and Rails installed on your local machine or development server, following Steps 1-4 in <a href="https://www.digitalocean.com/community/tutorials/how-to-install-ruby-on-rails-with-rbenv-on-ubuntu-18-04">How To Install Ruby on Rails with rbenv on Ubuntu 18.04</a>. This tutorial uses Ruby <span class="highlight">2.5.1</span>, rbenv <span class="highlight">1.1.2</span>, and Rails <span class="highlight">5.2.0</span>.</li>
</ul>

<h2 id="step-1-—-installing-sqlite3">Step 1 — Installing SQLite3</h2>

<p>Before creating our Rails shark application, we will need to ensure that we have a database to store user data. Rails is configured to use <a href="https://www.sqlite.org/index.html">SQLite</a> by default, and this is often a good choice in development. Since our application data doesn't require a high level programmatic extensibility, SQLite will meet our needs. </p>

<p>First, update your package index:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt update
</li></ul></code></pre>
<p>Next, install the <code>sqlite3</code> and <code>libsqlite3-dev</code> packages:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt install sqlite3 libsqlite3-dev
</li></ul></code></pre>
<p>This will install both SQLite and its required development files.</p>

<p>Check your version to confirm that the installation was successful:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sqlite3 --version
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div><span class="highlight">3.22.0</span> 2018-01-22 18:45:57 <span class="highlight">0c55d179733b46d8d0ba4d88e01a25e10677046ee3da1d5b1581e86726f2alt1</span>
</code></pre>
<p>With SQLite installed, you are ready to begin developing your application.</p>

<h2 id="step-2-—-creating-a-new-rails-project">Step 2 — Creating a New Rails Project</h2>

<p>With our database installed, we can create a new Rails project and look at some of the default boilerplate code that Rails gives us with the <a href="https://guides.rubyonrails.org/command_line.html#rails-new"><code>rails new</code> command</a>.</p>

<p>Create a project called <code><span class="highlight">sharkapp</span></code> with the following command:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">rails new <span class="highlight">sharkapp</span>
</li></ul></code></pre>
<p>You will see a good deal of output telling you what Rails is creating for your new project. The output below highlights some significant files, directories, and commands:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>     create  
     . . .
     create  Gemfile 
     . . .
      create  app 
      . . .
      create  app/controllers/application_controller.rb
      . . .
      create  app/models/application_record.rb
      . . .
      create  app/views/layouts/application.html.erb
      . . . 
      create  config
      create  config/routes.rb
      create  config/application.rb
      . . . 
      create  config/environments
      create  config/environments/development.rb
      create  config/environments/production.rb
      create  config/environments/test.rb
      . . .
      create  config/database.yml
      create  db
      create  db/seeds.rb
      . . . 
         run  bundle install
      . . . 
Bundle complete! 18 Gemfile dependencies, 78 gems now installed.
Use `bundle info [gemname]` to see where a bundled gem is installed.
      . . . 
* bin/rake: Spring inserted
* bin/rails: Spring inserted
</code></pre>
<p>The output highlighted here tells you that Rails has created the following:</p>

<ul>
<li><code>Gemfile</code>: This file lists the gem dependencies for your application. A <a href="https://guides.rubygems.org/what-is-a-gem/">gem</a> is a Ruby software package, and a Gemfile allows you to manage your project's software needs. </li>
<li><code>app</code>: The <code>app</code> directory is where your main application code lives. This includes the models, controllers, views, assets, helpers, and mailers that make up the application itself. Rails gives you some application-level boilerplate for the MCV model to start out in files like <code>app/models/application_record.rb</code>, <code>app/controllers/application_controller.rb</code>, and <code>app/views/layouts/application.html.erb</code>.</li>
<li><code>config</code>: This directory contains your application's configuration settings:

<ul>
<li><code>config/routes.rb</code>: Your application's route declarations live in this file.</li>
<li><code>config/application.rb</code>: General settings for your application components are located in this file. </li>
</ul></li>
<li><code>config/environments</code>: This directory is where configuration settings for your environments live. Rails includes three environments by default: <code>development</code>, <code>production</code>, and <code>test</code>.</li>
<li><code>config/database.yml</code>: Database configuration settings live in this file, which is broken into four sections: <code>default</code>, <code>development</code>, <code>production</code>, and <code>test</code>. Thanks to the Gemfile that came with the <code>rails new</code> command, which included the <code>sqlite3</code> gem, our <code>config/database.yml</code> file has its <code>adapter</code> parameter set to <code>sqlite3</code> already, specifying that we will use an SQLite database with this application.</li>
<li><code>db</code>: This folder includes a directory for database <a href="https://guides.rubyonrails.org/active_record_migrations.html">migrations</a> called <code>migrate</code>, along with the <code>schema.rb</code> and <code>seeds.rb</code> files. <code>schema.db</code> contains information about your database, while <code>seeds.rb</code> is where you can place seed data for the database.</li>
</ul>

<p>Finally, Rails runs the <a href="https://bundler.io/man/bundle-install.1.html"><code>bundle install</code></a> command to install the dependencies listed in your <code>Gemfile</code>.</p>

<p>Once everything is set up, navigate to the <code><span class="highlight">sharkapp</span></code> directory:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd <span class="highlight">sharkapp</span>
</li></ul></code></pre>
<p>You can now start the Rails server to ensure that your application is working, using the <a href="https://guides.rubyonrails.org/command_line.html#rails-server"><code>rails server</code> command</a>. If you are working on your local machine, type:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">rails server 
</li></ul></code></pre>
<p>Rails binds to <code>localhost</code> by default, so you can now access your application by navigating your browser to <code>locahost:3000</code>, where you will see the following image:</p>

<p><img src="https://assets.digitalocean.com/articles/build_rails_app/rails_landing.png" alt="Rails Landing Page"></p>

<p>If you are working on a development server, first ensure that connections are allowed on port <code>3000</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo ufw allow 3000
</li></ul></code></pre>
<p>Then start the server with the <code>--binding</code> flag, to bind to your server IP:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">rails server --binding=<span class="highlight">your_server_ip</span>
</li></ul></code></pre>
<p>Navigate to <code>http://<span class="highlight">your_server_ip</span>:3000</code> in your browser, where you will see the Rails welcome message.</p>

<p>Once you have looked around, you can stop the server with <code>CTRL+C</code>.</p>

<p>With your application created and in place, you are ready to start building from the Rails boilerplate to create a unique application.</p>

<h2 id="step-3-—-scaffolding-the-application">Step 3 — Scaffolding the Application</h2>

<p>To create our shark information application, we will need to create a model to manage our application data, views to enable user interaction with that data, and a controller to manage communication between the model and the views. To build these things we will use the <code>rails generate scaffold</code> command, which will give us a model, a <a href="https://guides.rubyonrails.org/active_record_migrations.html">database migration</a> to alter the database schema, a controller, a full set of views to manage <a href="https://en.wikipedia.org/wiki/">Create, Read, Update, and Delete</a> (CRUD) operations for the application, and templates for partials, helpers, and tests.</p>

<p>Because the <code>generate scaffold</code> command does so much work for us, we'll take a closer look at the resources it creates to understand the work that Rails is doing under the hood. </p>

<p>Our <code>generate scaffold</code> command will include the name of our model and the fields we want in our database table. Rails uses <a href="https://github.com/rails/rails/tree/master/activerecord">Active Record</a> to manage relationships between application data, constructed as objects with models, and the application database. Each of our models is a <a href="https://ruby-doc.org/core-2.5.3/Class.html">Ruby class</a>, while also inheriting from the <code>ActiveRecord::Base</code> class. This means that we can work with our model class in the same way that we would work with a Ruby class, while also pulling in methods from Active Record. Active Record will then ensure that each class is mapped to a table in our database, and each instance of that class to a row in that table.</p>

<p>Type the following command to generate a <code>Shark</code> model, controller, and associated views:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">rails generate scaffold Shark name:string facts:text
</li></ul></code></pre>
<p>With <code>name:string</code> and <code>facts:text</code> we are giving Rails information about the fields we would like in our database table and the type of data they should accept. Both will give us room to input what we would like, though <code>text</code> will allow more characters for shark facts.</p>

<p>When you type this command, you will again see a long list of output that explains everything Rails is generating for you. The output below highlights some of the more significant things for our setup:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>      invoke  active_record
      create    db/migrate/<span class="highlight">20190804181822</span>_create_sharks.rb
      create    app/models/shark.rb
      . . .
      invoke  resource_route
       route    resources :sharks
      invoke  scaffold_controller
      create    app/controllers/sharks_controller.rb
      invoke    erb
      create      app/views/sharks
      create      app/views/sharks/index.html.erb
      create      app/views/sharks/edit.html.erb
      create      app/views/sharks/show.html.erb
      create      app/views/sharks/new.html.erb
      create      app/views/sharks/_form.html.erb
      . . .
</code></pre>
<p>Rails has created the model at <code>app/models/shark.rb</code> and a database migration to go with it: <code>db/migrate/<span class="highlight">20190804181822</span>_create_sharks.rb</code>. The timestamp on your migration file will differ from what you see here. </p>

<p>It has also created a controller, <code>app/controllers/sharks_controller.rb</code>, as well as the views associated with our application's CRUD operations, collected under <code>app/views/sharks</code>. Among these views is a partial, <code>_form.html.erb</code>, that contains code used across views.</p>

<p>Finally, Rails added a new resourceful route, <code>resources :sharks</code>, to <code>config/routes.rb</code>. This enables the Rails router to match incoming HTTP requests with the <code>sharks</code> controller and its associated views.</p>

<p>Though Rails has done much of the work of building out our application code for us, it is worth taking a look at some files to understand what is happening. </p>

<p>First, let's look at the controller file with the following command:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cat app/controllers/sharks_controller.rb
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>class SharksController &lt; ApplicationController
  before_action :set_shark, only: [:show, :edit, :update, :destroy]

  # GET /sharks
  # GET /sharks.json
  def index
    @sharks = Shark.all
  end

  # GET /sharks/1
  # GET /sharks/1.json
  def show
  end

  # GET /sharks/new
  def new
    @shark = Shark.new
  end

  # GET /sharks/1/edit
  def edit
  end

  # POST /sharks
  # POST /sharks.json
  def create
    @shark = Shark.new(shark_params)

    respond_to do |format|
      if @shark.save
        format.html { redirect_to @shark, notice: 'Shark was successfully created.' }
        format.json { render :show, status: :created, location: @shark }
      else
        format.html { render :new }
        format.json { render json: @shark.errors, status: :unprocessable_entity }
      end
    end
  end

  # PATCH/PUT /sharks/1
  # PATCH/PUT /sharks/1.json
  def update
    respond_to do |format|
      if @shark.update(shark_params)
        format.html { redirect_to @shark, notice: 'Shark was successfully updated.' }
        format.json { render :show, status: :ok, location: @shark }
      else
        format.html { render :edit }
        format.json { render json: @shark.errors, status: :unprocessable_entity }
      end
    end
  end

  # DELETE /sharks/1
  # DELETE /sharks/1.json
  def destroy
    @shark.destroy
    respond_to do |format|
      format.html { redirect_to sharks_url, notice: 'Shark was successfully destroyed.' }
      format.json { head :no_content }
    end
  end

  private
    # Use callbacks to share common setup or constraints between actions.
    def set_shark
      @shark = Shark.find(params[:id])
    end

    # Never trust parameters from the scary internet, only allow the white list through.
    def shark_params
      params.require(:shark).permit(:name, :facts)
    end
end
</code></pre>
<p>The controller is responsible for managing how information gets fetched and passed to its associated model, and how it gets associated with particular views. As you can see, our <code>sharks</code> controller includes a series of methods that map roughly to standard CRUD operations. However, there are more methods than CRUD functions, to enable efficiency in the case of errors.</p>

<p>For example, consider the <code>create</code> method:</p>
<div class="code-label " title="~/sharkapp/app/controllers/sharks_controller.rb">~/sharkapp/app/controllers/sharks_controller.rb</div><pre class="code-pre "><code langs="">. . .
  def create
    @shark = Shark.new(shark_params)

    respond_to do |format|
      if @shark.save
        format.html { redirect_to @shark, notice: 'Shark was successfully created.' }
        format.json { render :show, status: :created, location: @shark }
      else
        format.html { render :new }
        format.json { render json: @shark.errors, status: :unprocessable_entity }
      end
    end
  end
. . . 
</code></pre>
<p>If a new instance of the <code>Shark</code> class is successfully saved, <code>redirect_to</code> will spawn a new request that is then directed to the controller. This will be a <code>GET</code> request, and it will be handled by the <code>show</code> method, which will show the user the shark they've just added.</p>

<p>If there is a failure, then Rails will render the <code>app/views/sharks/new.html.erb</code> template again rather than making another request to the router, giving users another chance to submit their data.</p>

<p>In addition to the sharks controller, Rails has given us a template for an <code>index</code> view, which maps to the <code>index</code> method in our controller. We will use this as the root view for our application, so it's worth taking a look at it.</p>

<p>Type the following to output the file:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cat app/views/sharks/index.html.erb
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>&lt;p id="notice"&gt;&lt;%= notice %&gt;&lt;/p&gt;

&lt;h1&gt;Sharks&lt;/h1&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Name&lt;/th&gt;
      &lt;th&gt;Facts&lt;/th&gt;
      &lt;th colspan="3"&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;

  &lt;tbody&gt;
    &lt;% @sharks.each do |shark| %&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;%= shark.name %&gt;&lt;/td&gt;
        &lt;td&gt;&lt;%= shark.facts %&gt;&lt;/td&gt;
        &lt;td&gt;&lt;%= link_to 'Show', shark %&gt;&lt;/td&gt;
        &lt;td&gt;&lt;%= link_to 'Edit', edit_shark_path(shark) %&gt;&lt;/td&gt;
        &lt;td&gt;&lt;%= link_to 'Destroy', shark, method: :delete, data: { confirm: 'Are you sure?' } %&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;% end %&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;br&gt;

&lt;%= link_to 'New Shark', new_shark_path %&gt;
</code></pre>
<p>The <code>index</code> view iterates through the instances of our <code>Shark</code> class, which have been mapped to the <code>sharks</code> table in our database. Using <a href="https://ruby-doc.org//stdlib-1.9.3/libdoc/erb/rdoc/ERB.html">ERB templating</a>, the view outputs each field from the table that is associated with an individual shark instance: <code>name</code> and <code>facts</code>.</p>

<p>The view then uses the <a href="https://api.rubyonrails.org/v5.2.3/classes/ActionView/Helpers/UrlHelper.html#method-i-link_to"><code>link_to</code></a> helper to create a hyperlink, with the provided string as the text for the link and the provided path as the destination. The paths themselves are made possible through the <a href="https://guides.rubyonrails.org/routing.html#path-and-url-helpers">helpers</a> that became available to us when we defined the <code>sharks</code> resourceful route with the <code>rails generate scaffold</code> command. </p>

<p>In addition to looking at our <code>index</code> view, we can also take a look at the <code>new</code> view to see how Rails uses partials in views. Type the following to output the <code>app/views/sharks/new.html.erb</code> template:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cat app/views/sharks/new.html.erb
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>&lt;h1&gt;New Shark&lt;/h1&gt;

&lt;%= render 'form', shark: @shark %&gt;

&lt;%= link_to 'Back', sharks_path %&gt;
</code></pre>
<p>Though this template may look like it lacks input fields for a new shark entry, the reference to <code>render 'form'</code> tells us that the template is pulling in the <code>_form.html.erb</code> partial, which extracts code that is repeated across views.</p>

<p>Looking at that file will give us a full sense of how a new shark instance gets created: </p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cat app/views/sharks/_form.html.erb
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>&lt;%= form_with(model: shark, local: true) do |form| %&gt;
  &lt;% if shark.errors.any? %&gt;
    &lt;div id="error_explanation"&gt;
      &lt;h2&gt;&lt;%= pluralize(shark.errors.count, "error") %&gt; prohibited this shark from being saved:&lt;/h2&gt;

      &lt;ul&gt;
      &lt;% shark.errors.full_messages.each do |message| %&gt;
        &lt;li&gt;&lt;%= message %&gt;&lt;/li&gt;
      &lt;% end %&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;% end %&gt;

  &lt;div class="field"&gt;
    &lt;%= form.label :name %&gt;
    &lt;%= form.text_field :name %&gt;
  &lt;/div&gt;

  &lt;div class="field"&gt;
    &lt;%= form.label :facts %&gt;
    &lt;%= form.text_area :facts %&gt;
  &lt;/div&gt;

  &lt;div class="actions"&gt;
    &lt;%= form.submit %&gt;
  &lt;/div&gt;
&lt;% end %&gt;
</code></pre>
<p>This template makes use of the <a href="https://api.rubyonrails.org/v5.2.3/classes/ActionView/Helpers/FormHelper.html#method-i-form_with"><code>form_with</code></a> <a href="https://api.rubyonrails.org/v5.2.3/classes/ActionView/Helpers/FormHelper.html">form helper</a>. Form helpers are designed to facilitate the creation of new objects from user input using the fields and scope of particular models. Here, <code>form_with</code> takes <code>model: shark</code> as an argument, and the new form builder object that it creates has field inputs that correspond to the fields in the <code>sharks</code> table. Thus users have form fields to enter both a shark <code>name</code> and shark <code>facts</code>.</p>

<p>Submitting this form will create a JSON response with user data that the rest of your application can access by way of the <a href="https://api.rubyonrails.org/classes/ActionController/Parameters.html">params method</a>, which creates a <code>ActionController::Parameters</code> object with that data. </p>

<p>Now that you know what <code>rails generate scaffold</code> has produced for you, you can move on to setting the root view for your application. </p>

<h2 id="step-4-—-creating-the-application-root-view-and-testing-functionality">Step 4 — Creating the Application Root View and Testing Functionality</h2>

<p>Ideally, you want the landing page of your application to map to the application's root, so users can immediately get a sense of the application's purpose. </p>

<p>There are a number of ways you could handle this: for example, you could create a <code>Welcome</code> controller and an associated <code>index</code> view, which would give users a generic landing page that could also link out to different parts of the application. In our case, however, having users land on our <code>index</code> sharks view will be enough of an introduction to the application's purpose for now.</p>

<p>To set this up, you will need to modify the routing settings in <code>config/routes.rb</code> to specify the root of the application.</p>

<p>Open <code>config/routes.rb</code> for editing, using <code>nano</code> or your favorite editor:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano config/routes.rb
</li></ul></code></pre>
<p>The file will look like this:</p>
<div class="code-label " title="~/sharkapp/config/routes.rb">~/sharkapp/config/routes.rb</div><pre class="code-pre "><code langs="">Rails.application.routes.draw do
  resources :sharks
  # For details on the DSL available within this file, see http://guides.rubyonrails.org/routing.html
end
</code></pre>
<p>Without setting something more specific, the default view at <code>http://localhost:3000</code> or <code>http://<span class="highlight">your_server_ip</span>:3000</code> will be the default Rails welcome page.</p>

<p>In order to map the root view of the application to the <code>index</code> view of the sharks controller, you will need to add the following line to the file:</p>
<div class="code-label " title="~/sharkapp/config/routes.rb">~/sharkapp/config/routes.rb</div><pre class="code-pre "><code langs="">Rails.application.routes.draw do
  resources :sharks

  <span class="highlight">root 'sharks#index'</span> 
  # For details on the DSL available within this file, see http://guides.rubyonrails.org/routing.html
end
</code></pre>
<p>Now, when users navigate to your application root, they will see a full listing of sharks, and have the opportunity to create a new shark entry, look at existing entries, and edit or delete given entries.</p>

<p>Save the file and exit your editor when you are finished editing. If you used <code>nano</code> to edit the file, you can do so by pressing <code>CTRL+X</code>, <code>Y</code>, then <code>ENTER</code></p>

<p>You can now run your migrations with the following command:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">rails db:migrate
</li></ul></code></pre>
<p>You will see output confirming the migration.</p>

<p>Start your Rails server once again. If you are working locally, type:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">rails s
</li></ul></code></pre>
<p>On a development server, type:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">rails s --binding=<span class="highlight">your_server_ip</span>
</li></ul></code></pre>
<p>Navigate to <code>localhost:3000</code> if you are working locally, or <code>http://<span class="highlight">your_server_ip</span>:3000</code> if you are working on a development server.</p>

<p>Your application landing page will look like this:</p>

<p><img src="https://assets.digitalocean.com/articles/build_rails_app/index_no_style.png" alt="Application Landing Page"></p>

<p>To create a new shark, click on the <strong>New Shark</strong> link at the bottom of the page, which will take you to the <code>sharks/new</code> route:</p>

<p><img src="https://assets.digitalocean.com/articles/build_rails_app/new_no_style.png" alt="Create New Shark"></p>

<p>Let's add some demo information to test our application. Input "Great White" into the <strong>Name</strong> field and "Scary" into the <strong>Facts</strong> field:</p>

<p><img src="https://assets.digitalocean.com/articles/build_rails_app/add_shark_no_style.png" alt="Add Great White Shark"></p>

<p>Click on the <strong>Create</strong> button to create the shark.</p>

<p>This will direct you to the <code>show</code> route, which, thanks to the <code>before_action</code> filter, is set with the <code>set_shark</code> method, which grabs the <code>id</code> of the shark we've just created:</p>
<div class="code-label " title="~/sharkapp/app/controllers/sharks_controller.rb">~/sharkapp/app/controllers/sharks_controller.rb</div><pre class="code-pre "><code langs="">class SharksController &lt; ApplicationController
  before_action <span class="highlight">:set_shark</span>, only: [<span class="highlight">:show</span>, :edit, :update, :destroy]

  . . . 

  def show
  end

  . . . 

  private
    # Use callbacks to share common setup or constraints between actions.
    def set_shark
      <a href="https://www.digitalocean.com/community/users/shark" class="username-tag">@shark</a> = Shark.find(params[<span class="highlight">:id</span>])
    end
  . . .
</code></pre>
<p><img src="https://assets.digitalocean.com/articles/build_rails_app/show_no_style.png" alt="Show Shark"></p>

<p>You can test the edit function now by clicking <strong>Edit</strong> on your shark entry. This will take you to the <code>edit</code> route for that shark:</p>

<p><img src="https://assets.digitalocean.com/articles/build_rails_app/edit_no_style.png" alt="Edit Shark"></p>

<p>Change the <code>facts</code> about the Great White to read "Large" instead of "Scary" and click <strong>Update Shark</strong>. This will take you back to the <code>show</code> route:</p>

<p><img src="https://assets.digitalocean.com/articles/build_rails_app/updated_no_style.png" alt="Updated Shark"></p>

<p>Finally, clicking <strong>Back</strong> will take you to your updated <code>index</code> view:</p>

<p><img src="https://assets.digitalocean.com/articles/build_rails_app/new_index_no_style.png" alt="New Index View"></p>

<p>Now that you have tested your application's basic functionality, you can add some validations and security checks to make everything more secure. </p>

<h2 id="step-5-—-adding-validations">Step 5 — Adding Validations</h2>

<p>Your shark application can accept input from users, but imagine a case where a user attempts to create a shark without adding facts to it, or creates an entry for a shark that's already in the database. You can create mechanisms to check data before it gets entered into the database by adding validations to your models. Since your application's logic is located in its models, validating data input here makes more sense than doing so elsewhere in the application. </p>

<p>Note that we will not cover writing validation tests in this tutorial, but you can find out more about testing by consulting <a href="https://guides.rubyonrails.org/testing.html">the Rails documentation</a>. </p>

<p>If you haven't stopped the server yet, go ahead and do that by typing <code>CTRL+C</code>.</p>

<p>Open your <code>shark.rb</code> model file:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano app/models/shark.rb
</li></ul></code></pre>
<p>Currently, the file tells us that the <code>Shark</code> class inherits from <code>ApplicationRecord</code>, which in turn inherits from <a href="https://api.rubyonrails.org/classes/ActiveRecord/Base.html"><code>ActiveRecord::Base</code></a>: </p>
<div class="code-label " title="~/sharkapp/app/models/shark.rb">~/sharkapp/app/models/shark.rb</div><pre class="code-pre "><code langs="">class Shark &lt; ApplicationRecord
end
</code></pre>
<p>Let's first add some validations to our <code>name</code> field to confirm that the field is filled out and that the entry is unique, preventing duplicate entries:</p>
<div class="code-label " title="~/sharkapp/app/models/shark.rb">~/sharkapp/app/models/shark.rb</div><pre class="code-pre "><code langs="">class Shark &lt; ApplicationRecord
  <span class="highlight">validates :name, presence: true, uniqueness: true</span>
end
</code></pre>
<p>Next, add a validation for the <code>facts</code> field to ensure that it, too, is filled out:</p>
<div class="code-label " title="~/sharkapp/app/models/shark.rb">~/sharkapp/app/models/shark.rb</div><pre class="code-pre "><code langs="">class Shark &lt; ApplicationRecord
  validates :name, presence: true, uniqueness: true
  <span class="highlight">validates :facts, presence: true</span>
end
</code></pre>
<p>We are less concerned here with the uniqueness of the facts, as long as they are associated with unique shark entries.</p>

<p>Save and close the file when you are finished. </p>

<p>Start up your server once again with either <code>rails s</code> or <code>rails s --binding=<span class="highlight">your_server_ip</span></code>, depending on whether you are working locally or with a development server.</p>

<p>Navigate to your application's root at <code>http://localhost:3000</code> or <code>http://<span class="highlight">your_server_ip</span>:3000</code>.</p>

<p>Click on <strong>New Shark</strong>. In the form, add "Great White" to the <strong>Name</strong> field and "Big Teeth" to the <strong>Facts</strong> field, and then click on <strong>Create Shark</strong>. You should see the following warning:</p>

<p><img src="https://assets.digitalocean.com/articles/build_rails_app/unique_validate.png" alt="Unique Validation Warning"></p>

<p>Now, let's see if we can check our other validation. Click <strong>Back</strong> to return to the homepage, and then <strong>New Shark</strong> once again. In the new form, enter "Tiger Shark" in the <strong>Name</strong> field, and leave <strong>Facts</strong> blank. Clicking <strong>Create Shark</strong> will trigger the following warning:</p>

<p><img src="https://assets.digitalocean.com/articles/build_rails_app/fact_presence.png" alt="Fact Presence Warning"></p>

<p>With these changes, your application has some validations in place to ensure consistency in the data that's saved to the database. Now you can turn your attention to your application's users and defining who can modify application data.</p>

<h2 id="step-6-—-adding-authentication">Step 6 — Adding Authentication</h2>

<p>With validations in place, we have some guarantees about the data that's being saved to the database. But what about users? If we don't want any and all users adding to the database, then we should add some authentication measures to ensure that only permitted users can add sharks. In order to do this, we'll use the <a href="https://api.rubyonrails.org/classes/ActionController/HttpAuthentication/Basic.html"><code>http_basic_authenticate_with</code> method</a>, which will allow us to create a username and password combination to authenticate users.</p>

<p>There are a number of ways to authenticate users with Rails, including working with the <a href="https://rubygems.org/gems/bcrypt/versions/3.1.12"><code>bcrypt</code></a> or <a href="https://rubygems.org/gems/devise"><code>devise</code></a> gems. For now, however, we will add a method to our application controller that will apply to actions across our application. This will be useful if we add more controllers to the application in the future. </p>

<p>Stop your server again with <code>CTRL+C</code>.</p>

<p>Open the file that defines your <code>ApplicationController</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano app/controllers/application_controller.rb
</li></ul></code></pre>
<p>Inside, you will see the definition for the <code>ApplicationController</code> class, which the other controllers in your application inherit from:</p>
<div class="code-label " title="~/sharkapp/app/controllers/application_controller.rb">~/sharkapp/app/controllers/application_controller.rb</div><pre class="code-pre "><code langs="">class ApplicationController &lt; ActionController::Base
end
</code></pre>
<p>To authenticate users, we'll use a hardcoded username and password with the <code>http_basic_authenticate_with</code> method. Add the following code to the file:</p>
<div class="code-label " title="~/sharkapp/app/controllers/application_controller.rb">~/sharkapp/app/controllers/application_controller.rb</div><pre class="code-pre "><code langs="">class ApplicationController &lt; ActionController::Base
  <span class="highlight">http_basic_authenticate_with name: 'sammy', password: 'shark', except: [:index, :show]</span>
end
</code></pre>
<p>In addition to supplying the username and password here, we've also restricted authentication by specifying the routes where it should <strong>not</strong> be required: <code>index</code> and <code>show</code>. Another way of accomplishing this would have been to write <code>only: [:create, :update, :destroy]</code>. This way, all users will be able to look at all of the sharks and read facts about particular sharks. When it comes to modifying site content, however, users will need to prove that they have access.</p>

<p>In a more robust setup, you would not want to hardcode values in this way, but for the purposes of demonstration, this will allow you to see how you can include authentication for your application's routes. It also lets you see how Rails stores session data by default in cookies: once you authenticate on a specified action, you will not be required to authenticate again in the same session.</p>

<p>Save and close <code>app/controllers/application_controller.rb</code> when you are finished editing. You can now test authentication in action.</p>

<p>Start the server with either <code>rails s</code> or <code>rails s --binding=<span class="highlight">your_server_ip</span></code> and navigate to your application at either <code>http://localhost:3000</code> or <code>http://<span class="highlight">your_server_ip</span>:3000</code>. </p>

<p>On the landing page, click on the <strong>New Shark</strong> button. This will trigger the following authentication window:</p>

<p><img src="https://assets.digitalocean.com/articles/build_rails_app/sign_in_two.png" alt="User Authentication"></p>

<p>If you enter the username and password combination you added to <code>app/controllers/application_controller.rb</code>, you will be able to securely create a new shark.</p>

<p>You now have a working shark application, complete with data validations and a basic authentication scheme.</p>

<h2 id="conclusion">Conclusion</h2>

<p>The Rails application you created in this tutorial is a jumping off point that you can use for further development. If you are interested in exploring the Rails ecosystem, the <a href="https://guides.rubyonrails.org/">project documentation</a> is a great place to start.</p>

<p>Additionally, you might want to explore how to set up a more robust frontend for your project with a framework such as <a href="https://reactjs.org/">React</a>. <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-ruby-on-rails-project-with-a-react-frontend">How To Set Up a Ruby on Rails Project with a React Frontend</a> offers guidance on how to do this.</p>

<p>If you would like to explore different database options, you can also check out <a href="https://www.digitalocean.com/community/tutorials/how-to-use-postgresql-with-your-ruby-on-rails-application-on-ubuntu-18-04">How To Use PostgreSQL with Your Ruby on Rails Application on Ubuntu 18.04</a>, which walks through how to work with <a href="https://www.postgresql.org/">PostgreSQL</a> instead of SQLite. You can also consult our library of <a href="https://www.digitalocean.com/community/tags/postgresql?type=tutorials">PostgreSQL tutorials</a> to learn more about working with this database.</p>
