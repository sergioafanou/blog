---
layout: post
title: How To Serve Flask Applications with uWSGI and Nginx on Ubuntu 18.04
network: digitalocean
date: December 12, 2019 at 08:01PM
url: https://www.digitalocean.com/community/tutorials/how-to-serve-flask-applications-with-uswgi-and-nginx-on-ubuntu-18-04-pt
image: https://assets.digitalocean.com/articles/nginx_uwsgi_wsgi_1404/test_app.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="introdução">Introdução</h3>

<p>Neste guia, você construirá um aplicativo Python usando o microframework do Flask no Ubuntu 18.04. A maior parte deste artigo será sobre como configurar o <a href="http://uwsgi-docs.readthedocs.io/en/latest/">servidor do aplicativo uWSGI</a> e como iniciar o aplicativo e configurar o <a href="https://www.nginx.com/">Nginx</a> para atuar como um proxy reverso no front-end.</p>

<h2 id="pré-requisitos">Pré-requisitos</h2>

<p>Antes de iniciar este guia, você deve ter:</p>

<ul>
<li>Um servidor com o Ubuntu 18.04 instalado e um usuário não raiz com privilégios sudo. Siga nosso <a href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04">guia de configuração inicial do servidor</a> para orientação.</li>
<li>O Nginx instalado, seguindo os Passos 1 e 2 de <a href="https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-ubuntu-18-04">Como Instalar o Nginx no Ubuntu 18.04</a>.</li>
<li><p>Um nome de domínio configurado para apontar para o seu servidor. Você pode comprar um no <a href="https://namecheap.com">Namecheap</a> ou obter um de graça no <a href="http://www.freenom.com/en/index.html">Freenom</a>. Você pode aprender como apontar domínios para o DigitalOcean seguindo a relevante <a href="https://www.digitalocean.com/docs/networking/dns/">documentação para domínios e DNS</a>. Certifique-se de criar os seguintes registros DNS:</p>

<ul>
<li>Um registro com o <code>your_domain &lt;^&gt;</code>apontando para o endereço IP público do seu servidor.</li>
<li>Um registro A com <code>www.<span class="highlight">your_domain</span></code> apontando para o endereço IP público do seu servidor.</li>
</ul></li>
<li><p>Familiaridade com a uWSGI, nosso servidor do aplicativo, e as especficiações da WSGI. <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-uwsgi-and-nginx-to-serve-python-apps-on-ubuntu-14-04#definitions-and-concepts">Este debate</a> sobre definições e conceitos examinará ambos em detalhes.</p></li>
</ul>

<h2 id="passo-1-—-instalando-os-componentes-dos-repositórios-do-ubuntu">Passo 1 — Instalando os componentes dos repositórios do Ubuntu</h2>

<p>Nosso primeiro passo será instalar todas as partes dos repositórios do Ubuntu que vamos precisar. Vamos instalar o <code>pip</code> e o gerenciador de pacotes Python para gerenciar nossos componentes Python. Também vamos obter os arquivos de desenvolvimento do Python necessários para construir a uWSGI.</p>

<p>Primeiramente, vamos atualizar o índice local de pacotes e instalar os pacotes que irão nos permitir construir nosso ambiente Python. Estes incluem o <code>python3-pip</code>, junto com alguns outros pacotes e ferramentas de desenvolvimento necessários para um ambiente de programação robusto:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt update
</li><li class="line" prefix="$">sudo apt install python3-pip python3-dev build-essential libssl-dev libffi-dev python3-setuptools
</li></ul></code></pre>
<p>Com esses pacotes instalados, vamos seguir em frente para criar um ambiente virtual para nosso projeto.</p>

<h2 id="passo-2-—-criando-um-ambiente-virtual-em-python">Passo 2 — Criando um Ambiente Virtual em Python</h2>

<p>Em seguida, vamos configurar um ambiente virtual para isolar nosso aplicativo Flask dos outros arquivos Python no sistema.</p>

<p>Inicie instalando o pacote <code>python3-venv</code>, que instalará o módulo <code>venv</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt install python3-venv
</li></ul></code></pre>
<p>Em seguida, vamos fazer um diretório pai para nosso projeto Flask. Acesse o diretório após criá-lo:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir ~/<span class="highlight">myproject</span>
</li><li class="line" prefix="$">cd ~/<span class="highlight">myproject</span>
</li></ul></code></pre>
<p>Crie um ambiente virtual para armazenar os requisitos Python do projeto Flask digitando:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">python3.6 -m venv <span class="highlight">myprojectenv</span>
</li></ul></code></pre>
<p>Isso instalará uma cópia local do Python e do <code>pip</code> para um diretório chamado <code><span class="highlight">myprojectenv</span></code> dentro do diretório do seu projeto.</p>

<p>Antes de instalar aplicativos no ambiente virtual, você precisa ativá-lo. Faça isso digitando:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">source <span class="highlight">myprojectenv</span>/bin/activate
</li></ul></code></pre>
<p>Seu prompt mudará para indicar que você agora está operando no ambiente virtual. Ele se parecerá com isso <code>(<span class="highlight">myprojectenv</span>)<span class="highlight">user</span>@<span class="highlight">host</span>:~/<span class="highlight">myproject</span>$</code>.</p>

<h2 id="passo-3-—-configurando-um-aplicativo-flask">Passo 3 — Configurando um aplicativo Flask</h2>

<p>Agora que você está no seu ambiente virtual, instale o Flask e a uWSGI e comece a projetar o seu aplicativo.</p>

<p>Primeiramente, vamos instalar o <code>wheel</code> com a instância local do <code>pip</code> para garantir que nossos pacotes serão instalados mesmo se estiverem faltando arquivos wheel:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">pip install wheel
</li></ul></code></pre>
<p><span class='note'><strong>Nota:</strong> Independentemente da versão de Python que você estiver usando, quando o ambiente virtual for ativado, você deverá usar o comando <code>pip</code> (não <code>pip3</code>).<br></span></p>

<p>Em seguida, vamos instalar o Flask e a uWSGI:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(myprojectenv) $">pip install uwsgi flask
</li></ul></code></pre>
<h3 id="criando-um-app-de-exemplo">Criando um App de exemplo</h3>

<p>Agora que você tem o Flask disponível, você pode criar um aplicativo simples. O Flask é um microframework. Ele não inclui muitas das ferramentas que os frameworks mais completos talvez tenham. Ele existe, principalmente, como um módulo que você pode importar para seus projetos para ajudá-lo na inicialização de um aplicativo Web.</p>

<p>Embora seu aplicativo possa ser mais complexo, vamos criar nosso app Flask em um único arquivo, chamado &ldquo;myproject.py:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(myprojectenv) $">nano ~/<span class="highlight">myproject</span>/<span class="highlight">myproject</span>.py
</li></ul></code></pre>
<p>O código do aplicativo ficará neste arquivo. Ele importará o Flask e instanciará um objeto Flask. Você pode usar isto para definir as funções que devem ser executadas quando uma rota específica for solicitada:</p>
<div class="code-label " title="~/myproject/myproject.py">~/myproject/myproject.py</div><pre class="code-pre "><code class="code-highlight language-python">from flask import Flask
app = Flask(__name__)

@app.route("/")
def hello():
    return "&lt;h1 style='color:blue'&gt;Hello There!&lt;/h1&gt;"

if __name__ == "__main__":
    app.run(host='0.0.0.0')
</code></pre>
<p>Isso define basicamente qual conteúdo apresentar quando o domínio raiz for acessado. Salve e feche o arquivo quando você terminar.</p>

<p>Se você seguiu o guia de configuração inicial do servidor, você deverá ter um firewall UFW ativado. Para testar o aplicativo, você precisa permitir o acesso à porta <code>5000</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(myprojectenv) $">sudo ufw allow 5000
</li></ul></code></pre>
<p>Agora, você pode testar seu app Flask digitando:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(myprojectenv) $">python <span class="highlight">myproject</span>.py
</li></ul></code></pre>
<p>Você verá um resultado como o seguinte, incluindo um aviso útil lembrando você para não usar essa configuração do servidor na produção:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>* Serving Flask app "myproject" (lazy loading)
 * Environment: production
   WARNING: Do not use the development server in a production environment.
   Use a production WSGI server instead.
 * Debug mode: off
 * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)
</code></pre>
<p>Visite o endereço IP do seu servidor seguido de <code>:5000</code> no seu navegador Web:</p>
<pre class="code-pre "><code langs="">http://<span class="highlight">your_server_ip</span>:5000
</code></pre>
<p>Você deve ver algo como isto:</p>

<p><img src="https://assets.digitalocean.com/articles/nginx_uwsgi_wsgi_1404/test_app.png" alt="Flask sample app"></p>

<p>Quando terminar, tecle <code>CTRL-C</code> na janela do seu terminal para parar o servidor de desenvolvimento Flask.</p>

<h3 id="criando-o-ponto-de-entrada-da-wsgi">Criando o ponto de entrada da WSGI</h3>

<p>Em seguida, vamos criar um arquivo que servirá como o ponto de entrada para nosso aplicativo. Isso dirá ao nosso servidor uWSGI como interagir com ele.</p>

<p>Vamos chamar o arquivo de <code>wsgi.py</code>:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(myprojectenv) $">nano ~/<span class="highlight">myproject</span>/wsgi.py
</li></ul></code></pre>
<p>Neste arquivo, vamos importar a instância Flask do nosso aplicativo e então executá-lo:</p>
<div class="code-label " title="~/myproject/wsgi.py">~/myproject/wsgi.py</div><pre class="code-pre "><code class="code-highlight language-python">from myproject import app

if __name__ == "__main__":
    app.run()
</code></pre>
<p>Salve e feche o arquivo quando você terminar.</p>

<h2 id="passo-4-—-configurando-a-uwsgi">Passo 4 — Configurando a uWSGI</h2>

<p>Seu aplicativo agora está gravado com um ponto de entrada estabelecido. Podemos agora seguir em frente para configurar a uWSGI.</p>

<h3 id="testando-o-atendimento-à-uwsgi">Testando o atendimento à uWSGI</h3>

<p>Vamos testar para ter certeza de que a uWSGI pode atender nosso aplicativo.</p>

<p>Podemos fazer isso simplesmente passando-lhe o nome do nosso ponto de entrada. Criamos esse ponto de entrada através do nome do módulo (menos a extensão <code>.py</code>) mais o nome do objeto callable dentro do aplicativo. No nosso caso, trata-se do <code>wsgi:app</code>.</p>

<p>Vamos também especificar o soquete, de modo que ele seja iniciado em uma interface disponível publicamente, bem como o protocolo, para que ele use o HTTP em vez do protocolo binário <code>uwsgi</code>. Vamos usar o mesmo número de porta, <code>5000</code>, que abrimos mais cedo:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(myprojectenv) $">uwsgi --socket 0.0.0.0:5000 --protocol=http -w wsgi:app
</li></ul></code></pre>
<p>Visite o endereço IP do seu servidor com <code>:5000</code> anexo ao final no seu navegador Web novamente:</p>
<pre class="code-pre "><code langs="">http://<span class="highlight">your_server_ip</span>:5000
</code></pre>
<p>Você deve ver o resultado do seu aplicativo novamente:</p>

<p><img src="https://assets.digitalocean.com/articles/nginx_uwsgi_wsgi_1404/test_app.png" alt="Flask sample app"></p>

<p>Quando você tiver confirmado que ele está funcionando corretamente, pressione <code>CTRL-C</code> na janela do seu terminal.</p>

<p>Acabamos agora o nosso ambiente virtual, para que possamos desativá-lo:</p>
<pre class="code-pre custom_prefix"><code langs=""><ul class="prefixed"><li class="line" prefix="(myprojectenv) $">deactivate
</li></ul></code></pre>
<p>Agora, qualquer comando Python voltará a usar o ambiente do sistema Python.</p>

<h3 id="criando-um-arquivo-de-configuração-da-uwsgi">Criando um arquivo de configuração da uWSGI</h3>

<p>Você testou e viu que a uWSGI pode atender o seu aplicativo. Porém, em última instância, você irá querer algo mais robusto para o uso a longo prazo. Você pode criar um arquivo de configuração da uWSGI com as opções relevantes para isso.</p>

<p>Vamos colocar aquele arquivo no diretório do nosso projeto e chamá-lo de <code>myproject.ini</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano ~/<span class="highlight">myproject</span>/<span class="highlight">myproject</span>.ini
</li></ul></code></pre>
<p>Dentro, vamos começar com o cabeçalho <code>[uwsgi]</code>, para que a uWSGI saiba aplicar as configurações. Vamos especificar duas coisas: o módulo propriamente dito, recorrendo ao arquivo <code>wsgi.py</code> (menos a extensão) e ao objeto callable dentro do arquivo, <code>app</code>:</p>
<div class="code-label " title="~/myproject/myproject.ini">~/myproject/myproject.ini</div><pre class="code-pre "><code langs="">[uwsgi]
module = wsgi:app
</code></pre>
<p>Em seguida, vamos dizer à uWSGI para iniciar em modo mestre e gerar cinco processos de trabalho para atender a pedidos reais:</p>
<div class="code-label " title="~/myproject/myproject.ini">~/myproject/myproject.ini</div><pre class="code-pre "><code langs="">[uwsgi]
module = wsgi:app

master = true
processes = 5
</code></pre>
<p>Quando você estava testando, você expôs a uWSGI em uma porta da rede. No entanto, você usará o Nginx para lidar com conexões reais do cliente, as quais então passarão as solicitações para a uWSGI. Uma vez que esses componentes estão operando no mesmo computador,é preferífel usar um soquete Unix porque ele é mais rápido e mais seguro. Vamos chamar o soquete de <code>myproject&lt;^&gt;.sock</code> e colocá-lo neste diretório.</p>

<p>Vamos alterar também as permissões no soquete. Mais tarde, iremos atribuir a propriedade do grupo Nginx sobre o processo da uWSGI. Dessa forma, precisamos assegurar que o proprietário do grupo do soquete consiga ler as informações que estão nele e gravar nele. Quando o processo parar, também limparemos o soquete, adicionando a opção <code>vacuum</code>:</p>
<div class="code-label " title="~/myproject/myproject.ini">~/myproject/myproject.ini</div><pre class="code-pre "><code langs="">[uwsgi]
module = wsgi:app

master = true
processes = 5

socket = <span class="highlight">myproject</span>.sock
chmod-socket = 660
vacuum = true
</code></pre>
<p>A última coisa que vamos fazer é definir a opção <code>die-on-term</code>. Isso pode ajudar a garantir que o sistema init e a uWSGI tenham as mesmas suposições sobre o que cada sinal de processo significa. Configurar isso alinha os dois componentes do sistema, implementando o comportamento esperado:</p>
<div class="code-label " title="~/myproject/myproject.ini">~/myproject/myproject.ini</div><pre class="code-pre "><code langs="">[uwsgi]
module = wsgi:app

master = true
processes = 5

socket = <span class="highlight">myproject</span>.sock
chmod-socket = 660
vacuum = true

die-on-term = true
</code></pre>
<p>Você pode ter notado que não especificamos um protocolo como fizemos a partir da linha de comando. Isso acontece porque, por padrão, a uWSGI fala usando o protocolo <code>uwsgi</code>, um protocolo binário rápido projetado para se comunicar com outros servidores. O Nginx pode falar este protocolo de maneira nativa, então é melhor usar isso do que forçar a comunicação pelo HTTP.</p>

<p>Quando você terminar, salve e feche o arquivo.</p>

<h2 id="passo-5-—-criando-um-arquivo-de-unidade-systemd">Passo 5 — Criando um arquivo de unidade systemd</h2>

<p>Em seguida, vamos criar o arquivo de unidade systemd. Criar um arquivo de unidade systemd permitirá que o sistema init do Ubuntu inicie automaticamente a uWSGI e atenda o aplicativo Flask sempre que o servidor for reinicializado.</p>

<p>Para começar, crie um arquivo de unidade que termine com <code>.service</code> dentro do diretório <code>/etc/systemd/system</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nano /etc/systemd/system/<span class="highlight">myproject</span>.service
</li></ul></code></pre>
<p>Ali, vamos começar com a seção <code>[Unit]</code>, que é usada para especificar os metadados e dependências. Vamos colocar uma descrição do nosso serviço aqui e dizer ao sistema init para iniciar isso somente após o objetivo da rede ter sido alcançado:</p>
<div class="code-label " title="/etc/systemd/system/myproject.service">/etc/systemd/system/myproject.service</div><pre class="code-pre "><code langs="">[Unit]
Description=uWSGI instance to serve <span class="highlight">myproject</span>
After=network.target
</code></pre>
<p>Em seguida, vamos abrir a seção <code>[Service]</code>. Isso especificará o usuário e o grupo sob o qual que queremos que o processo seja executado. Vamos dar à nossa conta de usuário regular a propriedade sobre o processo, uma vez que ela possui todos os arquivos relevantes. Vamos também dar propriedade sobre o grupo ao grupo <code>www-data</code> para que o Nginx possa se comunicar facilmente com os processos da uWSGI. Lembre-se de substituir esse nome de usuário pelo seu nome de usuário:</p>
<div class="code-label " title="/etc/systemd/system/myproject.service">/etc/systemd/system/myproject.service</div><pre class="code-pre "><code langs="">[Unit]
Description=uWSGI instance to serve <span class="highlight">myproject</span>
After=network.target

[Service]
User=<span class="highlight">sammy</span>
Group=www-data
</code></pre>
<p>Em seguida, vamos mapear o diretório de trabalho e definir a variável de ambiente <code>PATH</code> para que o sistema init saiba que os executáveis do processo estão localizados dentro do nosso ambiente virtual. Vamos também especificar o comando para iniciar o serviço. O systemd exige que seja dado o caminho completo para o executável uWSGI, que está instalado dentro do nosso ambiente virtual. Vamos passar o nome do arquivo de configuração <code>.ini</code> que criamos no nosso diretório de projeto.</p>

<p>Lembre-se de substituir o nome de usuário e os caminhos do projeto por seus próprios dados:</p>
<div class="code-label " title="/etc/systemd/system/myproject.service">/etc/systemd/system/myproject.service</div><pre class="code-pre "><code langs="">[Unit]
Description=uWSGI instance to serve <span class="highlight">myproject</span>
After=network.target

[Service]
User=<span class="highlight">sammy</span>
Group=www-data
WorkingDirectory=/home/<span class="highlight">sammy</span>/<span class="highlight">myproject</span>
Environment="PATH=/home/<span class="highlight">sammy</span>/<span class="highlight">myproject</span>/<span class="highlight">myprojectenv</span>/bin"
ExecStart=/home/<span class="highlight">sammy</span>/<span class="highlight">myproject</span>/<span class="highlight">myprojectenv</span>/bin/uwsgi --ini <span class="highlight">myproject</span>.ini
</code></pre>
<p>Finalmente, vamos adicionar uma seção <code>[Install]</code>. Isso dirá ao systemd ao que vincular este serviço se nós o habilitarmos para iniciar na inicialização. Queremos que este serviço comece quando o sistema regular de vários usuários estiver funcionando:</p>
<div class="code-label " title="/etc/systemd/system/myproject.service">/etc/systemd/system/myproject.service</div><pre class="code-pre "><code langs="">[Unit]
Description=uWSGI instance to serve <span class="highlight">myproject</span>
After=network.target

[Service]
User=<span class="highlight">sammy</span>
Group=www-data
WorkingDirectory=/home/<span class="highlight">sammy</span>/<span class="highlight">myproject</span>
Environment="PATH=/home/<span class="highlight">sammy</span>/<span class="highlight">myproject</span>/<span class="highlight">myprojectenv</span>/bin"
ExecStart=/home/<span class="highlight">sammy</span>/<span class="highlight">myproject</span>/<span class="highlight">myprojectenv</span>/bin/uwsgi --ini <span class="highlight">myproject</span>.ini

[Install]
WantedBy=multi-user.target
</code></pre>
<p>Com isso, nosso arquivo de serviço systemd está completo. Salve e feche-o agora.</p>

<p>Podemos agora iniciar o serviço uWSGI que criamos e habilitá-lo para que ele seja iniciado na inicialização:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl start <span class="highlight">myproject</span>
</li><li class="line" prefix="$">sudo systemctl enable <span class="highlight">myproject</span>
</li></ul></code></pre>
<p>Vamos verificar o status:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl status <span class="highlight">myproject</span>
</li></ul></code></pre>
<p>Você deve ver um resultado como este:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>● myproject.service - uWSGI instance to serve myproject
   Loaded: loaded (/etc/systemd/system/myproject.service; enabled; vendor preset: enabled)
   Active: <span class="highlight">active (running)</span> since Fri 2018-07-13 14:28:39 UTC; 46s ago
 Main PID: 30360 (uwsgi)
    Tasks: 6 (limit: 1153)
   CGroup: /system.slice/myproject.service
           ├─30360 /home/sammy/myproject/myprojectenv/bin/uwsgi --ini myproject.ini
           ├─30378 /home/sammy/myproject/myprojectenv/bin/uwsgi --ini myproject.ini
           ├─30379 /home/sammy/myproject/myprojectenv/bin/uwsgi --ini myproject.ini
           ├─30380 /home/sammy/myproject/myprojectenv/bin/uwsgi --ini myproject.ini
           ├─30381 /home/sammy/myproject/myprojectenv/bin/uwsgi --ini myproject.ini
           └─30382 /home/sammy/myproject/myprojectenv/bin/uwsgi --ini myproject.ini
</code></pre>
<p>Se encontrar erros, certifique-se de resolvê-los antes de continuar com o tutorial.</p>

<h2 id="passo-5-—-configurando-o-nginx-para-solicitações-de-proxy">Passo 5 — Configurando o Nginx para solicitações de proxy</h2>

<p>Nosso servidor do aplicativo uWSGI agora deverá estar funcionando, esperando pedidos no arquivo do soquete, no diretório do projeto. Vamos configurar o Nginx para passar pedidos da Web àquele soquete, usando o protocolo <code>uwsgi</code>.</p>

<p>Comece criando um novo arquivo de configuração do bloco do servidor no diretório <code>sites-available</code> do Nginx. Vamos chamá-lo de <code><span class="highlight">myproject</span></code> para mantê-lo alinhado com o resto do guia:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nano /etc/nginx/sites-available/<span class="highlight">myproject</span>
</li></ul></code></pre>
<p>Abra um bloco de servidor e diga ao Nginx para escutar na porta padrão <code>80</code>. Vamos também dizer a ele para usar este bloco para pedidos para o nome de domínio do nosso servidor:</p>
<div class="code-label " title="/etc/nginx/sites-available/myproject">/etc/nginx/sites-available/myproject</div><pre class="code-pre "><code langs="">server {
    listen 80;
    server_name <span class="highlight">your_domain</span> www.<span class="highlight">your_domain</span>;
}
</code></pre>
<p>Em seguida, vamos adicionar um bloco de localização que corresponda a cada pedido. Dentro deste bloco, vamos incluir o arquivo <code>uwsgi_params</code>, que especifica alguns parâmetros gerais da uWSGI que precisam ser configurados. Vamos então passar os pedidos para o soquete que definimos usando a diretiva <code>uwsgi_pass</code>:</p>
<div class="code-label " title="/etc/nginx/sites-available/myproject">/etc/nginx/sites-available/myproject</div><pre class="code-pre "><code langs="">server {
    listen 80;
    server_name <span class="highlight">your_domain</span> www.<span class="highlight">your_domain</span>;

    location / {
        include uwsgi_params;
        uwsgi_pass unix:/home/<span class="highlight">sammy</span>/<span class="highlight">myproject</span>/<span class="highlight">myproject</span>.sock;
    }
}
</code></pre>
<p>Salve e feche o arquivo quando você terminar.</p>

<p>Para habilitar a configuração do bloco do servidor Nginx que você acabou de criar, vincule o arquivo ao diretório <code>sites-enabled</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo ln -s /etc/nginx/sites-available/<span class="highlight">myproject</span> /etc/nginx/sites-enabled
</li></ul></code></pre>
<p>Com o arquivo naquele diretório, podemos realizar testes à procura de erros de sintaxe, digitando:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo nginx -t
</li></ul></code></pre>
<p>Se esse procedimento retornar sem indicar problemas, reinicie o processo do Nginx para ler a nova configuração:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo systemctl restart nginx
</li></ul></code></pre>
<p>Finalmente, vamos ajustar o firewall novamente. Já não precisamos de acesso através da porta <code>5000</code>, então podemos remover essa regra. Podemos então conceder acesso total ao servidor Nginx:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo ufw delete allow 5000
</li><li class="line" prefix="$">sudo ufw allow 'Nginx Full'
</li></ul></code></pre>
<p>Agora, você consegue navegar até o nome de domínio do seu servidor no seu navegador Web:</p>
<pre class="code-pre "><code langs="">http://<span class="highlight">your_domain</span>
</code></pre>
<p>Você deve ver o resultado do seu aplicativo:</p>

<p><img src="https://assets.digitalocean.com/articles/nginx_uwsgi_wsgi_1404/test_app.png" alt="Flask sample app"></p>

<p>Caso encontre quaisquer erros, tente verificar o seguinte:</p>

<ul>
<li><code>sudo less /var/log/nginx/error.log</code>: verifica os registros de erros do Nginx.</li>
<li><code>sudo less /var/log/nginx/access.log</code>: verifica os registros de acesso do Nginx.</li>
<li><code>sudo journalctl -u nginx</code>: verifica os registros de processo do Nginx.</li>
<li><code>sudo journalctl -u <span class="highlight">myproject</span></code>: verifica os registros de uWSGI do seu app Flask.</li>
</ul>

<h2 id="passo-7-—-protegendo-o-aplicativo">Passo 7 — Protegendo o aplicativo</h2>

<p>Para garantir que o tráfego para seu servidor permaneça protegido, vamos obter um certificado SSL para seu domínio. Há várias maneiras de fazer isso, incluindo a obtenção de um certificado gratuito do <a href="https://letsencrypt.org/">Let&rsquo;s Encrypt</a>, <a href="https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-nginx-in-ubuntu-18-04">gerando um certificado autoassinado</a> ou <a href="https://www.digitalocean.com/community/tutorials/how-to-install-an-ssl-certificate-from-a-commercial-certificate-authority">comprando algum de outro provedor</a> e configurando o Nginx para usá-lo, seguindo os Passos 2 a 6 de <a href="https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-nginx-in-ubuntu-18-04#step-2-%E2%80%93-configuring-nginx-to-use-ssl">Como criar um certificado SSL autoassinado para o Nginx no Ubuntu 18.04</a>. Vamos escolher a opção um por questão de conveniência.</p>

<p>Primeiramente, adicione o repositório de software Ubuntu do Certbot:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo add-apt-repository ppa:certbot/certbot
</li></ul></code></pre>
<p>Aperte <code>ENTER</code> para aceitar.</p>

<p>Em seguida, instale o pacote Nginx do Certbot com o <code>apt</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt install python-certbot-nginx
</li></ul></code></pre>
<p>O Certbot oferecer várias maneiras de obter certificados SSL através de plug-ins. O plug-in Nginx cuidará da reconfiguração do Nginx e recarregará a configuração sempre que necessário. Para usar este plug-in, digite o seguinte:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo certbot --nginx -d <span class="highlight">your_domain</span> -d www.<span class="highlight">your_domain</span>
</li></ul></code></pre>
<p>Esse comando executa o <code>certbot</code> com o plug-in <code>--nginx</code>, usando <code>-d</code> para especificar os nomes para os quais desejamos um certificado válido.</p>

<p>Se essa é a primeira vez que você executa o <code>certbot</code>, você será solicitado a informar um endereço de e-mail e concordar com os termos de serviço. Após fazer isso, o <code>certbot</code> se comunicará com o servidor da Let&rsquo;s Encrypt, executando posteriormente um desafio para verificar se você controla o domínio para o qual está solicitando um certificado.</p>

<p>Se tudo correr bem, o <code>certbot</code> perguntará como você quer definir suas configurações de HTTPS.</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Please choose whether or not to redirect HTTP traffic to HTTPS, removing HTTP access.
-------------------------------------------------------------------------------
1: No redirect - Make no further changes to the webserver configuration.
2: Redirect - Make all requests redirect to secure HTTPS access. Choose this for
new sites, or if you're confident your site works on HTTPS. You can undo this
change by editing your web server's configuration.
-------------------------------------------------------------------------------
Select the appropriate number [1-2] then [enter] (press 'c' to cancel):
</code></pre>
<p>Select your choice then hit ​​​<code>ENTER​​​​​</code>. A configuração será atualizada e o Nginx recarregará para aplicar as novas configurações. O <code>certbot</code> será encerrado com uma mensagem informando que o processo foi concluído e onde os certificados estão armazenados:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>IMPORTANT NOTES:
 - Congratulations! Your certificate and chain have been saved at:
   /etc/letsencrypt/live/<span class="highlight">your_domain</span>/fullchain.pem
   Your key file has been saved at:
   /etc/letsencrypt/live/<span class="highlight">your_domain</span>/privkey.pem
   Your cert will expire on 2018-07-23. To obtain a new or tweaked
   version of this certificate in the future, simply run certbot again
   with the "certonly" option. To non-interactively renew *all* of
   your certificates, run "certbot renew"
 - Your account credentials have been saved in your Certbot
   configuration directory at /etc/letsencrypt. You should make a
   secure backup of this folder now. This configuration directory will
   also contain certificates and private keys obtained by Certbot so
   making regular backups of this folder is ideal.
 - If you like Certbot, please consider supporting our work by:

   Donating to ISRG / Let's Encrypt:   https://letsencrypt.org/donate
   Donating to EFF:                    https://eff.org/donate-le

</code></pre>
<p>Se seguiu as instruções de instalação do Nginx nos pré-requisitos, a permissão do perfil HTTP redundante não será mais necessária:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo ufw delete allow 'Nginx HTTP'
</li></ul></code></pre>
<p>Para verificar a configuração, vamos navegar novamente até o seu domínio, usando <code>https://</code>:</p>
<pre class="code-pre "><code langs="">https://<span class="highlight">your_domain</span>
</code></pre>
<p>Você deve ver novamente o resultado do seu aplicativo, junto com o indicador de segurança do seu navegador, que deve indicar que o site está protegido.</p>

<h2 id="conclusão">Conclusão</h2>

<p>Neste guia, você criou e protegeu um aplicativo Flask simples em um ambiente virtual Python. Você criou um ponto de entrada da WSGI para que qualquer servidor de aplicativo compatível com a WSGI possa interagir com ela; depois, configurou o servidor de app uWSGI para fornecer essa função. Depois, criou um arquivo de serviço systemd para iniciar automaticamente o servidor do aplicativo na inicialização. Você também criou um bloco de servidor Nginx que passa o tráfego Web do cliente para o servidor do aplicativo - retransmitindo pedidos externos - e protegeu o tráfego para seu servidor com o Let&rsquo;s Encrypt.</p>

<p>O Flask é um framework muito simples - mas extremamente flexível, destinado a fornecer funcionalidade a seus aplicativos sem ser restritivo demais em termos de estrutura e design. Você pode usar a pilha geral descrita neste guia para atender os aplicativos flask que projetar.</p>
