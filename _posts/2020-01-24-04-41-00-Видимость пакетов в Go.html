---
layout: post
title: Видимость пакетов в Go
network: digitalocean
date: January 24, 2020 at 04:41AM
url: https://www.digitalocean.com/community/tutorials/understanding-package-visibility-in-go-ru
image: http://ifttt.com/images/no_image_card.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<h3 id="Введение">Введение</h3>

<p>При создании <a href="https://www.digitalocean.com/community/tutorials/how-to-write-packages-in-go">пакета в Go</a> конечная цель обычно заключается в том, чтобы сделать пакет доступным для других разработчиков, либо в пакетах более высокого порядка, либо в целых программах. При <a href="https://www.digitalocean.com/community/tutorials/importing-packages-in-go">импорте пакета</a> ваша часть кода может стать компонентом других более сложных инструментов. Однако для импорта доступны только определенные пакеты. Это определяется видимостью пакета.</p>

<p>В этом контексте под <em>видимостью</em> подразумевается файловое пространство, откуда можно ссылаться на пакет или другой конструкционный элемент. Например, если мы определим переменную в функции, видимость (сфера действия) этой переменной будет только внутри функции, где она определена. Если же мы определим переменную в пакете, ее можно будет сделать видимой только для этого пакета или разрешить доступ к ней из-за пределов пакета.</p>

<p>Тщательный контроль видимости пакетов важен для написания эргономичного кода, особенно если учитывать будущие изменения, которые вы можете внести в пакет. Если вам потребуется исправить ошибку, повысить производительность или изменить функционал, вам нужно будет вносить изменения так, чтобы не повредить код у тех разработчиков, кто использует ваш пакет. Чтобы минимизировать разрушающие изменения, можно разрешить доступ только к тем частям вашего пакета, которые необходимы для его правильного использования. Ограничивая доступ, вы можете вносить изменения внутри пакета. Это снизит вероятность воздействия на использование вашего пакета другими разработчиками.</p>

<p>В этой статье вы узнаете, как контролировать видимость пакетов и как защищать части вашего кода, которые должны использоваться только внутри вашего пакета. Для этого мы создадим базовый регистратор для регистрации и отладки сообщений, используя пакеты с разными уровнями видимости элементов.</p>

<h2 id="Предварительные-требования">Предварительные требования</h2>

<p>Для выполнения примеров из этой статьи вам потребуется следующее:</p>

<ul>
<li>Рабочее пространство Go, настроенное согласно <a href="https://www.digitalocean.com/community/tutorial_series/how-to-install-and-set-up-a-local-programming-environment-for-go">руководству по установке Go и настройке локальной среды для разработки</a>. В настоящем обучающем модуле будет использоваться следующая структура файлов:</li>
</ul>
<pre class="code-pre "><code langs="">.
├── bin
│
└── src
    └── github.com
        └── gopherguides
</code></pre>
<h2 id="Экспортированные-и-неэкспортированные-элементы">Экспортированные и неэкспортированные элементы</h2>

<p>В отличие от таких языков программирования, как Java и <a href="https://www.digitalocean.com/community/tutorial_series/how-to-code-in-python-3">Python</a>, где используются различные* модификаторы доступа*, декларирующие элементы как <code>public</code>, <code>private</code> или <code>protected</code>. Декларирование помогает Go определить, являются ли элементы <code>экспортированными</code> или <code>неэкспортированными</code>. В этом случае экспорт элемента делает его <code>видимым</code> за пределами текущего пакета. Если элемент не экспортирован, его можно видеть и использовать только внутри пакета, где он определен.</p>

<p>Видимость внешних элементов определяется посредством использования заглавной первой буквы декларированного элемента. Все начинающиеся с заглавной буквы элементы, в том числе <code>типы</code>, <code>переменные</code>, <code>константы</code>, <code>функции</code> и т. д., являются видимыми за пределами текущего пакета.</p>

<p>Рассмотрим следующий код, обращая особое внимание на использование заглавных букв:</p>
<div class="code-label " title="greet.go">greet.go</div><pre class="code-pre "><code langs="">package greet

import "fmt"

var <span class="highlight">G</span>reeting string

func <span class="highlight">H</span>ello(name string) string {
    return fmt.Sprintf(Greeting, name)
}
</code></pre>
<p>Этот код декларирует, что он содержится в пакете <code>greet</code>. Затем он декларирует два символа: переменную <code>Greeting</code> и функцию <code>Hello</code>. Поскольку они начинаются с заглавной буквы, они являются <code>экспортируемыми</code> и доступны любой внешней программе. Как уже говорилось выше, создание пакета с ограничением доступа позволит лучше проектировать API и упростит внутреннее обновление пакета без нарушения работы кода, зависящего от вашего пакета.</p>

<h2 id="Определение-видимости-пакета">Определение видимости пакета</h2>

<p>Чтобы лучше изучить видимость пакетов в программе, мы создадим пакет <code>logging</code>, учитывая при этом, что мы хотим сделать видимым вне пакета, а что хотим оставить невидимым. Этот пакет logging будет отвечать за регистрацию любых сообщений нашей программы на консоли. Также он будет проверять <em>уровень</em> регистрации. Уровень описывает тип журнала регистрации и будет иметь одно из трех состояний: <code>info</code>, <code>warning</code> или <code>error</code>.</p>

<p>Создайте в каталоге <code>src</code> каталог с именем <code>logging</code>, где будут размещены наши файлы регистрации:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir logging
</li></ul></code></pre>
<p>Перейдите в этот каталог:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd logging
</li></ul></code></pre>
<p>Используйте nano или другой редактор для создания файла <code>logging.go</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano logging.go
</li></ul></code></pre>
<p>Поместите следующий код в созданный нами файл <code>logging.go</code>:</p>
<div class="code-label " title="logging/logging.go">logging/logging.go</div><pre class="code-pre "><code class="code-highlight language-go">package logging

import (
    "fmt"
    "time"
)

var debug bool

func Debug(b bool) {
    debug = b
}

func Log(statement string) {
    if !debug {
        return
    }

    fmt.Printf("%s %s\n", time.Now().Format(time.RFC3339), statement)
}
</code></pre>
<p>В первой строчке этого кода декларируется пакет с именем <code>logging</code>. В этом пакете содержится две <code>экспортируемые</code> функции: <code>Debug</code> и <code>Log</code>. Эти функции сможет вызывать любой другой пакет, импортирующий пакет <code>logging</code>. Также существует private переменная с именем <code>debug</code>. Эта переменная доступна только из пакета <code>logging</code>. Важно отметить, что функция <code>Debug</code> и переменная <code>debug</code> имеют одинаковое написание, но имя функции начинается с заглавной буквы, а имя переменной — нет. Это обеспечивает отдельное декларирование с разной сферой действия.</p>

<p>Сохраните и закройте файл.</p>

<p>Чтобы использовать этот пакет в других частях нашего кода, мы можем <a href="https://www.digitalocean.com/community/tutorials/importing-packages-in-go"><code>импортировать</code> его в новый пакет</a>. Мы создадим этот новый пакет, но вначале нам потребуется новый каталог для хранения этих исходных файлов.</p>

<p>Выйдем из каталога <code>logging</code>, создадим новый каталог <code>cmd</code> и перейдем в этот новый каталог:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd ..
</li><li class="line" prefix="$">mkdir cmd
</li><li class="line" prefix="$">cd cmd
</li></ul></code></pre>
<p>Создайте файл с именем <code>main.go</code> в каталоге <code>cmd</code>, который мы только что создали:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano main.go
</li></ul></code></pre>
<p>Теперь мы можем добавить следующий код:</p>
<div class="code-label " title="cmd/main.go">cmd/main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import "github.com/gopherguides/logging"

func main() {
    logging.Debug(true)

    logging.Log("This is a debug statement...")
}
</code></pre>
<p>Теперь у нас написана вся программа. Однако перед запуском этой программы нам также потребуется создать несколько файлов конфигурации, чтобы обеспечить правильную работу нашего кода. Go использует <a href="https://blog.golang.org/using-go-modules">Go Modules</a> для настройки зависимостей пакетов при импорте ресурсов. Модули Go представляют собой файлы конфигурации в каталоге вашего пакета, которые указывают компилятору, откуда импортировать пакеты. Хотя изучение модулей не входит в состав настоящей статьи, мы можем написать несколько строк конфигурации, чтобы этот пример работал локально.</p>

<p>Откройте следующий файл <code>go.mod</code> в каталоге <code>cmd</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano go.mod
</li></ul></code></pre>
<p>Затем поместите в файл следующий код:</p>
<div class="code-label " title="go.mod">go.mod</div><pre class="code-pre "><code langs="">module github.com/gopherguides/cmd

replace github.com/gopherguides/logging =&gt; ../logging
</code></pre>
<p>Первая строчка этого файла сообщает компилятору, что пакет <code>cmd</code> имеет файловый путь <code>github.com/gopherguides/cmd</code>. Вторая строка сообщает компилятору, что каталог <code>github.com/gopherguides/logging</code> можно найти на локальном диске в каталоге <code>../logging</code>.</p>

<p>Также нам потребуется файл <code>go.mod</code> для нашего пакета <code>logging</code>. Вернемся в каталог <code>logging</code> и создадим файл <code>go.mod</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd ../logging
</li><li class="line" prefix="$">nano go.mod
</li></ul></code></pre>
<p>Добавьте в файл следующие строчки:</p>
<div class="code-label " title="go.mod">go.mod</div><pre class="code-pre "><code langs="">module github.com/gopherguides/logging
</code></pre>
<p>Это показывает компилятору, что созданный нами пакет <code>logging</code> на самом деле является пакетом <code>github.com/gopherguides/logging</code>. Это позволяет импортировать пакет в наш пакет <code>main</code>, используя следующую строчку, которую мы написали ранее:</p>
<div class="code-label " title="cmd/main.go">cmd/main.go</div><pre class="code-pre "><code langs="">package main

<span class="highlight">import "github.com/gopherguides/logging"</span>

func main() {
    logging.Debug(true)

    logging.Log("This is a debug statement...")
}
</code></pre>
<p>Теперь у вас должны быть следующая структура каталогов и расположение файлов:</p>
<pre class="code-pre "><code langs="">├── cmd
│   ├── go.mod
│   └── main.go
└── logging
    ├── go.mod
    └── logging.go
</code></pre>
<p>Мы завершили настройку и теперь можем запустить программу <code>main</code> из пакета <code>cmd</code> с помощью следующих команд:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd ../cmd
</li><li class="line" prefix="$">go run main.go
</li></ul></code></pre>
<p>Результат должен выглядеть примерно следующим образом:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div><span class="highlight">2019-08-28T11:36:09-05:00</span> This is a debug statement...
</code></pre>
<p>Программа выведет текущее время в формате RFC 3339, а затем выражение, которое мы отправили в регистратор. <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> — это формат времени, разработанный для представления времени в интернете и обычно используемый в файлах журналов.</p>

<p>Поскольку функции <code>Debug</code> и <code>Log</code> экспортированы из пакета logging, мы можем использовать их в нашем пакете <code>main</code>. Однако переменная <code>debug</code> в пакете <code>logging</code> не экспортируется. Попытка ссылки на неэкспортированную декларацию приведет к ошибке во время компиляции.</p>

<p>Добавьте следующую выделенную строку в файл <code>main.go</code>:</p>
<div class="code-label " title="cmd/main.go">cmd/main.go</div><pre class="code-pre "><code langs="">package main

import "github.com/gopherguides/logging"

func main() {
    logging.Debug(true)

    logging.Log("This is a debug statement...")

    <span class="highlight">fmt.Println(logging.debug)</span>
}
</code></pre>
<p>Сохраните и запустите файл. Вы получите примерно следующее сообщение об ошибке:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>. . .
./main.go:10:14: cannot refer to unexported name logging.debug
</code></pre>
<p>Мы увидели поведение <code>экспортированных</code> и <code>неэкспортированных</code> элементов в пакетах, а теперь посмотрим, как можно экспортировать <code>поля</code> и <code>методы</code> из <code>структур</code>.</p>

<h2 id="Видимость-в-структурах">Видимость в структурах</h2>

<p>Хотя построенная нами в предыдущем разделе схема видимости может работать для простых программ, она передает слишком много значений состояния, чтобы быть полезной в нескольких пакетах. Это связано с тем, что экспортированные переменные доступны многим пакетам, которые могут изменять переменные до конфликтующих состояний. Если разрешить подобное изменение состояния пакета, будет сложно прогнозировать поведение программы. Например, при текущей схеме один пакет может задать для переменной <code>Debug</code> значение <code>true</code>, а другой — значение <code>false</code> для того же самого экземпляра. Это создаст проблему, поскольку будет влиять на оба пакета, импортирующих пакет <code>logging</code>.</p>

<p>Мы можем изолировать регистратор, создав структуру и передав ей методы. Это позволит нам создавать <code>экземпляр</code> регистратора, который будет использоваться независимо в каждом пакете.</p>

<p>Замените пакет <code>logging</code> на следующее, чтобы исправить код и изолировать регистратор:</p>
<div class="code-label " title="logging/logging.go">logging/logging.go</div><pre class="code-pre "><code class="code-highlight language-go">package logging

import (
    "fmt"
    "time"
)

type Logger struct {
    timeFormat string
    debug      bool
}

func New(timeFormat string, debug bool) *Logger {
    return &amp;Logger{
        timeFormat: timeFormat,
        debug:      debug,
    }
}

func (l *Logger) Log(s string) {
    if !l.debug {
        return
    }
    fmt.Printf("%s %s\n", time.Now().Format(l.timeFormat), s)
}
</code></pre>
<p>В этом коде мы создали структуру <code>Logger</code>. В этой структуре будет размещено неэкспортированное состояние, включая формат времени для вывода и значение переменной <code>debug</code> — <code>true</code> или <code>false</code>. Функция <code>New</code> задает начальное состояние для создания регистратора, в частности формат времени и статус отладки. Она сохранит присвоенные внутренние значения в неэкспортированные переменные <code>timeFormat</code> и <code>debug</code>. Также мы создали метод <code>Log</code> типа <code>Logger</code>, который принимает выражение, которое мы хотим вывести. В методе <code>Log</code> содержится ссылка на переменную локального метода <code>l</code> для получения доступа к таким его внутренним полям, как <code>l.timeFormat</code> и <code>l.debug</code>.</p>

<p>Этот подход позволит нам создавать <code>Logger</code> в разных пакетах и использовать его независимо от его использования другими пакетами.</p>

<p>Чтобы использовать его в другом пакете, изменим <code>cmd/main.go</code> следующим образом:</p>
<div class="code-label " title="cmd/main.go">cmd/main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import (
    "time"

    "github.com/gopherguides/logging"
)

func main() {
    logger := logging.New(time.RFC3339, true)

    logger.Log("This is a debug statement...")
}
</code></pre>
<p>При запуске этой программы будут выведены следующие результаты:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div><span class="highlight">2019-08-28T11:56:49-05:00</span> This is a debug statement...
</code></pre>
<p>В этом коде мы создали экземпляр регистратора, вызвав экспортированную функцию <code>New</code>. Мы сохранили ссылку на этот экземпляр в переменной <code>logger</code>. Теперь мы можем вызывать <code>logging.Log</code> для вывода выражений.</p>

<p>Если мы попытаемся сослаться на неэкспортированное поле из <code>Logger</code>, например, на поле <code>timeFormat</code>, при компиляции будет выведена ошибка. Попробуйте добавить следующую выделенную строку и запустить <code>cmd/main.go</code>:</p>
<div class="code-label " title="cmd/main.go">cmd/main.go</div><pre class="code-pre "><code langs="">
package main

import (
    "time"

    "github.com/gopherguides/logging"
)

func main() {
    logger := logging.New(time.RFC3339, true)

    logger.Log("This is a debug statement...")

    <span class="highlight">fmt.Println(logger.timeFormat)</span>
}
</code></pre>
<p>Будет выведено следующее сообщение об ошибке:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>. . .
cmd/main.go:14:20: logger.timeFormat undefined (cannot refer to unexported field or method timeFormat)
</code></pre>
<p>Компилятор определяет, что <code>logger.timeFormat</code> не экспортируется, и поэтому не может быть получен из пакета <code>logging</code>.</p>

<h2 id="Видимость-в-методах">Видимость в методах</h2>

<p>Методы, как и поля структуры, могут быть экспортируемыми или неэкспортируемыми.</p>

<p>Для иллюстрации добавим в наш регистратор <em>многоуровневую</em> регистрацию. Многоуровневая регистрация — это способ разделения журналов регистрации на категории, позволяющий искать в журналах определенные типы событий. В нашем регистраторе мы используем следующие уровни:</p>

<ul>
<li><p>Уровень <code>info</code>, представляющий события информационного типа, сообщающие пользователю о действии, например, <code>Program started</code> или <code>Email sent</code>. Они помогают выполнять отладку и отслеживать части программы, чтобы определять ожидаемое поведение.</p></li>
<li><p>Уровень <code>warning</code>. Эти события определяют непредвиденные события, которые не представляют собой ошибку, например, <code>Email failed to send, retrying</code>. Они помогают понять, какие части программы работают не так хорошо, как мы ожидали.</p></li>
<li><p>Уровень <code>error</code>, означающий, что в программе возникла проблема, например, <code>File not found</code>. Часто это вызывает прекращение работы программы.</p></li>
</ul>

<p>Вы можете включать и отключать определенные уровни регистрации, особенно если ваша программа не работает ожидаемым образом, и вы хотите провести ее отладку. Мы добавим эту функцию, изменив программу так, что при установке для <code>debug</code> значения <code>true</code> будут выводиться все уровни сообщений. При значении <code>false</code> будут выводиться только сообщения об ошибках.</p>

<p>Для добавления многоуровневой регистрации нужно внести следующие изменения в файл <code>logging/logging.go</code>:</p>
<div class="code-label " title="logging/logging.go">logging/logging.go</div><pre class="code-pre "><code class="code-highlight language-go">
package logging

import (
    "fmt"
    "strings"
    "time"
)

type Logger struct {
    timeFormat string
    debug      bool
}

func New(timeFormat string, debug bool) *Logger {
    return &amp;Logger{
        timeFormat: timeFormat,
        debug:      debug,
    }
}

func (l *Logger) Log(level string, s string) {
    level = strings.ToLower(level)
    switch level {
    case "info", "warning":
        if l.debug {
            l.write(level, s)
        }
    default:
        l.write(level, s)
    }
}

func (l *Logger) write(level string, s string) {
    fmt.Printf("[%s] %s %s\n", level, time.Now().Format(l.timeFormat), s)
}
</code></pre>
<p>В этом примере мы ввели новый аргумент для метода <code>Log</code>. Теперь мы можем передать <code>уровень</code> сообщения журнала. Метод <code>Log</code> определяет уровень сообщения. Если это сообщение типа <code>info</code> или <code>warning</code>, и если поле <code>debug</code> имеет значение <code>true</code>, выполняется запись сообщения. В противном случае, сообщение игнорируется. Если это сообщение любого другого уровня, например, <code>error</code>, оно будет выведено в любом случае.</p>

<p>Основная логика определения необходимости вывода сообщения содержится в методе <code>Log.</code> Также мы представили неэкспортированный метод с именем <code>write</code>. Метод <code>write</code> фактически выполняет вывод сообщения журнала.</p>

<p>Теперь мы можем использовать многоуровневую регистрацию в другом пакете, изменив <code>cmd/main.go</code> следующим образом:</p>
<div class="code-label " title="cmd/main.go">cmd/main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import (
    "time"

    "github.com/gopherguides/logging"
)

func main() {
    logger := logging.New(time.RFC3339, true)

    logger.Log("info", "starting up service")
    logger.Log("warning", "no tasks found")
    logger.Log("error", "exiting: no work performed")

}
</code></pre>
<p>При запуске вы увидите следующее:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>[info] <span class="highlight">2019-09-23T20:53:38Z</span> starting up service
[warning] <span class="highlight">2019-09-23T20:53:38Z</span> no tasks found
[error] <span class="highlight">2019-09-23T20:53:38Z</span> exiting: no work performed
</code></pre>
<p>В этом примере <code>cmd/main.go</code> успешно использует экспортированный метод <code>Log</code>.</p>

<p>Мы можем передать <code>уровень</code> каждого сообщения, изменив значение <code>debug</code> на <code>false</code>:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import (
    "time"

    "github.com/gopherguides/logging"
)

func main() {
    logger := logging.New(time.RFC3339, <span class="highlight">false</span>)

    logger.Log("info", "starting up service")
    logger.Log("warning", "no tasks found")
    logger.Log("error", "exiting: no work performed")

}
</code></pre>
<p>Теперь мы видим, что выводятся только сообщения уровня <code>error</code>:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>[error] <span class="highlight">2019-08-28T13:58:52-05:00</span> exiting: no work performed
</code></pre>
<p>Если мы попытаемся вызвать метод <code>write</code> из-за пределов пакета <code>logging</code>, мы получим ошибку компиляции:</p>
<div class="code-label " title="main.go">main.go</div><pre class="code-pre "><code langs="">package main

import (
    "time"

    "github.com/gopherguides/logging"
)

func main() {
    logger := logging.New(time.RFC3339, true)

    logger.Log("info", "starting up service")
    logger.Log("warning", "no tasks found")
    logger.Log("error", "exiting: no work performed")

    <span class="highlight">logger.write("error", "log this message...")</span>
}
</code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>cmd/main.go:16:8: logger.write undefined (cannot refer to unexported field or method logging.(*Logger).write)
</code></pre>
<p>Когда компилятор видит, что вы пытаетесь оставить ссылку на элемент другого пакета, имя которого начинается со строчной буквы, он понимает, что это неэкспортированный элемент, и выводит сообщение об ошибке.</p>

<p>Регистратор в этом обучающем руководстве показывает, как написать код, открывающий другим пакетам только те части, которые требуются. Поскольку мы контролируем, какие части пакета видимы за пределами пакета, мы можем вносить будущие изменения без воздействия на код, зависящий от нашего пакета. Например, если бы мы хотели только отключить сообщения уровня <code>info</code>, когда <code>debug</code> имеет значение false, мы могли бы провести это изменение без воздействия на любую другую часть вашего API. Мы также могли безопасно вносить изменения в сообщения журнала, добавляя дополнительную информацию, такую как каталог, откуда запускается программа.</p>

<h2 id="Заключение">Заключение</h2>

<p>В этой статье мы рассказали, как использовать в пакетах общий код и при этом защитить детали реализации конкретных пакетов. Это позволяет экспортировать простые API, которые редко изменяются для обеспечения обратной совместимости, но позволяют вносить в пакет необходимые изменения для улучшения их работы. Это считается лучшей практикой при создании пакетов и их API.</p>

<p>Дополнительную информацию о пакетах в Go можно найти в статьях <a href="https://www.digitalocean.com/community/tutorials/importing-packages-in-go">Импорт пакетов в Go</a> и <a href="https://www.digitalocean.com/community/tutorials/how-to-write-packages-in-go">Написание пакетов в Go</a>, а также в других статьях <a href="https://www.digitalocean.com/community/tutorial_series/how-to-code-in-go">серии по программированию на Go</a>.</p>
