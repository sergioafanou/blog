---
layout: post
title: Como Fazer o Deploy de uma Aplicação Go Resiliente no Kubernetes da DigitalOcean
network: digitalocean
date: July 22, 2019 at 08:29PM
url: https://www.digitalocean.com/community/tutorials/como-fazer-o-deploy-de-uma-aplicacao-go-resiliente-no-kubernetes-da-digitalocean-pt
image: https://assets.digitalocean.com/articles/resilient_go_kubernetes/resilient_screenshot_1.png
tags: docker
feedtitle: DigitalOcean Community Tutorials
feedurl: https://www.digitalocean.com/community/tutorials
author: DigitalOcean
---
<p><em>O autor escolheu o <a href="https://www.brightfunds.org/organizations/girls-who-code">Girls Who Code</a> para receber uma doação como parte do programa <a href="https://do.co/w4do-cta">Write for DOnations</a>.</em></p>

<h3 id="introdução">Introdução</h3>

<p>O <a href="https://www.docker.com/">Docker</a> é uma ferramenta de <a href="https://en.wikipedia.org/wiki/OS-level_virtualisation">containerização</a> utilizada para fornecer às aplicações um sistema de arquivos que armazena tudo o que eles precisam para executar, garantindo que o software tenha um ambiente de runtime consistente e se comporte da mesma maneira, independentemente de onde esteja implantado ou <em>deployado</em>. O <a href="https://kubernetes.io/">Kubernetes</a> é uma plataforma em nuvem para automatizar o deployment, a escalabilidade e o gerenciamento de aplicações containerizadas.</p>

<p>Ao aproveitar o Docker, você pode fazer o deploy de uma aplicação em qualquer sistema que ofereça suporte ao Docker com a confiança de que ele sempre funcionará conforme o esperado. O Kubernetes, por sua vez, permite que você faça o deploy de sua aplicação em vários nodes em um cluster. Além disso, ele lida com as principais tarefas, como lançar novos containers em caso de queda de qualquer um dos seus containers. Juntas, essas ferramentas simplificam o processo de deployment de uma aplicação, permitindo que você se concentre no desenvolvimento.</p>

<p>Neste tutorial, você vai criar uma aplicação de exemplo escrita em <a href="https://golang.org/">Go</a> e a colocará em funcionamento localmente em sua máquina de desenvolvimento. Em seguida, você irá containerizar a aplicação com o Docker, fazer o deploy em um cluster Kubernetes e vai criar um balanceador de carga que servirá como ponto de entrada voltado ao público para a sua aplicação.</p>

<h2 id="pré-requisitos">Pré-requisitos</h2>

<p>Antes de começar este tutorial, você precisará do seguinte:</p>

<ul>
<li>Um servidor de desenvolvimento ou máquina local a partir da qual você fará o deploy da aplicação. Embora as instruções deste guia funcionem em grande parte para a maioria dos sistemas operacionais, este tutorial pressupõe que você tenha acesso a um sistema Ubuntu 18.04 configurado com um usuário não-root com privilégios sudo, conforme descrito em nosso tutorial <a href="https://www.digitalocean.com/community/tutorials/configuracao-inicial-de-servidor-com-ubuntu-18-04-pt">Configuração Inicial de servidor com Ubuntu 18.04</a>.</li>
<li>A ferramenta de linha de comando <code>docker</code> instalada em sua máquina de desenvolvimento. Para instalar isto, siga os <strong>Passos 1 e 2</strong> do nosso tutorial sobre <a href="https://www.digitalocean.com/community/tutorials/como-instalar-e-usar-o-docker-no-ubuntu-18-04-pt">Como Instalar e Usar o Docker no Ubuntu 18.04</a>.</li>
<li>A ferramenta de linha de comando <code>kubectl</code> instalada em sua máquina de desenvolvimento. Para instalá-la, siga <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl-on-linux">este guia da documentação oficial do Kubernetes</a>.</li>
<li>Uma conta gratuita no Docker Hub para a qual você enviará sua imagem do Docker. Para configurar isso, visite o <a href="https://hub.docker.com/">website do Docker Hub</a>, clique no botão <strong>Get Started</strong> no canto superior direito da página e siga as instruções de registro.</li>
<li>Um cluster Kubernetes. Você pode provisionar um <a href="https://www.digitalocean.com/products/kubernetes/">cluster Kubernetes na DigitalOcean</a> seguindo nosso <a href="https://www.digitalocean.com/docs/kubernetes/quickstart/">Guia de início rápido do Kubernetes</a>. Você ainda pode concluir este tutorial se provisionar seu cluster em outro provedor de nuvem. Sempre que você adquirir seu cluster, certifique-se de definir um arquivo de configuração e garantir que você possa se conectar ao cluster a partir do seu servidor de desenvolvimento.</li>
</ul>

<h2 id="passo-1-—-criando-uma-aplicação-web-de-exemplo-em-go">Passo 1 — Criando uma Aplicação Web de Exemplo em Go</h2>

<p>Nesta etapa, você criará uma aplicação de exemplo escrita em Go. Após containerizar este app com o Docker, ele servirá <code>My Awesome Go App</code> em resposta a solicitações para o endereço IP do seu servidor na porta <code>3000</code>.</p>

<p>Comece atualizando as listas de pacotes do seu servidor, se você não tiver feito isso recentemente:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt update
</li></ul></code></pre>
<p>Em seguida, instale o Go executando:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">sudo apt install golang
</li></ul></code></pre>
<p>Depois, verifique se você está em seu diretório home e crie um novo diretório que vai conter todos os seus arquivos do projeto:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd &amp;&amp; mkdir go-app
</li></ul></code></pre>
<p>Em seguida, navegue até este novo diretório:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">cd go-app/
</li></ul></code></pre>
<p>Use o <code>nano</code> ou seu editor de texto preferido para criar um arquivo chamado <code>main.go</code>, que conterá o código da sua aplicação Go:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano main.go
</li></ul></code></pre>
<p>A primeira linha em qualquer arquivo-fonte do Go é sempre uma instrução <code>package</code> que define a qual pacote de código o arquivo pertence. Para arquivos executáveis como este, a declaração <code>package</code> deve apontar para o pacote <code>main</code>:</p>
<div class="code-label " title="go-app/main.go">go-app/main.go</div><pre class="code-pre "><code class="code-highlight language-go"><span class="highlight">package main</span>
</code></pre>
<p>Depois disso, adicione uma instrução <code>import</code> onde você pode listar todas as bibliotecas que a aplicação precisará. Aqui, inclua <code>fmt</code>, que lida com entrada e saída de texto formatada, e <code>net/http</code>, que fornece implementações de cliente e servidor HTTP:</p>
<div class="code-label " title="go-app/main.go">go-app/main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

<span class="highlight">import (</span>
  <span class="highlight">"fmt"</span>
  <span class="highlight">"net/http"</span>
<span class="highlight">)</span>
</code></pre>
<p>Em seguida, defina uma função <code>homePage</code> que terá dois argumentos: <code>http.ResponseWriter</code> e um ponteiro para <code>http.Request</code>. Em Go, uma interface <code>ResponseWriter</code> é usada para construir uma resposta HTTP, enquanto <code>http.Request</code> é um objeto que representa uma solicitação de entrada. Assim, este bloco lê solicitações HTTP de entrada e, em seguida, constrói uma resposta:</p>
<div class="code-label " title="go-app/main.go">go-app/main.go</div><pre class="code-pre "><code class="code-highlight language-go">. . .

import (
  "fmt"
  "net/http"
)

<span class="highlight">func homePage(w http.ResponseWriter, r *http.Request) {</span>
  <span class="highlight">fmt.Fprintf(w, "My Awesome Go App")</span>
<span class="highlight">}</span>
</code></pre>
<p>Depois disso, adicione uma função <code>setupRoutes</code> que mapeará as solicitações de entrada para as funções planejadas do handler HTTP. No corpo desta função <code>setupRoutes</code>, adicione um mapeamento da rota <code>/</code> para sua função <code>homePage</code> recém-definida. Isso diz à aplicação para imprimir a mensagem <code>My Awesome Go App</code> mesmo para solicitações feitas a endpoints desconhecidos:</p>
<div class="code-label " title="go-app/main.go">go-app/main.go</div><pre class="code-pre "><code class="code-highlight language-go">. . .

func homePage(w http.ResponseWriter, r *http.Request) {
  fmt.Fprintf(w, "My Awesome Go App")
}

<span class="highlight">func setupRoutes() {</span>
  <span class="highlight">http.HandleFunc("/", homePage)</span>
<span class="highlight">}</span>
</code></pre>
<p>E finalmente, adicione a seguinte função <code>main</code>. Isso imprimirá uma string indicando que sua aplicação foi iniciada. Ela então chamará a função <code>setupRoutes</code> antes de começar a ouvir e servir sua aplicação Go na porta <code>3000</code>.</p>
<div class="code-label " title="go-app/main.go">go-app/main.go</div><pre class="code-pre "><code class="code-highlight language-go">. . .

func setupRoutes() {
  http.HandleFunc("/", homePage)
}

<span class="highlight">func main() {</span>
  <span class="highlight">fmt.Println("Go Web App Started on Port 3000")</span>
  <span class="highlight">setupRoutes()</span>
  <span class="highlight">http.ListenAndServe(":3000", nil)</span>
<span class="highlight">}</span>
</code></pre>
<p>Após adicionar essas linhas, é assim que o arquivo final ficará:</p>
<div class="code-label " title="go-app/main.go">go-app/main.go</div><pre class="code-pre "><code class="code-highlight language-go">package main

import (
  "fmt"
  "net/http"
)

func homePage(w http.ResponseWriter, r *http.Request) {
  fmt.Fprintf(w, "My Awesome Go App")
}

func setupRoutes() {
  http.HandleFunc("/", homePage)
}

func main() {
  fmt.Println("Go Web App Started on Port 3000")
  setupRoutes()
  http.ListenAndServe(":3000", nil)
}
</code></pre>
<p>Salve e feche este arquivo. Se você criou este arquivo usando <code>nano</code>, faça-o pressionando <code>CTRL + X</code>, <code>Y</code>, depois <code>ENTER</code>.</p>

<p>Em seguida, execute a aplicação usando o seguinte comando <code>go run</code>. Isto irá compilar o código no seu arquivo <code>main.go</code> e irá executá-lo localmente em sua máquina de desenvolvimento:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">go run main.go
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Go Web App Started on Port 3000
</code></pre>
<p>Esta saída confirma que a aplicação está funcionando conforme o esperado. Ela será executada indefinidamente, entretanto, feche-a pressionando <code>CTRL + C</code>.</p>

<p>Ao longo deste guia, você usará essa aplicação de exemplo para experimentar com o Docker e o Kubernetes. Para esse fim, continue lendo para saber como containerizar sua aplicação com o Docker.</p>

<h2 id="passo-2-—-dockerizando-sua-aplicação-go">Passo 2 — Dockerizando sua Aplicação Go</h2>

<p>Em seu estado atual, a aplicação Go que você acabou de criar está sendo executada apenas em seu servidor de desenvolvimento. Nesta etapa, você tornará essa nova aplicação portátil ao containerizá-la com o Docker. Isso permitirá que ela seja executada em qualquer máquina que ofereça suporte a containers Docker. Você irá criar uma imagem do Docker e a enviará para um repositório público central no Docker Hub. Dessa forma, seu cluster Kubernetes pode baixar a imagem de volta e fazer o deployment dela como um container dentro do cluster.</p>

<p>O primeiro passo para a containerização de sua aplicação é criar um script especial chamado de <a href="https://docs.docker.com/search/?q=dockerfile"><em>Dockerfile</em></a>. Um Dockerfile geralmente contém uma lista de instruções e argumentos que são executados em ordem sequencial para executar automaticamente determinadas ações em uma imagem base ou criar uma nova.</p>

<p><span class='note'><strong>Nota:</strong> Nesta etapa, você vai configurar um container Docker simples que criará e executará sua aplicação Go em um único estágio. Se, no futuro, você quiser reduzir o tamanho do container onde suas aplicações Go serão executadas em produção, talvez seja interessante dar uma olhada no <a href="https://docs.docker.com/develop/develop-images/multistage-build/"><em>mutli-stage builds</em></a> ou compilação em múltiplos estágios.<br></span></p>

<p>Crie um novo arquivo chamado <code>Dockerfile</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano Dockerfile
</li></ul></code></pre>
<p>Na parte superior do arquivo, especifique a imagem base necessária para a aplicação Go:</p>
<div class="code-label " title="go-app/Dockerfile">go-app/Dockerfile</div><pre class="code-pre "><code langs=""><span class="highlight">FROM golang:1.12.0-alpine3.9</span>
</code></pre>
<p>Em seguida, crie um diretório <code>app</code> dentro do container que vai conter os arquivos-fonte da aplicação:</p>
<div class="code-label " title="go-app/Dockerfile">go-app/Dockerfile</div><pre class="code-pre "><code langs="">FROM golang:1.12.0-alpine3.9
<span class="highlight">RUN mkdir /app</span>
</code></pre>
<p>Abaixo disso, adicione a seguinte linha que copia tudo no diretório <code>raiz</code> dentro do diretório <code>app</code>:</p>
<div class="code-label " title="go-app/Dockerfile">go-app/Dockerfile</div><pre class="code-pre "><code langs="">FROM golang:1.12.0-alpine3.9
RUN mkdir /app
<span class="highlight">ADD . /app</span>
</code></pre>
<p>Em seguida, adicione a seguinte linha que altera o diretório de trabalho para <code>app</code>, significando que todos os comandos a seguir neste Dockerfile serão executados a partir desse local:</p>
<div class="code-label " title="go-app/Dockerfile">go-app/Dockerfile</div><pre class="code-pre "><code langs="">FROM golang:1.12.0-alpine3.9
RUN mkdir /app
ADD . /app
<span class="highlight">WORKDIR /app</span>
</code></pre>
<p>Adicione uma linha instruindo o Docker a executar o comando <code>go build -o main</code>, que compila o executável binário da aplicação Go:</p>
<div class="code-label " title="go-app/Dockerfile">go-app/Dockerfile</div><pre class="code-pre "><code langs="">FROM golang:1.12.0-alpine3.9
RUN mkdir /app
ADD . /app
WORKDIR /app
<span class="highlight">RUN go build -o main .</span>
</code></pre>
<p>Em seguida, adicione a linha final, que irá rodar o executável binário:</p>
<div class="code-label " title="go-app/Dockerfile">go-app/Dockerfile</div><pre class="code-pre "><code langs="">FROM golang:1.12.0-alpine3.9
RUN mkdir /app
ADD . /app
WORKDIR /app
RUN go build -o main .
<span class="highlight">CMD ["/app/main"]</span>
</code></pre>
<p>Salve e feche o arquivo depois de adicionar essas linhas.</p>

<p>Agora que você tem esse <code>Dockerfile</code> na raiz do seu projeto, você pode criar uma imagem Docker baseada nele usando o seguinte comando <code>docker build</code>. Este comando inclui a flag <code>-t</code> que, quando passado o valor <code>go-web-app</code>, nomeará a imagem Docker como <code>go-web-app</code> e irá marcar ou colocar uma <em>tag</em> nela.</p>

<span class='note'><p>
<strong>Nota</strong>: No Docker, as tags permitem que você transmita informações específicas para uma determinada imagem, como o seu número de versão. O comando a seguir não fornece uma tag específica, portanto, o Docker marcará a imagem com sua tag padrão: <code>latest</code>. Se você quiser atribuir uma tag personalizada a uma imagem, você adicionaria o nome da imagem com dois pontos e a tag de sua escolha, assim:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker build -t <span class="highlight">sammy</span>/<span class="highlight">nome_da_imagem</span>:<span class="highlight">nome_da_tag</span> .
</li></ul></code></pre>
<p>Marcar ou "taggear" uma imagem como essa pode lhe dar maior controle sobre suas imagens. Por exemplo, você poderia fazer o deploy de uma imagem marcada como <code>v1.1</code> em produção, mas fazer o deploy de outra marcada como <code>v1.2</code> em seu ambiente de pré-produção ou teste.<br></p></span>

<p>O argumento final que você vai passar é o caminho: <code>.</code>. Isso especifica que você deseja criar a imagem Docker a partir do conteúdo do diretório de trabalho atual. Além disso, certifique-se de atualizar <code><span class="highlight">sammy</span></code> para o seu nome de usuário do Docker Hub:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker build -t <span class="highlight">sammy</span>/go-web-app .
</li></ul></code></pre>
<p>Este comando de compilação vai ler todas as linhas do seu <code>Dockerfile</code>, executá-las em ordem e armazenará em cache, permitindo que futuras compilações sejam executadas muito mais rapidamente:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>. . .
Successfully built <span class="highlight">521679ff78e5</span>
Successfully tagged go-web-app:latest
</code></pre>
<p>Quando este comando terminar a compilação, você poderá ver sua imagem quando executar o comando <code>docker images</code> da seguinte forma:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker images
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE
<span class="highlight">sammy</span>/go-web-app   latest              <span class="highlight">4ee6cf7a8ab4</span>        3 seconds ago       355MB
</code></pre>
<p>Em seguida, use o seguinte comando para criar e iniciar um container com base na imagem que você acabou de criar. Este comando inclui a flag <code>-it</code>, que especifica que o container será executado no modo interativo. Ele também possui a flag <code>-p</code> que mapeia a porta na qual a aplicação Go está sendo executada em sua máquina de desenvolvimento  — porta <code>3000</code> — para  a porta <code>3000</code> em seu container Docker.</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker run -it -p 3000:3000 <span class="highlight">sammy</span>/go-web-app
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>Go Web App Started on Port 3000
</code></pre>
<p>Se não houver mais nada em execução nessa porta, você poderá ver a aplicação em ação abrindo um navegador e navegando até a seguinte URL:</p>
<pre class="code-pre "><code langs="">http://<span class="highlight">ip_do_seu_servidor</span>:3000
</code></pre>
<span class='note'><p>
<strong>Nota:</strong> Se você estiver seguindo este tutorial em sua máquina local em vez de um servidor, visite a aplicação acessando a seguinte URL:</p>
<pre class="code-pre "><code langs="">http://localhost:3000
</code></pre>
<p></p></span>

<p><img src="https://assets.digitalocean.com/articles/resilient_go_kubernetes/resilient_screenshot_1.png" alt="Your containerized Go App"></p>

<p>Depois de verificar se a aplicação funciona como esperado no seu navegador, finalize-a pressionando <code>CTRL + C</code> no seu terminal.</p>

<p>Quando você faz o deploy de sua aplicação containerizada em seu cluster Kubernetes, você vai precisar conseguir extrair a imagem de um local centralizado. Para esse fim, você pode enviar sua imagem recém-criada para o repositório de imagens do Docker Hub.</p>

<p>Execute o seguinte comando para efetuar login no Docker Hub a partir do seu terminal:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker login
</li></ul></code></pre>
<p>Isso solicitará seu nome de usuário e sua senha do Docker Hub. Depois de inseri-los corretamente, você verá <code>Login Succeeded</code> na saída do comando.</p>

<p>Após o login, envie sua nova imagem para o Docker Hub usando o comando <code>docker push</code>, assim:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">docker push <span class="highlight">sammy</span>/go-web-app
</li></ul></code></pre>
<p>Quando esse comando for concluído com êxito, você poderá abrir sua conta do Docker Hub e ver sua imagem do Docker lá.</p>

<p>Agora que você enviou sua imagem para um local central, está pronto para fazer o seu deployment em seu cluster do Kubernetes. Primeiro, porém, vamos tratar de um breve processo que tornará muito menos tedioso executar comandos <code>kubectl</code>.</p>

<h2 id="passo-3-—-melhorando-a-usabilidade-para-o-kubectl">Passo 3 — Melhorando a Usabilidade para o <code>kubectl</code></h2>

<p>Nesse ponto, você criou uma aplicação Go funcional e fez a containerização dela com o Docker. No entanto, a aplicação ainda não está acessível publicamente. Para resolver isso, você fará o deploy de sua nova imagem Docker em seu cluster Kubernetes usando a ferramenta de linha de comando <code>kubectl</code>. Antes de fazer isso, vamos fazer uma pequena alteração no arquivo de configuração do Kubernetes que o ajudará a tornar a execução de comandos <code>kubectl</code> menos trabalhosa.</p>

<p>Por padrão, quando você executa comandos com a ferramenta de linha de comando <code>kubectl</code>, você deve especificar o caminho do arquivo de configuração do cluster usando a flag <code>--kubeconfig</code>. No entanto, se o seu arquivo de configuração é chamado <code>config</code> e está armazenado em um diretório chamado <code>~/.kube</code>, o <code>kubectl</code> saberá onde procurar pelo arquivo de configuração e poderá obtê-lo sem a flag <code>--kubeconfig</code> apontando para ele.</p>

<p>Para esse fim, se você ainda não tiver feito isso, crie um novo diretório chamado <code>~/.kube</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mkdir ~/.kube
</li></ul></code></pre>
<p>Em seguida, mova o arquivo de configuração do cluster para este diretório e renomeie-o como <code>config</code> no processo:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">mv <span class="highlight">clusterconfig</span>.yaml ~/.kube/config
</li></ul></code></pre>
<p>Seguindo em frente, você não precisará especificar a localização do arquivo de configuração do seu cluster quando executar o <code>kubectl</code>, pois o comando poderá encontrá-lo agora que está no local padrão. Teste esse comportamento executando o seguinte comando <code>get nodes</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get nodes
</li></ul></code></pre>
<p>Isso exibirá todos os <em>nodes</em> que residem em seu cluster Kubernetes. No contexto do Kubernetes, um node é um servidor ou uma máquina de trabalho na qual pode-se fazer o deployment de um ou mais pods:</p>
<pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME                                        STATUS    ROLES     AGE       VERSION
k8s-1-13-5-do-0-nyc1-1554148094743-1-7lfd   Ready     &lt;none&gt;    1m        v1.13.5
k8s-1-13-5-do-0-nyc1-1554148094743-1-7lfi   Ready     &lt;none&gt;    1m        v1.13.5
k8s-1-13-5-do-0-nyc1-1554148094743-1-7lfv   Ready     &lt;none&gt;    1m        v1.13.5
</code></pre>
<p>Com isso, você está pronto para continuar e fazer o deploy da sua aplicação em seu cluster Kubernetes. Você fará isso criando dois objetos do Kubernetes: um que fará o deploy da aplicação em alguns pods no cluster e outro que criará um balanceador de carga, fornecendo um ponto de acesso à sua aplicação.</p>

<h2 id="passo-4-—-criando-um-deployment">Passo 4 — Criando um Deployment</h2>

<p><a href="https://en.wikipedia.org/wiki/Representational_state_transfer">Recursos RESTful</a> compõem todas as entidades persistentes dentro de um sistema Kubernetes, e neste contexto elas são comumente chamadas de <em>Kubernetes objects</em>. É útil pensar nos objetos do Kubernetes como as ordens de trabalho que você envia ao Kubernetes: você lista quais recursos você precisa e como eles devem funcionar, e então o Kubernetes trabalhará constantemente para garantir que eles existam em seu cluster.</p>

<p>Um tipo de objeto do Kubernetes, conhecido como <em>deployment</em>, é um conjunto de pods idênticos e indistinguíveis. No Kubernetes, um <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/"><em>pod</em></a> é um agrupamento de um ou mais containers que podem se comunicar pela mesma rede compartilhada e interagir com o mesmo armazenamento compartilhado. Um deployment executa mais de uma réplica da aplicação pai de cada vez e substitui automaticamente todas as instâncias que falham, garantindo que a aplicação esteja sempre disponível para atender às solicitações do usuário.</p>

<p>Nesta etapa, você criará um arquivo de descrição de objetos do Kubernetes, também conhecido como <em>manifest</em>, para um deployment. Esse manifest conterá todos os detalhes de configuração necessários para fazer o deploy da sua aplicação Go em seu cluster.</p>

<p>Comece criando um manifest de deployment no diretório raiz do seu projeto: <code>go-app/</code>. Para projetos pequenos como este, mantê-los no diretório raiz minimiza a complexidade. Para projetos maiores, no entanto, pode ser benéfico armazenar seus manifests em um subdiretório separado para manter tudo organizado.</p>

<p>Crie um novo arquivo chamado <code>deployment.yml</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano deployment.yml
</li></ul></code></pre>
<p>Diferentes versões da API do Kubernetes contêm diferentes definições de objetos, portanto, no topo deste arquivo você deve definir a <code>apiVersion</code> que você está usando para criar este objeto. Para o propósito deste tutorial, você estará usando o agrupamento <code>apps/v1</code>, pois ele contém muitas das principais definições de objeto do Kubernetes que você precisará para criar um deployment. Adicione um campo abaixo de <code>apiVersion</code>, descrevendo o <code>kind</code> ou tipo de objeto do Kubernetes que você está criando. Neste caso, você está criando um <code>Deployment</code>:</p>
<div class="code-label " title="go-app/deployment.yml">go-app/deployment.yml</div><pre class="code-pre yml"><code langs=""><span class="highlight">---</span>
<span class="highlight">apiVersion: apps/v1</span>
<span class="highlight">kind: Deployment</span>
</code></pre>
<p>Em seguida, defina o <code>metadata</code> para o seu deployment. Um campo <code>metadata</code> é necessário para todos os objetos do Kubernetes, pois contém informações como o <code>name</code> ou nome exclusivo do objeto. Este <code>name</code> é útil, pois permite distinguir diferentes deployments e identificá-los usando nomes inteligíveis:</p>
<div class="code-label " title="go-app/deployment.yml">go-app/deployment.yml</div><pre class="code-pre yml"><code langs="">---
apiVersion: apps/v1
kind: Deployment
<span class="highlight">metadata:</span>
    <span class="highlight">name: go-web-app</span>
</code></pre>
<p>Em seguida, você construirá o bloco <code>spec</code> do seu <code>deployment.yml</code>. Um campo <code>spec</code> é um requisito para todos os objetos do Kubernetes, mas seu formato exato é diferente para cada tipo de objeto. No caso de um deployment, ele pode conter informações como o número de <em>réplicas</em> que você deseja executar. No Kubernetes, uma réplica é o número de pods que você deseja executar em seu cluster. Aqui, defina o número de <code>replicas</code> para <code>5</code>:</p>
<div class="code-label " title="go-app/deployment.yml">go-app/deployment.yml</div><pre class="code-pre yml"><code langs="">. . .
metadata:
    name: go-web-app
<span class="highlight">spec:</span>
  <span class="highlight">replicas: 5</span>
</code></pre>
<p>Depois, crie um bloco <code>selector</code> aninhado sob o bloco <code>spec</code>. Isso servirá como um <em>seletor de label</em> ou <em>seletor de etiquetas</em>  para seus pods. O Kubernetes usa seletores de label para definir como o deployment encontra os pods que ele deve gerenciar.</p>

<p>Dentro deste bloco <code>selector</code>, defina <code>matchLabels</code> e adicione a label <code>name</code>. Essencialmente, o campo <code>matchLabels</code> diz ao Kubernetes para quais pods o deployment se aplica. Neste exemplo, o deployment será aplicado a todos os pods com o nome <code>go-web-app</code>:</p>
<div class="code-label " title="go-app/deployment.yml">go-app/deployment.yml</div><pre class="code-pre yml"><code langs="">. . .
spec:
  replicas: 5
  <span class="highlight">selector:</span>
    <span class="highlight">matchLabels:</span>
      <span class="highlight">name: go-web-app</span>
</code></pre>
<p>Depois disso, adicione um bloco <code>template</code>. Cada deployment cria um conjunto de pods usando as labels especificadas em um bloco <code>template</code>. O primeiro subcampo deste bloco é o <code>metadata</code>, que contém as <code>labels</code> que serão aplicadas a todos os pods deste deployment. Essas labels são pares de chave/valor que são usados como atributos de identificação de objetos do Kubernetes. Quando você definir seu serviço mais tarde, você pode especificar que deseja que todos os pods com essa label <code>name</code> sejam agrupados sob esse serviço. Defina esta label <code>name</code> para <code>go-web-app</code>:</p>
<div class="code-label " title="go-app/deployment.yml">go-app/deployment.yml</div><pre class="code-pre yml"><code langs="">. . .
spec:
  replicas: 5
  selector:
    matchLabels:
      name: go-web-app
  <span class="highlight">template:</span>
    <span class="highlight">metadata:</span>
      <span class="highlight">labels:</span>
        <span class="highlight">name: go-web-app</span>
</code></pre>
<p>A segunda parte deste bloco <code>template</code> é o bloco <code>spec</code>. Este é diferente do bloco <code>spec</code> que você adicionou anteriormente, já que este se aplica somente aos pods criados pelo bloco <code>template</code>, em vez de todo o deployment.</p>

<p>Dentro deste bloco <code>spec</code>, adicione um campo <code>containers</code> e mais uma vez defina um atributo <code>name</code>. Este campo <code>name</code> define o nome de qualquer container criado por este deployment específico. Abaixo disso, defina a imagem ou <code>image</code> que você deseja baixar e fazer o deploy. Certifique-se de alterar <code><span class="highlight">sammy</span></code> para seu próprio nome de usuário do Docker Hub:</p>
<div class="code-label " title="go-app/deployment.yml">go-app/deployment.yml</div><pre class="code-pre yml"><code langs="">. . .
  template:
    metadata:
      labels:
        name: go-web-app
    <span class="highlight">spec:</span>
      <span class="highlight">containers:</span>
      <span class="highlight">- name: application</span>
        <span class="highlight">image: </span>sammy<span class="highlight">/go-web-app</span>
</code></pre>
<p>Depois disso, adicione um campo <code>imagePullPolicy</code> definido como <code>IfNotPresent</code>, que direcionará o deployment para baixar uma imagem apenas se ainda não tiver feito isso antes. Então, por último, adicione um bloco <code>ports</code>. Lá, defina o <code>containerPort</code> que deve corresponder ao número da porta que sua aplicação Go está escutando. Neste caso, o número da porta é <code>3000</code>:</p>
<div class="code-label " title="go-app/deployment.yml">go-app/deployment.yml</div><pre class="code-pre yml"><code langs="">. . .
    spec:
      containers:
      - name: application
        image: <span class="highlight">sammy</span>/go-web-app
        <span class="highlight">imagePullPolicy: IfNotPresent</span>
        <span class="highlight">ports:</span>
          <span class="highlight">- containerPort: 3000</span>
</code></pre>
<p>A versão completa do seu arquivo <code>deployment.yml</code> ficará assim:</p>
<div class="code-label " title="go-app/deployment.yml">go-app/deployment.yml</div><pre class="code-pre yml"><code langs="">---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: go-web-app
spec:
  replicas: 5
  selector:
    matchLabels:
      name: go-web-app
  template:
    metadata:
      labels:
        name: go-web-app
    spec:
      containers:
      - name: application
        image: <span class="highlight">sammy</span>/go-web-app
        imagePullPolicy: IfNotPresent
        ports:
          - containerPort: 3000
</code></pre>
<p>Salve e feche o arquivo.</p>

<p>Em seguida, aplique seu novo deployment com o seguinte comando:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f deployment.yml
</li></ul></code></pre>
<p><span class='note'><strong>Nota:</strong> Para mais informações sobre todas as configurações disponíveis para seus deployments, confira a documentação oficial do Kubernetes aqui: <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Kubernetes Deployments</a><br></span></p>

<p>Na próxima etapa, você criará outro tipo de objeto do Kubernetes que gerenciará como você vai acessar os pods existentes em seu novo deployment. Esse serviço criará um balanceador de carga que, então, vai expor um único endereço IP, e as solicitações para esse endereço IP serão distribuídas para as réplicas em seu deployment. Esse serviço também manipulará regras de encaminhamento de porta para que você possa acessar sua aplicação por HTTP.</p>

<h2 id="passo-5-—-criando-um-serviço">Passo 5 — Criando um Serviço</h2>

<p>Agora que você tem um deployment bem sucedido do Kubernetes, está pronto para expor sua aplicação ao mundo externo. Para fazer isso, você precisará definir outro tipo de objeto do Kubernetes: um <em>service</em>. Este serviço irá expor a mesma porta em todos os nodes do cluster. Então, seus nodes encaminharão qualquer tráfego de entrada nessa porta para os pods que estiverem executando sua aplicação.</p>

<p><span class='note'><strong>Nota:</strong> Para maior clareza, vamos definir esse objeto de serviço em um arquivo separado. No entanto, é possível agrupar vários manifests de recursos no mesmo arquivo YAML, contanto que estejam separados por <code>---</code>. Veja <a href="https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#organizing-resource-configurations">esta página da documentação do Kubernetes</a> para maiores detalhes.<br></span></p>

<p>Crie um novo arquivo chamado <code>service.yml</code>:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">nano service.yml
</li></ul></code></pre>
<p>Inicie este arquivo novamente definindo os campos <code>apiVersion</code> e <code>kind</code> de maneira similar ao seu arquivo <code>deployment.yml</code>. Desta vez, aponte o campo <code>apiVersion</code> para <code>v1</code>, a API do Kubernetes comumente usada para serviços:</p>
<div class="code-label " title="go-app/service.yml">go-app/service.yml</div><pre class="code-pre yml"><code langs=""><span class="highlight">---</span>
<span class="highlight">apiVersion: v1</span>
<span class="highlight">kind: Service</span>
</code></pre>
<p>Em seguida, adicione o nome do seu serviço em um bloco <code>metadata</code> como você fez em <code>deployment.yml</code>. Pode ser qualquer coisa que você goste, mas para clareza, vamos chamar de <code>go-web-service</code>:</p>
<div class="code-label " title="go-app/service.yml">go-app/service.yml</div><pre class="code-pre yml"><code langs="">---
apiVersion: v1
kind: Service
<span class="highlight">metadata:</span>
  <span class="highlight">name: go-web-service</span>
</code></pre>
<p>Em seguida, crie um bloco <code>spec</code>. Este bloco <code>spec</code> será diferente daquele incluído em seu deployment, e ele conterá o tipo ou <code>type</code> deste serviço, assim como a configuração de encaminhamento de porta e o <code>seletor</code>.</p>

<p>Adicione um campo definindo o <code>type</code> deste serviço e defina-o para <code>LoadBalancer</code>. Isso provisionará automaticamente um balanceador de carga que atuará como o principal ponto de entrada para sua aplicação.</p>

<p><span class='warning'><strong>Atenção:</strong> O método para criar um balanceador de carga descrito nesta etapa só funcionará para clusters Kubernetes provisionados por provedores de nuvem que também suportam balanceadores de carga externos. Além disso, esteja ciente de que provisionar um balanceador de carga de um provedor de nuvem incorrerá em custos adicionais. Se isto é uma preocupação para você, você pode querer olhar a exposição de um endereço IP externo usando um <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/">Ingress</a>.<br></span></p>
<div class="code-label " title="go-app/service.yml">go-app/service.yml</div><pre class="code-pre yml"><code langs="">---
apiVersion: v1
kind: Service
metadata:
  name: go-web-service
<span class="highlight">spec:</span>
  <span class="highlight">type: LoadBalancer</span>
</code></pre>
<p>Em seguida, adicione um bloco <code>ports</code> onde você definirá como deseja que seus apps sejam acessados. Aninhado dentro deste bloco, adicione os seguintes campos:</p>

<ul>
<li><code>name</code>, apontando para <code>http</code></li>
<li><code>port</code>, apontando para a porta <code>80</code></li>
<li><code>targetPort</code>, apontando para a porta <code>3000</code></li>
</ul>

<p>Isto irá pegar solicitações HTTP de entrada na porta <code>80</code> e encaminhá-las para o <code>targetPort</code> de <code>3000</code>. Este <code>targetPort</code> é a mesma porta na qual sua aplicação Go está rodando:</p>
<div class="code-label " title="go-app/service.yml">go-app/service.yml</div><pre class="code-pre yml"><code langs="">---
apiVersion: v1
kind: Service
metadata:
  name: go-web-service
spec:
  type: LoadBalancer
  <span class="highlight">ports:</span>
  <span class="highlight">- name: http</span>
    <span class="highlight">port: 80</span>
    <span class="highlight">targetPort: 3000</span>
</code></pre>
<p>Por último, adicione um bloco <code>selector</code> como você fez no arquivo <code>deployments.yml</code>. Este bloco <code>selector</code> é importante, pois mapeia quaisquer pods <em>deployados</em> chamados <code>go-web-app</code> para este serviço:</p>
<div class="code-label " title="go-app/service.yml">go-app/service.yml</div><pre class="code-pre yml"><code langs="">---
apiVersion: v1
kind: Service
metadata:
  name: go-web-service
spec:
  type: LoadBalancer
  ports:
  - name: http
    port: 80
    targetPort: 3000
  <span class="highlight">selector:</span>
    <span class="highlight">name: go-web-app</span>
</code></pre>
<p>Depois de adicionar essas linhas, salve e feche o arquivo. Depois disso, aplique este serviço ao seu cluster do Kubernetes novamente usando o comando <code>kubectl apply</code> assim:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl apply -f service.yml
</li></ul></code></pre>
<p>Esse comando aplicará o novo serviço do Kubernetes, além de criar um balanceador de carga. Esse balanceador de carga servirá como o ponto de entrada voltado ao público para a sua aplicação em execução no cluster.</p>

<p>Para visualizar a aplicação, você precisará do endereço IP do novo balanceador de carga. Encontre-o executando o seguinte comando:</p>
<pre class="code-pre command"><code langs=""><ul class="prefixed"><li class="line" prefix="$">kubectl get services
</li></ul></code></pre><pre class="code-pre "><code langs=""><div class="secondary-code-label " title="Output">Output</div>NAME             TYPE           CLUSTER-IP       EXTERNAL-IP       PORT(S)        AGE
go-web-service   LoadBalancer   10.245.107.189   <span class="highlight">203.0.113.20</span>   80:30533/TCP   10m
kubernetes       ClusterIP      10.245.0.1       &lt;none&gt;            443/TCP        3h4m
</code></pre>
<p>Você pode ter mais de um serviço em execução, mas encontre o que está com a label <code>go-web-service</code>. Encontre a coluna <code>EXTERNAL-IP</code> e copie o endereço IP associado ao <code>go-web-service</code>. Neste exemplo de saída, este endereço IP é <code><span class="highlight">203.0.113.20</span></code>. Em seguida, cole o endereço IP na barra de URL do seu navegador para visualizar a aplicação em execução no seu cluster Kubernetes.</p>

<p><span class='note'><strong>Nota:</strong> Quando o Kubernetes cria um balanceador de carga dessa maneira, ele faz isso de forma assíncrona. Consequentemente, a saída do comando <code>kubectl get services</code> pode mostrar o endereço <code>EXTERNAL-IP</code> do <code>LoadBalancer</code> restante em um estado <code>&lt;pending&gt;</code> por algum tempo após a execução do comando <code>kubectl apply</code>. Se for esse o caso, aguarde alguns minutos e tente executar novamente o comando para garantir que o balanceador de carga foi criado e está funcionando conforme esperado.<br></span></p>

<p>O balanceador de carga receberá a solicitação na porta <code>80</code> e a encaminhará para um dos pods em execução no seu cluster.</p>

<p><img src="https://assets.digitalocean.com/articles/resilient_go_kubernetes/resilient_screenshot_2.png" alt="Your working Go App!"></p>

<p>Com isso, você criou um serviço Kubernetes acoplado a um balanceador de carga, oferecendo um ponto de entrada único e estável para a aplicação.</p>

<h2 id="conclusão">Conclusão</h2>

<p>Neste tutorial, você criou uma aplicação Go, containerizada com o Docker e, em seguida, fez o deploy dela em um cluster Kubernetes. Em seguida, você criou um balanceador de carga que fornece um ponto de entrada resiliente para essa aplicação, garantindo que ela permaneça altamente disponível, mesmo se um dos nodes do cluster falhar. Você pode usar este tutorial para fazer o deploy da sua própria aplicação Go em um cluster Kubernetes ou continuar aprendendo outros conceitos do Kubernetes e do Docker com a aplicação de exemplo que você criou no Passo 1.</p>

<p>Seguindo em frente, você pode <a href="https://www.digitalocean.com/community/tutorials/how-to-point-to-digitalocean-nameservers-from-common-domain-registrars">mapear o endereço IP do seu balanceador de carga para um nome de domínio que você controla</a> para que você possa acessar a aplicação por meio de um endereço web legível em vez do IP do balanceador de carga. Além disso, os seguintes tutoriais de Kubernetes podem ser de seu interesse:</p>

<ul>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-automate-deployments-to-digitalocean-kubernetes-with-circleci">How to Automate Deployments to DigitalOcean Kubernetes with CircleCI</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/white-paper-running-cloud-native-applications-on-digitalocean-kubernetes">White Paper: Running Cloud Native Applications on DigitalOcean Kubernetes</a></li>
</ul>

<p>Por fim, se você quiser saber mais sobre o Go, recomendamos que você confira nossa série sobre <a href="https://www.digitalocean.com/community/tutorial_series/how-to-code-in-go">Como Programar em Go</a>.</p>
